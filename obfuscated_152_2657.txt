[CmdletBinding()]
Param
(
	
	[switch]$ShowInstallationPrompt = $false,
	[switch]$ShowInstallationRestartPrompt = $false,
	[switch]$CleanupBlockedApps = $false,
	[switch]$ShowBlockedAppDialog = $false,
	[switch]$DisableLogging = $false,
	[string]$ReferringApplication = '',
	[string]$Message = '',
	[string]$MessageAlignment = '',
	[string]$ButtonRightText = '',
	[string]$ButtonLeftText = '',
	[string]$ButtonMiddleText = '',
	[string]$Icon = '',
	[string]$Timeout = '',
	[switch]$ExitOnTimeout = $false,
	[boolean]$MinimizeWindows = $false,
	[switch]$PersistPrompt = $false,
	[int32]$CountdownSeconds,
	[int32]$CountdownNoHideSeconds,
	[switch]$NoCountdown = $false,
	[switch]$RelaunchToolkitAsUser = $false
)







[string]$appDeployToolkitName = ("{2}{4}{1}{5}{0}{3}"-f 'o','yT','PSA','lkit','ppDeplo','o')
[string]$appDeployMainScriptFriendlyName = ("{4}{2}{5}{1}{3}{0}"-f 'ain','k','y T','it M','App Deplo','ool')


[version]$appDeployMainScriptVersion = [version]("{1}{0}"-f '0','3.6.')
[version]$appDeployMainScriptMinimumConfigVersion = [version]("{0}{1}"-f '3.','6.0')
[string]$appDeployMainScriptDate = ("{2}{0}{1}"-f '20','14','12/18/')
[hashtable]$appDeployMainScriptParameters = $PSBoundParameters


[string]$currentTime = (Get-Date -UFormat '%T').ToString()
[string]$currentDate = (Get-Date -UFormat ("{0}{1}"-f '%d-%m','-%Y')).ToString()
[timespan]$currentTimeZoneBias = [System.TimeZone]::CurrentTimeZone.GetUtcOffset([datetime]::Now)
[Globalization.CultureInfo]$culture = Get-Culture
[string]$currentLanguage = $culture.TwoLetterISOLanguageName.ToUpper()


[psobject]$envHost = $Host
[string]$envAllUsersProfile = $env:ALLUSERSPROFILE
[string]$envAppData = $env:APPDATA
[string]$envArchitecture = $env:PROCESSOR_ARCHITECTURE
[string]$envCommonProgramFiles = $env:CommonProgramFiles
[string]$envCommonProgramFilesX86 = ${env:CommonProgramFiles(x86)}
[string]$envComputerName = $env:COMPUTERNAME | Where-Object { $_ } | ForEach-Object { $_.ToUpper() }
[string]$envComputerNameFQDN = ([System.Net.Dns]::GetHostEntry('')).HostName
[string]$envHomeDrive = $env:HOMEDRIVE
[string]$envHomePath = $env:HOMEPATH
[string]$envHomeShare = $env:HOMESHARE
[string]$envLocalAppData = $env:LOCALAPPDATA
[string]$envProgramFiles = $env:PROGRAMFILES
[string]$envProgramFilesX86 = ${env:ProgramFiles(x86)}
[string]$envProgramData = $env:PROGRAMDATA
[string]$envPublic = $env:PUBLIC
[string]$envSystemDrive = $env:SYSTEMDRIVE
[string]$envSystemRoot = $env:SYSTEMROOT
[string]$envTemp = $env:TEMP
[string]$envUserName = $env:USERNAME
[string]$envUserProfile = $env:USERPROFILE
[string]$envWinDir = $env:WINDIR

If (-not $envCommonProgramFilesX86) { [string]$envCommonProgramFilesX86 = $env:CommonProgramFiles }
If (-not $envProgramFilesX86) { [string]$envProgramFilesX86 = $env:PROGRAMFILES }


[boolean]$IsMachinePartOfDomain = (Get-WmiObject Win32_ComputerSystem -ErrorAction ("{2}{1}{3}{0}"-f 'inue','lyCon','Silent','t')).PartOfDomain
[string]$envMachineWorkgroup = ''
[string]$envMachineADDomain = ''
[string]$envLogonServer = ''
[string]$MachineDomainController = ''
If ($IsMachinePartOfDomain) {
	[string]$envMachineADDomain = (Get-WmiObject -Class Win32_ComputerSystem -ErrorAction ("{2}{0}{1}"-f 'tlyConti','nue','Silen')).Domain | Where-Object { $_ } | ForEach-Object { $_.ToLower() }
	Try {
		[string]$envLogonServer = $env:LOGONSERVER | Where-Object { (($_) -and (-not $_.Contains(((("{1}{0}{2}{3}{4}"-f '0','{0}{','}Micro','softAcco','unt'))-F [cHar]92)))) } | ForEach-Object { $_.TrimStart('\') } | ForEach-Object { ([System.Net.Dns]::GetHostEntry($_)).HostName }
		[string]$MachineDomainController = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().FindDomainController().Name
	}
	Catch { }
}
Else {
	[string]$envMachineWorkgroup = (Get-WmiObject -Class Win32_ComputerSystem -ErrorAction ("{2}{1}{0}" -f 'ue','ilentlyContin','S')).Domain | Where-Object { $_ } | ForEach-Object { $_.ToUpper() }
}
[string]$envMachineDNSDomain = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties().DomainName | Where-Object { $_ } | ForEach-Object { $_.ToLower() }
[string]$envUserDNSDomain = $env:USERDNSDOMAIN | Where-Object { $_ } | ForEach-Object { $_.ToLower() }
[string]$envUserDomain = $env:USERDOMAIN | Where-Object { $_ } | ForEach-Object { $_.ToUpper() }


[psobject]$envOS = Get-WmiObject -Class Win32_OperatingSystem -ErrorAction ("{1}{0}{3}{4}{2}"-f'e','Sil','nue','n','tlyConti')
[string]$envOSName = $envOS.Caption.Trim()
[string]$envOSServicePack = $envOS.CSDVersion
[version]$envOSVersion = [System.Environment]::OSVersion.Version
[string]$envOSVersionMajor = $envOSVersion.Major
[string]$envOSVersionMinor = $envOSVersion.Minor
[string]$envOSVersionBuild = $envOSVersion.Build
[string]$envOSVersionRevision = $envOSVersion.Revision
[string]$envOSVersion = $envOSVersion.ToString()

[int32]$envOSProductType = $envOS.ProductType
[boolean]$IsServerOS = [boolean]($envOSProductType -eq 3)
[boolean]$IsDomainControllerOS = [boolean]($envOSProductType -eq 2)
[boolean]$IsWorkStationOS = [boolean]($envOSProductType -eq 1)
Switch ($envOSProductType) {
	3 { [string]$envOSProductTypeName = ("{0}{2}{1}"-f'Se','er','rv') }
	2 { [string]$envOSProductTypeName = ("{4}{1}{3}{2}{0}"-f 'er','n','ontroll',' C','Domai') }
	1 { [string]$envOSProductTypeName = ("{0}{1}{2}{3}" -f 'Wo','rk','sta','tion') }
	Default { [string]$envOSProductTypeName = ("{2}{1}{0}"-f 'wn','o','Unkn') }
}

[boolean]$Is64Bit = [boolean]((Get-WmiObject -Class Win32_Processor | Where-Object { $_.DeviceID -eq ("{1}{0}"-f'U0','CP') } | Select-Object -ExpandProperty AddressWidth) -eq '64')
If ($Is64Bit) { [string]$envOSArchitecture = ("{0}{1}{2}"-f'6','4-bi','t') } Else { [string]$envOSArchitecture = ("{1}{0}"-f 'bit','32-') }


[boolean]$Is64BitProcess = [boolean]([System.IntPtr]::Size -eq 8)
If ($Is64BitProcess) { [string]$psArchitecture = 'x64' } Else { [string]$psArchitecture = 'x86' }


[hashtable]$envPSVersionTable = $PSVersionTable

[version]$envPSVersion = $envPSVersionTable.PSVersion
[string]$envPSVersionMajor = $envPSVersion.Major
[string]$envPSVersionMinor = $envPSVersion.Minor
[string]$envPSVersionBuild = $envPSVersion.Build
[string]$envPSVersionRevision = $envPSVersion.Revision
[string]$envPSVersion = $envPSVersion.ToString()

[version]$envCLRVersion = $envPSVersionTable.CLRVersion
[string]$envCLRVersionMajor = $envCLRVersion.Major
[string]$envCLRVersionMinor = $envCLRVersion.Minor
[string]$envCLRVersionBuild = $envCLRVersion.Build
[string]$envCLRVersionRevision = $envCLRVersion.Revision
[string]$envCLRVersion = $envCLRVersion.ToString()


[System.Security.Principal.WindowsIdentity]$CurrentProcessToken = [System.Security.Principal.WindowsIdentity]::GetCurrent()
[System.Security.Principal.SecurityIdentifier]$CurrentProcessSID = $CurrentProcessToken.User
[string]$ProcessNTAccount = $CurrentProcessToken.Name
[string]$ProcessNTAccountSID = $CurrentProcessSID.Value
[boolean]$IsAdmin = [boolean]($CurrentProcessToken.Groups -contains [System.Security.Principal.SecurityIdentifier]("{1}{0}{3}{2}"-f '-','S-1','44','5-32-5'))
[boolean]$IsLocalSystemAccount = $CurrentProcessSID.IsWellKnown([System.Security.Principal.WellKnownSidType]("{2}{3}{1}{0}"-f 'd','SystemSi','Lo','cal'))
[boolean]$IsLocalServiceAccount = $CurrentProcessSID.IsWellKnown([System.Security.Principal.WellKnownSidType]("{0}{2}{1}{3}{4}" -f'Loc','l','a','Servi','ceSid'))
[boolean]$IsNetworkServiceAccount = $CurrentProcessSID.IsWellKnown([System.Security.Principal.WellKnownSidType]("{3}{1}{4}{2}{0}"-f 'rviceSid','two','kSe','Ne','r'))
[boolean]$IsServiceAccount = [boolean]($CurrentProcessToken.Groups -contains [System.Security.Principal.SecurityIdentifier]("{1}{2}{0}"-f '5-6','S','-1-'))
[boolean]$IsProcessUserInteractive = [System.Environment]::UserInteractive
[string]$LocalSystemNTAccount = (New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList ([Security.Principal.WellKnownSidType]::("{0}{1}{3}{2}"-f'LocalSys','t','mSid','e'), $null)).Translate([System.Security.Principal.NTAccount]).Value

If ($IsLocalSystemAccount -or $IsLocalServiceAccount -or $IsNetworkServiceAccount -or $IsServiceAccount) { $SessionZero = $true } Else { $SessionZero = $false }


[int32]$dpiPixels = Get-ItemProperty -Path ((("{9}{12}{14}{17}{6}{7}{4}{0}{8}{15}{3}{2}{5}{10}{1}{16}{13}{11}"-f'icr','u','Wind','t','tM','ow','RE','SV','osof','HK','s NTSVtC','ntDPI','L','ionSVtFo','M:SO','tSV','rrentVers','FTWA'))  -rEPLaCE 'SVt',[cHAR]92) -ErrorAction ("{1}{2}{3}{4}{0}"-f 'ue','S','ilen','tlyCo','ntin') | Select-Object -ExpandProperty LogPixels -ErrorAction ("{1}{0}{2}{3}"-f 'l','Silent','yC','ontinue')
Switch ($dpiPixels) {
	96 { [int32]$dpiScale = 100 }
	120 { [int32]$dpiScale = 125 }
	144 { [int32]$dpiScale = 150 }
	192 { [int32]$dpiScale = 200 }
	Default { [int32]$dpiScale = 100 }
}


[string]$scriptPath = $MyInvocation.MyCommand.Definition
[string]$scriptName = [System.IO.Path]::GetFileNameWithoutExtension($scriptPath)
[string]$scriptFileName = Split-Path -Path $scriptPath -Leaf
[string]$scriptRoot = Split-Path -Path $scriptPath -Parent
[string]$invokingScript = (Get-Variable -Name MyInvocation).Value.ScriptName

If ($invokingScript) {
	
	[string]$scriptParentPath = Split-Path -Path $invokingScript -Parent
}
Else {
	
	[string]$scriptParentPath = (Get-Item -Path $scriptRoot).Parent.FullName
}


[string]$appDeployLogoIcon = Join-Path -Path $scriptRoot -ChildPath ("{5}{3}{6}{2}{1}{4}{0}" -f'Logo.ico','l','o','p','kit','Ap','DeployTo')
[string]$appDeployLogoBanner = Join-Path -Path $scriptRoot -ChildPath ("{8}{7}{0}{2}{5}{3}{4}{6}{1}" -f'plo','g','yToolki','B','an','t','ner.pn','pDe','Ap')
[string]$appDeployConfigFile = Join-Path -Path $scriptRoot -ChildPath ("{2}{3}{5}{4}{1}{6}{0}{7}"-f '.xm','lkit','Ap','pDe','oyToo','pl','Config','l')

[string]$appDeployToolkitDotSourceExtensions = ("{8}{0}{5}{7}{4}{1}{3}{2}{6}" -f'l','xt','ons','ensi','itE','oyTo','.ps1','olk','AppDep')

If (-not (Test-Path -Path $AppDeployLogoIcon -PathType Leaf)) { Throw ("{5}{0}{6}{4}{2}{1}{3}" -f'o','ot fou','n','nd.','on file ','App Depl','y logo ic') }
If (-not (Test-Path -Path $AppDeployLogoBanner -PathType Leaf)) { Throw ("{0}{1}{5}{3}{6}{4}{7}{2}" -f'App',' Dep','.','er fil','ot fo','loy logo bann','e n','und') }
If (-not (Test-Path -Path $AppDeployConfigFile -PathType Leaf)) { Throw ("{8}{11}{5}{1}{6}{7}{12}{9}{2}{3}{10}{0}{4}" -f' fou','eploy XML','file',' ','nd.',' D',' co','nfigurati','Ap',' ','not','p','on') }


[xml]$xmlConfigFile = Get-Content -Path $AppDeployConfigFile
$xmlConfig = $xmlConfigFile.AppDeployToolkit_Config

$configConfigDetails = $xmlConfig.Config_File
[string]$configConfigVersion = [version]$configConfigDetails.Config_Version
[string]$configConfigDate = $configConfigDetails.Config_Date

$xmlToolkitOptions = $xmlConfig.Toolkit_Options
[boolean]$configToolkitRequireAdmin = [boolean]::Parse($xmlToolkitOptions.Toolkit_RequireAdmin)
[boolean]$configToolkitAllowSystemInteraction = [boolean]::Parse($xmlToolkitOptions.Toolkit_AllowSystemInteraction)
[boolean]$configToolkitAllowSystemInteractionFallback = [boolean]::Parse($xmlToolkitOptions.Toolkit_AllowSystemInteractionFallback)
[boolean]$configToolkitAllowSystemInteractionForNonConsoleUser = [boolean]::Parse($xmlToolkitOptions.Toolkit_AllowSystemInteractionForNonConsoleUser)
[string]$configToolkitTempPath = $ExecutionContext.InvokeCommand.ExpandString($xmlToolkitOptions.Toolkit_TempPath)
[string]$configToolkitRegPath = $xmlToolkitOptions.Toolkit_RegPath
[string]$configToolkitLogDir = $ExecutionContext.InvokeCommand.ExpandString($xmlToolkitOptions.Toolkit_LogPath)
[boolean]$configToolkitCompressLogs = [boolean]::Parse($xmlToolkitOptions.Toolkit_CompressLogs)
[string]$configToolkitLogStyle = $xmlToolkitOptions.Toolkit_LogStyle
[double]$configToolkitLogMaxSize = $xmlToolkitOptions.Toolkit_LogMaxSize
[boolean]$configToolkitLogWriteToHost = [boolean]::Parse($xmlToolkitOptions.Toolkit_LogWriteToHost)
[boolean]$configToolkitLogDebugMessage = [boolean]::Parse($xmlToolkitOptions.Toolkit_LogDebugMessage)

$xmlConfigMSIOptions = $xmlConfig.MSI_Options
[string]$configMSILoggingOptions = $xmlConfigMSIOptions.MSI_LoggingOptions
[string]$configMSIInstallParams = $xmlConfigMSIOptions.MSI_InstallParams
[string]$configMSISilentParams = $xmlConfigMSIOptions.MSI_SilentParams
[string]$configMSIUninstallParams = $xmlConfigMSIOptions.MSI_UninstallParams
[string]$configMSILogDir = $ExecutionContext.InvokeCommand.ExpandString($xmlConfigMSIOptions.MSI_LogPath)
[int32]$configMSIMutexWaitTime = $xmlConfigMSIOptions.MSI_MutexWaitTime

$xmlConfigUIOptions = $xmlConfig.UI_Options
[boolean]$configShowBalloonNotifications = [boolean]::Parse($xmlConfigUIOptions.ShowBalloonNotifications)
[int32]$configInstallationUITimeout = $xmlConfigUIOptions.InstallationUI_Timeout
[int32]$configInstallationUIExitCode = $xmlConfigUIOptions.InstallationUI_ExitCode
[int32]$configInstallationDeferExitCode = $xmlConfigUIOptions.InstallationDefer_ExitCode
[int32]$configInstallationPersistInterval = $xmlConfigUIOptions.InstallationPrompt_PersistInterval
[int32]$configInstallationRestartPersistInterval = $xmlConfigUIOptions.InstallationRestartPrompt_PersistInterval

[string]$xmlUIMessageLanguage = "UI_Messages_$currentLanguage"
If (-not ($xmlConfig.$xmlUIMessageLanguage)) { [string]$xmlUIMessageLanguage = ("{0}{2}{1}{3}"-f'UI_Me','E','ssages_','N') }
$xmlUIMessages = $xmlConfig.$xmlUIMessageLanguage
[string]$configDiskSpaceMessage = $xmlUIMessages.DiskSpace_Message
[string]$configBalloonTextStart = $xmlUIMessages.BalloonText_Start
[string]$configBalloonTextComplete = $xmlUIMessages.BalloonText_Complete
[string]$configBalloonTextRestartRequired = $xmlUIMessages.BalloonText_RestartRequired
[string]$configBalloonTextFastRetry = $xmlUIMessages.BalloonText_FastRetry
[string]$configBalloonTextError = $xmlUIMessages.BalloonText_Error
[string]$configProgressMessageInstall = $xmlUIMessages.Progress_MessageInstall
[string]$configProgressMessageUninstall = $xmlUIMessages.Progress_MessageUninstall
[string]$configClosePromptMessage = $xmlUIMessages.ClosePrompt_Message
[string]$configClosePromptButtonClose = $xmlUIMessages.ClosePrompt_ButtonClose
[string]$configClosePromptButtonDefer = $xmlUIMessages.ClosePrompt_ButtonDefer
[string]$configClosePromptButtonContinue = $xmlUIMessages.ClosePrompt_ButtonContinue
[string]$configClosePromptCountdownMessage = $xmlUIMessages.ClosePrompt_CountdownMessage
[string]$configDeferPromptWelcomeMessage = $xmlUIMessages.DeferPrompt_WelcomeMessage
[string]$configDeferPromptExpiryMessage = $xmlUIMessages.DeferPrompt_ExpiryMessage
[string]$configDeferPromptWarningMessage = $xmlUIMessages.DeferPrompt_WarningMessage
[string]$configDeferPromptRemainingDeferrals = $xmlUIMessages.DeferPrompt_RemainingDeferrals
[string]$configDeferPromptDeadline = $xmlUIMessages.DeferPrompt_Deadline
[string]$configBlockExecutionMessage = $xmlUIMessages.BlockExecution_Message
[string]$configDeploymentTypeInstall = $xmlUIMessages.DeploymentType_Install
[string]$configDeploymentTypeUnInstall = $xmlUIMessages.DeploymentType_UnInstall
[string]$configRestartPromptTitle = $xmlUIMessages.RestartPrompt_Title
[string]$configRestartPromptMessage = $xmlUIMessages.RestartPrompt_Message
[string]$configRestartPromptMessageTime = $xmlUIMessages.RestartPrompt_MessageTime
[string]$configRestartPromptMessageRestart = $xmlUIMessages.RestartPrompt_MessageRestart
[string]$configRestartPromptTimeRemaining = $xmlUIMessages.RestartPrompt_TimeRemaining
[string]$configRestartPromptButtonRestartLater = $xmlUIMessages.RestartPrompt_ButtonRestartLater
[string]$configRestartPromptButtonRestartNow = $xmlUIMessages.RestartPrompt_ButtonRestartNow


[string]$dirFiles = Join-Path -Path $scriptParentPath -ChildPath ("{1}{0}" -f'iles','F')
[string]$dirSupportFiles = Join-Path -Path $scriptParentPath -ChildPath ("{3}{2}{0}{1}"-f'ortFile','s','upp','S')
[string]$dirAppDeployTemp = Join-Path -Path $configToolkitTempPath -ChildPath $appDeployToolkitName


If (-not $appVendor) { [string]$appVendor = 'PS' }
If (-not $appName) { [string]$appName = $appDeployMainScriptFriendlyName }
If (-not $appVersion) { [string]$appVersion = $appDeployMainScriptVersion }
If (-not $appLang) { [string]$appLang = $currentLanguage }
If (-not $appRevision) { [string]$appRevision = '01' }
If (-not $appArch) { [string]$appArch = '' }
[string]$installTitle = ("$appVendor "+"$appName "+"$appVersion")


[char[]]$invalidFileNameChars = [System.IO.Path]::GetInvalidFileNamechars()
[string]$appVendor = $appVendor -replace "[$invalidFileNameChars]",'' -replace ' ',''
[string]$appName = $appName -replace "[$invalidFileNameChars]",'' -replace ' ',''
[string]$appVersion = $appVersion -replace "[$invalidFileNameChars]",'' -replace ' ',''
[string]$appArch = $appArch -replace "[$invalidFileNameChars]",'' -replace ' ',''
[string]$appLang = $appLang -replace "[$invalidFileNameChars]",'' -replace ' ',''
[string]$appRevision = $appRevision -replace "[$invalidFileNameChars]",'' -replace ' ',''


If ($appArch) {
	[string]$installName = $appVendor + '_' + $appName + '_' + $appVersion + '_' + $appArch + '_' + $appLang + '_' + $appRevision
}
Else {
	[string]$installName = $appVendor + '_' + $appName + '_' + $appVersion + '_' + $appLang + '_' + $appRevision
}
[string]$installName = $installName.Trim('_') -replace ("{1}{0}"-f']+','[_'),'_'


If (-not $deploymentType) { [string]$deploymentType = ("{0}{2}{1}"-f 'Inst','l','al') }


[string]$exeWusa = ("{2}{0}{1}" -f'usa.','exe','w') 
[string]$exeMsiexec = ("{0}{2}{1}" -f 'msi','xec.exe','e') 
[string]$exeSchTasks = "$envWinDir\System32\schtasks.exe" 


[string]$MSIProductCodeRegExPattern = '^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$'



[string[]]$regKeyApplications = ((("{0}{4}{11}{10}{2}{6}{7}{8}{1}{5}{3}{12}{9}" -f 'HKLM','s','o','n',':SOFTWAREH1KMic','io','wsH1KCu','rr','entVer','ninstall','oftH1KWind','ros','H1KU'))  -CrEPLAcE'H1K',[chaR]92),((("{14}{5}{2}{10}{1}{8}{7}{6}{13}{12}{11}{9}{0}{3}{4}" -f 'ersionC8SUn','Wow64','OFTW','in','stall','S','C','e','32Nod','dowsC8SCurrentV','AREC8S','crosoftC8SWin','SMi','8','HKLM:')).REPlace('C8S','\'))
If ($is64Bit) {
	[string]$regKeyLotusNotes = ((("{7}{1}{3}{6}{5}{0}{9}{2}{11}{8}{10}{4}"-f 'ode{0}Lot','LM:SOF','{','TWA','es','E{0}Wow6432N','R','HK','N','us','ot','0}'))  -f[CHar]92)
}
Else {
	[string]$regKeyLotusNotes = ((("{2}{0}{4}{1}{3}{5}" -f 'LM:S','FTWAR','HK','EBMCLotus','O','BMCNotes')).rePlaCE('BMC','\'))
}
[string]$regKeyAppExecution = ((("{1}{9}{6}{0}{13}{12}{3}{10}{11}{2}{7}{5}{14}{8}{4}"-f 'Micro','HKLM:SOFTWAR','0}Ima','ndows NT{','ons','ti','}','ge File Execu','Opti','E{0','0}Curre','ntVersion{','t{0}Wi','sof','on ')) -F [ChaR]92)
[string]$regKeyDeferHistory = "$configToolkitRegPath\$appDeployToolkitName\DeferHistory\$installName"


[__comobject]$Shell = New-Object -ComObject WScript.Shell -ErrorAction ("{0}{1}{3}{2}"-f'Si','len','inue','tlyCont')
[__comobject]$ShellApp = New-Object -ComObject Shell.Application -ErrorAction ("{0}{2}{3}{1}"-f'Silen','ue','tl','yContin')


[boolean]$msiRebootDetected = $false
[boolean]$BlockExecution = $false
[boolean]$installationStarted = $false
[boolean]$runningTaskSequence = $false
If (Test-Path -Path ("{3}{2}{4}{0}{1}"-f'm','eTimer','ab','vari','le:welco')) { Remove-Variable -Name welcomeTimer -Scope Script}

If (Test-Path -Path ("{1}{0}{3}{2}"-f'le:de','variab','ory','ferHist')) { Remove-Variable -Name deferHistory }
If (Test-Path -Path ("{1}{4}{3}{5}{0}{2}"-f 'm','var','es','able:','i','deferTi')) { Remove-Variable -Name deferTimes }
If (Test-Path -Path ("{1}{0}{2}{3}" -f'ariable','v',':defer','Days')) { Remove-Variable -Name deferDays }


[string]$logName = $installName + '_' + $appDeployToolkitName + '_' + $deploymentType + ("{1}{0}"-f 'g','.lo')
[string]$logTempFolder = Join-Path -Path $envTemp -ChildPath $installName
If ($configToolkitCompressLogs) {
	
	
	[string]$logDirectory = $logTempFolder
	
	[string]$zipFileDate = (Get-Date -Format ("{3}{1}{0}{2}{4}" -f'M-dd','y-M','-','yyy','hh-mm-ss')).ToString()
	[string]$zipFileName = Join-Path -Path $configToolkitLogDir -ChildPath ($installName + '_' + $deploymentType + '_' + $zipFileDate + ("{0}{1}" -f '.','zip'))
	
	
	If (Test-Path -Path $logTempFolder -PathType Container -ErrorAction ("{1}{2}{0}" -f'e','Sil','entlyContinu')) {
		Remove-Item -Path $logTempFolder -Recurse -Force -ErrorAction ("{1}{2}{4}{3}{0}" -f'nue','S','i','yConti','lentl') | Out-Null
	}
}
Else {
	
	[string]$logDirectory = $configToolkitLogDir
}












Function Write-FunctionHeaderOrFooter {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$CmdletName,
		[Parameter(Mandatory=$true,ParameterSetName="hEa`DER")]
		[AllowEmptyCollection()]
		[hashtable]$CmdletBoundParameters,
		[Parameter(Mandatory=$true,ParameterSetName="He`AdeR")]
		[switch]$Header,
		[Parameter(Mandatory=$true,ParameterSetName="foot`ER")]
		[switch]$Footer
	)
	
	If ($Header) {
		Write-Log -Message ("{1}{3}{0}{2}" -f 'tion','F',' Start','unc') -Source ${CmdletName} -DebugMessage
		
		
		[string]$CmdletBoundParameters = $CmdletBoundParameters | Format-Table -Property @{ Label = ("{1}{0}{2}" -f'ar','P','ameter'); Expression = { "[-$($_.Key)]" } }, @{ Label = ("{0}{1}"-f'V','alue'); Expression = { $_.Value }; Alignment = ("{1}{0}" -f'eft','L') } -AutoSize -Wrap | Out-String
		If ($CmdletBoundParameters) {
			Write-Log -Message ('Funct'+'io'+'n '+'inv'+'oke'+'d '+'with'+' '+'boun'+'d '+'para'+'meter(s'+')'+': '+"`n$CmdletBoundParameters") -Source ${CmdletName} -DebugMessage
		}
		Else {
			Write-Log -Message ("{1}{4}{7}{8}{6}{5}{0}{2}{9}{3}" -f ' param','Function invoked wit','et','rs','h','ound','ny b','out ','a','e') -Source ${CmdletName} -DebugMessage
		}
	}
	ElseIf ($Footer) {
		Write-Log -Message ("{3}{0}{2}{1}"-f 'ct','nd','ion E','Fun') -Source ${CmdletName} -DebugMessage
	}
}




Function Write-Log {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
		[AllowEmptyCollection()]
		[string[]]$Message,
		[Parameter(Mandatory=$false,Position=1)]
		[ValidateRange(1,3)]
		[int16]$Severity = 1,
		[Parameter(Mandatory=$false,Position=2)]
		[ValidateNotNull()]
		[string]$Source = '',
		[Parameter(Mandatory=$false,Position=3)]
		[ValidateNotNullorEmpty()]
		[string]$ScriptSection = $script:installPhase,
		[Parameter(Mandatory=$false,Position=4)]
		[ValidateSet({"{2}{1}{0}"-f 'Trace','M','C'},{"{1}{0}" -f 'gacy','Le'})]
		[string]$LogType = $configToolkitLogStyle,
		[Parameter(Mandatory=$false,Position=5)]
		[ValidateNotNullorEmpty()]
		[string]$LogFileDirectory = $logDirectory,
		[Parameter(Mandatory=$false,Position=6)]
		[ValidateNotNullorEmpty()]
		[string]$LogFileName = $logName,
		[Parameter(Mandatory=$false,Position=7)]
		[ValidateNotNullorEmpty()]
		[decimal]$MaxLogFileSizeMB = $configToolkitLogMaxSize,
		[Parameter(Mandatory=$false,Position=8)]
		[ValidateNotNullorEmpty()]
		[boolean]$WriteHost = $configToolkitLogWriteToHost,
		[Parameter(Mandatory=$false,Position=9)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true,
		[Parameter(Mandatory=$false,Position=10)]
		[switch]$PassThru = $false,
		[Parameter(Mandatory=$false,Position=11)]
		[switch]$DebugMessage = $false,
		[Parameter(Mandatory=$false,Position=12)]
		[boolean]$LogDebugMessage = $configToolkitLogDebugMessage,
		[Parameter(Mandatory=$false,Position=13)]
		[switch]$DisableOnRelaunchToolkitAsUser = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name

		
		[string]$LogTime = (Get-Date -Format HH:mm:ss.fff).ToString()
		[string]$LogDate = (Get-Date -Format MM-dd-yyyy).ToString()
		If (-not (Test-Path -Path ("{0}{5}{4}{1}{3}{2}"-f 'var',':LogTim','eBias','eZon','able','i'))) { [int32]$script:LogTimeZoneBias = [System.TimeZone]::CurrentTimeZone.GetUtcOffset([datetime]::Now).TotalMinutes }
		[string]$LogTimePlusBias = $LogTime + $script:LogTimeZoneBias
		[boolean]$ExitLoggingFunction = $false

		
		If ($DisableOnRelaunchToolkitAsUser -and $RelaunchToolkitAsUser) { [boolean]$ExitLoggingFunction = $true; Return }

		
		If (($DebugMessage) -and (-not $LogDebugMessage)) { [boolean]$ExitLoggingFunction = $true; Return }
		
		
		If (-not (Test-Path -Path $LogFileDirectory -PathType Container)) {
			Try {
				New-Item -Path $LogFileDirectory -Type ("{0}{2}{1}"-f'Dir','ctory','e') -Force -ErrorAction ("{1}{0}" -f'top','S') | Out-Null
			}
			Catch {
				[boolean]$ExitLoggingFunction = $true
				
				If (-not $ContinueOnError) {
					Write-Host "[$LogDate $LogTime] [${CmdletName}] $ScriptSection :: Failed to create the log directory [$LogFileDirectory]. `n$(Resolve-Error)" -ForegroundColor 'Red'
				}
				Return
			}
		}

		
		If ($script:MyInvocation.Value.ScriptName) { [string]$ScriptSource = Split-Path -Path $script:MyInvocation.Value.ScriptName -Leaf } Else { [string]$ScriptSource = Split-Path -Path $script:MyInvocation.MyCommand.Definition -Leaf }
		
		
		[boolean]$ScriptSectionDefined = [boolean](-not [string]::IsNullOrEmpty($ScriptSection))
		
		
		If (-not (Test-Path -Path ("{2}{1}{5}{4}{6}{0}{3}" -f 'in','able','vari','g','s',':Di','ableLogg'))) { $DisableLogging = $false }
		
		
		[scriptblock]$CMTraceLogString = {
			Param (
				[string]$lMessage,
				[string]$lSource,
				[int16]$lSeverity
			)
			"<![LOG[$lMessage]LOG]!>" + ("<time=`"$LogTimePlusBias`" "+'') + ("date=`"$LogDate`" "+'') + ("component=`"$lSource`" "+'') + "context=`"$([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)`"  " + ("type=`"$lSeverity`" "+'') + ("thread=`"$PID`" "+'') + "file=`"$ScriptSource`">"
		}
		
		
		[scriptblock]$WriteLogLineToHost = {
			Param (
				[string]$lTextLogLine,
				[int16]$lSeverity
			)
			If ($WriteHost) {
				
				If ($Host.UI.RawUI.ForegroundColor) {
					Switch ($lSeverity) {
						3 { Write-Host $lTextLogLine -ForegroundColor 'Red' -BackgroundColor ("{1}{0}" -f'ck','Bla') }
						2 { Write-Host $lTextLogLine -ForegroundColor ("{1}{0}{2}" -f'ell','Y','ow') -BackgroundColor ("{1}{0}" -f 'ck','Bla') }
						1 { Write-Host $lTextLogLine }
					}
				}
				
				Else {
					Write-Output $lTextLogLine
				}
			}
		}
		
		
		[string]$LogFilePath = Join-Path -Path $LogFileDirectory -ChildPath $LogFileName
	}
	Process {
		
		If ($ExitLoggingFunction) { Return }
		
		ForEach ($Msg in $Message) {
			
			[string]$CMTraceMsg = ''
			[string]$ConsoleLogLine = ''
			[string]$LegacyTextLogLine = ''
			If ($Msg) {
				
				If ($ScriptSectionDefined) { [string]$CMTraceMsg = ("[$ScriptSection] "+':'+': '+"$Msg") }
				
				
				[string]$LegacyMsg = ("[$LogDate "+"$LogTime]")
				If ($ScriptSectionDefined) { [string]$LegacyMsg += (' '+"[$ScriptSection]") }
				If ($Source) {
					[string]$ConsoleLogLine = ("$LegacyMsg "+"[$Source] "+':'+': '+"$Msg")
					Switch ($Severity) {
						3 { [string]$LegacyTextLogLine = ("$LegacyMsg "+"[$Source] "+'[Err'+'or'+'] '+'::'+' '+"$Msg") }
						2 { [string]$LegacyTextLogLine = ("$LegacyMsg "+"[$Source] "+'[Warn'+'i'+'n'+'g] '+'::'+' '+"$Msg") }
						1 { [string]$LegacyTextLogLine = ("$LegacyMsg "+"[$Source] "+'[I'+'nfo]'+' '+'::'+' '+"$Msg") }
					}
				}
				Else {
					[string]$ConsoleLogLine = ("$LegacyMsg "+':'+': '+"$Msg")
					Switch ($Severity) {
						3 { [string]$LegacyTextLogLine = ("$LegacyMsg "+'[E'+'r'+'ror] '+':'+': '+"$Msg") }
						2 { [string]$LegacyTextLogLine = ("$LegacyMsg "+'[W'+'arnin'+'g'+'] '+'::'+' '+"$Msg") }
						1 { [string]$LegacyTextLogLine = ("$LegacyMsg "+'['+'Info] '+':'+': '+"$Msg") }
					}
				}
			}
			
			
			[string]$CMTraceLogLine = & $CMTraceLogString -lMessage $CMTraceMsg -lSource $Source -lSeverity $Severity
			
			
			If ($LogType -ieq ("{0}{1}"-f'CMTrac','e')) {
				[string]$LogLine = $CMTraceLogLine
			}
			Else {
				[string]$LogLine = $LegacyTextLogLine
			}
			
			
			If (-not $DisableLogging) {
				Try {
					$LogLine | Out-File -FilePath $LogFilePath -Append -NoClobber -Force -Encoding ("{1}{0}"-f '8','UTF') -ErrorAction ("{0}{1}"-f'S','top')
				}
				Catch {
					If (-not $ContinueOnError) {
						Write-Host "[$LogDate $LogTime] [$ScriptSection] [${CmdletName}] :: Failed to write message [$Msg] to the log file [$LogFilePath]. `n$(Resolve-Error)" -ForegroundColor 'Red'
					}
				}
			}
			
			
			& $WriteLogLineToHost -lTextLogLine $ConsoleLogLine -lSeverity $Severity
		}
	}
	End {
		
		Try {
			If (-not $ExitLoggingFunction) {
				[System.IO.FileInfo]$LogFile = Get-ChildItem -Path $LogFilePath -ErrorAction ("{1}{0}" -f 'op','St')
				[decimal]$LogFileSizeMB = $LogFile.Length/1MB
				If (($LogFileSizeMB -gt $MaxLogFileSizeMB) -and ($MaxLogFileSizeMB -gt 0)) {
					
					[string]$ArchivedOutLogFile = [System.IO.Path]::ChangeExtension($LogFilePath, 'lo_')
					[hashtable]$ArchiveLogParams = @{ ScriptSection = $ScriptSection; Source = ${CmdletName}; Severity = 2; LogFileDirectory = $LogFileDirectory; LogFileName = $LogFilePath; LogType = $LogType; MaxLogFileSizeMB = 0; WriteHost = $WriteHost; ContinueOnError = $ContinueOnError; PassThru = $false }
					
					
					$ArchiveLogMessage = ('Ma'+'ximum'+' '+'lo'+'g '+'file'+' '+'siz'+'e '+"[$MaxLogFileSizeMB "+'M'+'B] '+'reac'+'hed'+'. '+'Rena'+'me '+'log'+' '+'file'+' '+'to'+' '+"[$ArchivedOutLogFile].")
					Write-Log -Message $ArchiveLogMessage @ArchiveLogParams
					
					
					Move-Item -Path $LogFilePath -Destination $ArchivedOutLogFile -Force -ErrorAction ("{0}{1}"-f 'S','top')
					
					
					$NewLogMessage = ('P'+'re'+'v'+'ious '+'log'+' '+'fi'+'le '+'was'+' '+'rena'+'med'+' '+'t'+'o '+"[$ArchivedOutLogFile] "+'bec'+'aus'+'e '+'m'+'axi'+'mum '+'log'+' '+'file'+' '+'si'+'ze '+'o'+'f '+"[$MaxLogFileSizeMB "+'M'+'B] '+'wa'+'s '+'rea'+'c'+'hed.')
					Write-Log -Message $NewLogMessage @ArchiveLogParams
				}
			}
		}
		Catch {
			
		}
		Finally {
			If ($PassThru) { Write-Output $Message }
		}
	}
}




Function Exit-Script {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$ExitCode = 0
	)
	
	
	[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
	
	
	If ($formCloseApps) { $formCloseApps.Close }
	
	
	
	If (Test-Path -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -PathType ("{1}{0}" -f 'af','Le')) {
		[string]$StatusMessage = ("{2}{1}{0}" -f 'nspace','u','_CloseR')
		$StatusMessage | Export-Clixml -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -Force
	}
	Start-Sleep -Seconds 5
	Close-InstallationProgress
	
	
	If (($BlockExecution) -and (-not $RelaunchToolkitAsUser)) { Unblock-AppExecution }
	
	
	If (($terminalServerMode) -and (-not $RelaunchToolkitAsUser)) { Disable-TerminalServerInstallMode }
	
	
	Switch ($exitCode) {
		$configInstallationUIExitCode { $installSuccess = $false }
		$configInstallationDeferExitCode { $installSuccess = $false }
		3010 { $installSuccess = $true }
		1641 { $installSuccess = $true }
		0 { $installSuccess = $true }
		Default { $installSuccess = $false }
	}
	
	
	If ($deployModeSilent) { [boolean]$configShowBalloonNotifications = $false }
	
	If ($installSuccess) {
		If (Test-Path -Path $regKeyDeferHistory -ErrorAction ("{3}{0}{1}{2}{4}"-f 'lyC','o','nt','Silent','inue')) {
			Write-Log -Message ("{3}{6}{1}{4}{0}{5}{7}{2}"-f ' h',' deferra','.','Rem','l','i','ove','story..') -Source ${CmdletName}
			Remove-RegistryKey -Key $regKeyDeferHistory
		}
		
		[string]$balloonText = ("$deploymentTypeName "+"$configBalloonTextComplete")
		
		If (($msiRebootDetected) -and ($AllowRebootPassThru)) {
			Write-Log -Message ("{3}{4}{0}{6}{1}{5}{2}" -f'start has','been flagged ','ired.','A',' re','as requ',' ') -Source ${CmdletName}
			[string]$balloonText = ("$deploymentTypeName "+"$configBalloonTextRestartRequired")
			[int32]$exitCode = 3010
		}
		Else {
			[int32]$exitCode = 0
		}
		
		Write-Log -Message ("$installName "+"$deploymentTypeName "+'compl'+'et'+'ed '+'w'+'ith '+'exi'+'t '+'c'+'ode '+"[$exitcode].") -Source ${CmdletName}
		If ($configShowBalloonNotifications) { Show-BalloonTip -BalloonTipIcon ("{0}{1}" -f 'In','fo') -BalloonTipText $balloonText }
	}
	ElseIf (-not $installSuccess) {
		Write-Log -Message ("$installName "+"$deploymentTypeName "+'co'+'m'+'plete'+'d '+'wi'+'th '+'exi'+'t '+'cod'+'e '+"[$exitcode].") -Source ${CmdletName}
		If (($exitCode -eq $configInstallationUIExitCode) -or ($exitCode -eq $configInstallationDeferExitCode)) {
			[string]$balloonText = ("$deploymentTypeName "+"$configBalloonTextFastRetry")
			If ($configShowBalloonNotifications) { Show-BalloonTip -BalloonTipIcon ("{2}{1}{0}" -f'g','nin','War') -BalloonTipText $balloonText }
		}
		Else {
			[string]$balloonText = ("$deploymentTypeName "+"$configBalloonTextError")
			If ($configShowBalloonNotifications) { Show-BalloonTip -BalloonTipIcon ("{0}{1}" -f'Err','or') -BalloonTipText $balloonText }
		}
	}
	
	[string]$LogDash = '-' * 79
	Write-Log -Message $LogDash -Source ${CmdletName}
	
	
	If (($configToolkitCompressLogs) -and (-not $RelaunchToolkitAsUser)) {
		Try {
			
			Set-Content -Path $zipFileName -Value ('PK' + [char]5 + [char]6 + ("$([char]0)" * 18)) -ErrorAction ("{1}{0}" -f 'top','S')
			
			$zipFile = $shellApp.NameSpace($zipFileName)
			ForEach ($file in (Get-ChildItem -Path $logTempFolder -ErrorAction ("{0}{1}" -f 'Sto','p'))) {
				Write-Log -Message "Compress log file [$($file.Name)] to [$zipFileName]... " -Source ${CmdletName}
				$zipFile.CopyHere($file.FullName)
				Start-Sleep -Milliseconds 500
			}
			
			If (Test-Path -Path $logTempFolder -PathType Container -ErrorAction ("{0}{1}" -f 'St','op')) {
				Remove-Item -Path $logTempFolder -Recurse -Force -ErrorAction ("{0}{1}" -f 'St','op') | Out-Null
			}
		}
		Catch {
			Write-Log -Message "Failed to compress the log file(s). `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	
	
	Exit $exitCode
}




Function Resolve-Error {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false,Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
		[AllowEmptyCollection()]
		[array]$ErrorRecord,
		[Parameter(Mandatory=$false,Position=1)]
		[ValidateNotNullorEmpty()]
		[string[]]$Property = (("{0}{1}"-f'Me','ssage'),("{1}{3}{0}{2}"-f 'ceptio','I','n','nnerEx'),("{4}{1}{3}{0}{2}" -f 'lif','yQu','iedErrorId','a','Full'),("{3}{1}{0}{2}"-f'Tra','riptStack','ce','Sc'),("{2}{0}{3}{4}{1}" -f 'i','sage','Pos','t','ionMes')),
		[Parameter(Mandatory=$false,Position=2)]
		[switch]$GetErrorRecord = $true,
		[Parameter(Mandatory=$false,Position=3)]
		[switch]$GetErrorInvocation = $true,
		[Parameter(Mandatory=$false,Position=4)]
		[switch]$GetErrorException = $true,
		[Parameter(Mandatory=$false,Position=5)]
		[switch]$GetErrorInnerException = $true
	)
	
	Begin {
		
		If (-not $ErrorRecord) {
			If ($global:Error.Count -eq 0) {
				
				Return
			}
			Else {
				[array]$ErrorRecord = $global:Error[0]
			}
		}
		
		
		[scriptblock]$SelectProperty = {
			Param (
				[Parameter(Mandatory=$true)]
				[ValidateNotNullorEmpty()]
				$InputObject,
				[Parameter(Mandatory=$true)]
				[ValidateNotNullorEmpty()]
				[string[]]$Property
			)
			
			[string[]]$ObjectProperty = $InputObject | Get-Member -MemberType *Property | Select-Object -ExpandProperty Name
			ForEach ($Prop in $Property) {
				If ($Prop -eq '*') {
					[string[]]$PropertySelection = $ObjectProperty
					Break
				}
				ElseIf ($ObjectProperty -contains $Prop) {
					[string[]]$PropertySelection += $Prop
				}
			}
			Write-Output $PropertySelection
		}
		
		
		$LogErrorRecordMsg = $null
		$LogErrorInvocationMsg = $null
		$LogErrorExceptionMsg = $null
		$LogErrorMessageTmp = $null
		$LogInnerMessage = $null
	}
	Process {
		If (-not $ErrorRecord) { Return }
		ForEach ($ErrRecord in $ErrorRecord) {
			
			If ($GetErrorRecord) {
				[string[]]$SelectedProperties = & $SelectProperty -InputObject $ErrRecord -Property $Property
				$LogErrorRecordMsg = $ErrRecord | Select-Object -Property $SelectedProperties
			}
			
			
			If ($GetErrorInvocation) {
				If ($ErrRecord.InvocationInfo) {
					[string[]]$SelectedProperties = & $SelectProperty -InputObject $ErrRecord.InvocationInfo -Property $Property
					$LogErrorInvocationMsg = $ErrRecord.InvocationInfo | Select-Object -Property $SelectedProperties
				}
			}
			
			
			If ($GetErrorException) {
				If ($ErrRecord.Exception) {
					[string[]]$SelectedProperties = & $SelectProperty -InputObject $ErrRecord.Exception -Property $Property
					$LogErrorExceptionMsg = $ErrRecord.Exception | Select-Object -Property $SelectedProperties
				}
			}
			
			
			If ($Property -eq '*') {
				
				If ($LogErrorRecordMsg) { [array]$LogErrorMessageTmp += $LogErrorRecordMsg }
				If ($LogErrorInvocationMsg) { [array]$LogErrorMessageTmp += $LogErrorInvocationMsg }
				If ($LogErrorExceptionMsg) { [array]$LogErrorMessageTmp += $LogErrorExceptionMsg }
			}
			Else {
				
				If ($LogErrorExceptionMsg) { [array]$LogErrorMessageTmp += $LogErrorExceptionMsg }
				If ($LogErrorRecordMsg) { [array]$LogErrorMessageTmp += $LogErrorRecordMsg }
				If ($LogErrorInvocationMsg) { [array]$LogErrorMessageTmp += $LogErrorInvocationMsg }
			}
			
			If ($LogErrorMessageTmp) {
				$LogErrorMessage = ("{0}{4}{3}{1}{2}" -f'Erro','Recor','d:',' ','r')
				$LogErrorMessage += "`n-------------"
				$LogErrorMsg = $LogErrorMessageTmp | Format-List | Out-String
				$LogErrorMessage += $LogErrorMsg
			}
			
			
			If ($GetErrorInnerException) {
				If ($ErrRecord.Exception -and $ErrRecord.Exception.InnerException) {
					$LogInnerMessage = ("{2}{4}{0}{3}{1}" -f '(','):','Error Inner Excep','s','tion')
					$LogInnerMessage += "`n-------------------------"
					
					$ErrorInnerException = $ErrRecord.Exception.InnerException
					$Count = 0
					
					While ($ErrorInnerException) {
						[string]$InnerExceptionSeperator = '~' * 40
						
						[string[]]$SelectedProperties = & $SelectProperty -InputObject $ErrorInnerException -Property $Property
						$LogErrorInnerExceptionMsg = $ErrorInnerException | Select-Object -Property $SelectedProperties | Format-List | Out-String
						
						If ($Count -gt 0) { $LogInnerMessage += $InnerExceptionSeperator }
						$LogInnerMessage += $LogErrorInnerExceptionMsg
						
						$Count++
						$ErrorInnerException = $ErrorInnerException.InnerException
					}
				}
			}
			
			If ($LogErrorMessage) { $Output = $LogErrorMessage }
			If ($LogInnerMessage) { $Output += $LogInnerMessage }
			
			Write-Output $Output
			
			If (Test-Path -Path ("{1}{3}{2}{4}{0}"-f 'tput','varia','l','b','e:Ou')) { Clear-Variable -Name Output }
			If (Test-Path -Path ("{0}{4}{3}{1}{2}" -f 'var','r','orMessage','LogEr','iable:')) { Clear-Variable -Name LogErrorMessage }
			If (Test-Path -Path ("{0}{3}{2}{1}{4}"-f 'varia','In','g','ble:Lo','nerMessage')) { Clear-Variable -Name LogInnerMessage }
			If (Test-Path -Path ("{1}{3}{4}{2}{0}"-f 'mp','vari','sageT','able:LogErro','rMes')) { Clear-Variable -Name LogErrorMessageTmp }
		}
	}
	End {
	}
}




Function Show-InstallationPrompt {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Title = $installTitle,
		[Parameter(Mandatory=$false)]
		[string]$Message = '',
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{0}{1}"-f 'Lef','t'},{"{2}{0}{1}"-f 'nt','er','Ce'},{"{1}{0}"-f 't','Righ'})]
		[string]$MessageAlignment = ("{2}{1}{0}" -f 'r','ente','C'),
		[Parameter(Mandatory=$false)]
		[string]$ButtonRightText = '',
		[Parameter(Mandatory=$false)]
		[string]$ButtonLeftText = '',
		[Parameter(Mandatory=$false)]
		[string]$ButtonMiddleText = '',
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{1}{3}{0}{2}"-f'io','Applica','n','t'},{"{2}{0}{1}" -f'i','sk','Aster'},{"{1}{0}" -f'ror','Er'},{"{3}{2}{1}{0}"-f 'n','io','clamat','Ex'},{"{0}{1}" -f'Ha','nd'},{"{0}{1}{2}{3}" -f'Infor','m','a','tion'},{"{0}{1}"-f 'No','ne'},{"{0}{2}{1}" -f'Que','tion','s'},{"{1}{0}" -f'ld','Shie'},{"{0}{1}"-f 'War','ning'},{"{0}{2}{1}"-f'WinL','go','o'})]
		[string]$Icon = ("{1}{0}" -f'one','N'),
		[Parameter(Mandatory=$false)]
		[switch]$NoWait = $false,
		[Parameter(Mandatory=$false)]
		[switch]$PersistPrompt = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$MinimizeWindows = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$Timeout = $configInstallationUITimeout,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ExitOnTimeout = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) {
			Write-Log -Message ('Bypas'+'sin'+'g'+' '+'I'+'nstall'+'at'+'i'+'on '+'P'+'rompt '+'[Mo'+'de: '+"$deployMode]... "+"$Message") -Source ${CmdletName}
			Return
		}

		
		If (-not $IsProcessUserInteractive) {
			$ShowInstallPromptResult = Invoke-PSCommandAsUser -PassThru -Command ([scriptblock]::Create(('S'+'how-Inst'+'allati'+'o'+'nPro'+'mpt '+'-'+'Title'+' '+"'$Title' "+'-Message'+' '+"'$Message' "+'-MessageA'+'l'+'i'+'g'+'n'+'ment '+"'$MessageAlignment' "+'-Bu'+'t'+'tonRi'+'g'+'htText '+"'$ButtonRightText' "+'-ButtonLe'+'f'+'t'+'Te'+'xt '+"'$ButtonLeftText' "+'-Butt'+'o'+'nMi'+'ddleText '+"'$ButtonMiddleText' "+'-I'+'con '+"'$Icon' "+"-NoWait:`$$NoWait "+"-PersistPrompt:`$$PersistPrompt "+'-'+'Minimize'+'W'+'indows '+"`$$MinimizeWindows "+'-Ti'+'m'+'eout '+"$Timeout "+'-'+'Exi'+'tO'+'nTimeo'+'ut '+"`$$ExitOnTimeout")))
			If ($ShowInstallPromptResult) {
				Return $ShowInstallPromptResult
			}
			Else {
				Return
			}
		}

		
		[hashtable]$installPromptParameters = $psBoundParameters
		
		
		If ($timeout -gt $configInstallationUITimeout) {
			[string]$CountdownTimeoutErr = ("{1}{2}{13}{23}{4}{21}{22}{17}{16}{20}{15}{5}{10}{12}{6}{7}{18}{9}{3}{19}{14}{0}{8}{11}"-f'ur','T','he','ified in','allati','e','he ','ti','ation ',' spec','r tha','file.','n t',' in','the XML config','long','meout ca','g ti','meout',' ','nnot be ','on UI ','dialo','st')
			Write-Log -Message $CountdownTimeoutErr -Severity 3 -Source ${CmdletName}
			Throw $CountdownTimeoutErr
		}
		
		[System.Windows.Forms.Application]::EnableVisualStyles()
		$formInstallationPrompt = New-Object -TypeName System.Windows.Forms.Form
		$pictureBanner = New-Object -TypeName System.Windows.Forms.PictureBox
		$pictureIcon = New-Object -TypeName System.Windows.Forms.PictureBox
		$labelText = New-Object -TypeName System.Windows.Forms.Label
		$buttonRight = New-Object -TypeName System.Windows.Forms.Button
		$buttonMiddle = New-Object -TypeName System.Windows.Forms.Button
		$buttonLeft = New-Object -TypeName System.Windows.Forms.Button
		$buttonAbort = New-Object -TypeName System.Windows.Forms.Button
		$InitialFormInstallationPromptWindowState = New-Object -TypeName System.Windows.Forms.FormWindowState
		
		[scriptblock]$Form_Cleanup_FormClosed = {
			
			Try {
				$labelText.remove_Click($handler_labelText_Click)
				$buttonLeft.remove_Click($buttonLeft_OnClick)
				$buttonRight.remove_Click($buttonRight_OnClick)
				$buttonMiddle.remove_Click($buttonMiddle_OnClick)
				$buttonAbort.remove_Click($buttonAbort_OnClick)
				$timer.remove_Tick($timer_Tick)
				$timer.dispose()
				$timer = $null
				$timerPersist.remove_Tick($timerPersist_Tick)
				$timerPersist.dispose()
				$timerPersist = $null
				$formInstallationPrompt.remove_Load($Form_StateCorrection_Load)
				$formInstallationPrompt.remove_FormClosed($Form_Cleanup_FormClosed)
			}
			Catch { }
		}
		
		[scriptblock]$Form_StateCorrection_Load = {
			
			$formInstallationPrompt.WindowState = ("{0}{1}" -f'No','rmal')
			$formInstallationPrompt.AutoSize = $true
			$formInstallationPrompt.TopMost = $true
			$formInstallationPrompt.BringToFront()
			
			Set-Variable -Name formInstallationPromptStartPosition -Value $formInstallationPrompt.Location -Scope Script
		}
		
		
		$formInstallationPrompt.Controls.Add($pictureBanner)
		
		
		
		$paddingNone = New-Object -TypeName System.Windows.Forms.Padding
		$paddingNone.Top = 0
		$paddingNone.Bottom = 0
		$paddingNone.Left = 0
		$paddingNone.Right = 0
		
		
		$labelPadding = ("{2}{1}{0}"-f',20,0','0','20,')
		
		
		$buttonWidth = 110
		$buttonHeight = 23
		$buttonPadding = 50
		$buttonSize = New-Object -TypeName System.Drawing.Size
		$buttonSize.Width = $buttonWidth
		$buttonSize.Height = $buttonHeight
		$buttonPadding = New-Object -TypeName System.Windows.Forms.Padding
		$buttonPadding.Top = 0
		$buttonPadding.Bottom = 5
		$buttonPadding.Left = 50
		$buttonPadding.Right = 0
		
		
		$pictureBanner.DataBindings.DefaultDataSourceUpdateMode = 0
		$pictureBanner.ImageLocation = $appDeployLogoBanner
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 0
		$System_Drawing_Point.Y = 0
		$pictureBanner.Location = $System_Drawing_Point
		$pictureBanner.Name = ("{0}{1}{2}"-f'pict','ure','Banner')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 50
		$System_Drawing_Size.Width = 450
		$pictureBanner.Size = $System_Drawing_Size
		$pictureBanner.SizeMode = ("{3}{2}{0}{1}"-f 'terIm','age','n','Ce')
		$pictureBanner.Margin = $paddingNone
		$pictureBanner.TabIndex = 0
		$pictureBanner.TabStop = $false
		
		
		$pictureIcon.DataBindings.DefaultDataSourceUpdateMode = 0
		If ($icon -ne ("{1}{0}"-f'one','N')) { $pictureIcon.Image = ([System.Drawing.SystemIcons]::$Icon).ToBitmap() }
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 15
		$System_Drawing_Point.Y = 105
		$pictureIcon.Location = $System_Drawing_Point
		$pictureIcon.Name = ("{1}{0}{2}"-f 'icture','p','Icon')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 32
		$System_Drawing_Size.Width = 32
		$pictureIcon.Size = $System_Drawing_Size
		$pictureIcon.AutoSize = $true
		$pictureIcon.Margin = $paddingNone
		$pictureIcon.TabIndex = 0
		$pictureIcon.TabStop = $false
		
		
		$labelText.DataBindings.DefaultDataSourceUpdateMode = 0
		$labelText.Name = ("{1}{2}{0}"-f 'xt','labe','lTe')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 148
		$System_Drawing_Size.Width = 385
		$labelText.Size = $System_Drawing_Size
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 25
		$System_Drawing_Point.Y = 50
		$labelText.Location = $System_Drawing_Point
		$labelText.Margin = ("{2}{0}{1}"-f ',0',',0','0,0')
		$labelText.Padding = $labelPadding
		$labelText.TabIndex = 1
		$labelText.Text = $message
		$labelText.TextAlign = "Middle$($MessageAlignment)"
		$labelText.Anchor = 'Top'
		$labelText.add_Click($handler_labelText_Click)
		
		
		$buttonLeft.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonLeft.Location = ("{0}{1}" -f '15,','200')
		$buttonLeft.Name = ("{1}{2}{0}"-f'ft','b','uttonLe')
		$buttonLeft.Size = $buttonSize
		$buttonLeft.TabIndex = 5
		$buttonLeft.Text = $buttonLeftText
		$buttonLeft.DialogResult = 'No'
		$buttonLeft.AutoSize = $false
		$buttonLeft.UseVisualStyleBackColor = $true
		$buttonLeft.add_Click($buttonLeft_OnClick)
		
		
		$buttonMiddle.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonMiddle.Location = ("{1}{2}{0}"-f'00','170,','2')
		$buttonMiddle.Name = ("{1}{3}{2}{0}"-f'e','but','onMiddl','t')
		$buttonMiddle.Size = $buttonSize
		$buttonMiddle.TabIndex = 6
		$buttonMiddle.Text = $buttonMiddleText
		$buttonMiddle.DialogResult = ("{1}{0}"-f'nore','Ig')
		$buttonMiddle.AutoSize = $true
		$buttonMiddle.UseVisualStyleBackColor = $true
		$buttonMiddle.add_Click($buttonMiddle_OnClick)
		
		
		$buttonRight.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonRight.Location = ("{0}{1}"-f'325,2','00')
		$buttonRight.Name = ("{2}{3}{0}{1}"-f 'tonRi','ght','b','ut')
		$buttonRight.Size = $buttonSize
		$buttonRight.TabIndex = 7
		$buttonRight.Text = $ButtonRightText
		$buttonRight.DialogResult = 'Yes'
		$buttonRight.AutoSize = $true
		$buttonRight.UseVisualStyleBackColor = $true
		$buttonRight.add_Click($buttonRight_OnClick)
		
		
		$buttonAbort.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonAbort.Name = ("{0}{2}{1}" -f'bu','rt','ttonAbo')
		$buttonAbort.Size = '1,1'
		$buttonAbort.DialogResult = ("{1}{0}"-f'bort','A')
		$buttonAbort.TabIndex = 5
		$buttonAbort.UseVisualStyleBackColor = $true
		$buttonAbort.add_Click($buttonAbort_OnClick)
		
		
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 270
		$System_Drawing_Size.Width = 450
		$formInstallationPrompt.Size = $System_Drawing_Size
		$formInstallationPrompt.Padding = ("{0}{1}"-f '0,0,0',',10')
		$formInstallationPrompt.Margin = $paddingNone
		$formInstallationPrompt.DataBindings.DefaultDataSourceUpdateMode = 0
		$formInstallationPrompt.Name = ("{1}{2}{3}{0}" -f'orm','Welc','ome','F')
		$formInstallationPrompt.Text = $title
		$formInstallationPrompt.StartPosition = ("{0}{1}{2}"-f'Cent','erScree','n')
		$formInstallationPrompt.FormBorderStyle = ("{1}{2}{0}"-f'ialog','Fixe','dD')
		$formInstallationPrompt.MaximizeBox = $false
		$formInstallationPrompt.MinimizeBox = $false
		$formInstallationPrompt.TopMost = $true
		$formInstallationPrompt.TopLevel = $true
		$formInstallationPrompt.Icon = New-Object -TypeName System.Drawing.Icon -ArgumentList $AppDeployLogoIcon
		$formInstallationPrompt.Controls.Add($pictureBanner)
		$formInstallationPrompt.Controls.Add($pictureIcon)
		$formInstallationPrompt.Controls.Add($labelText)
		$formInstallationPrompt.Controls.Add($buttonAbort)
		If ($buttonLeftText) { $formInstallationPrompt.Controls.Add($buttonLeft) }
		If ($buttonMiddleText) { $formInstallationPrompt.Controls.Add($buttonMiddle) }
		If ($buttonRightText) { $formInstallationPrompt.Controls.Add($buttonRight) }
		
		
		$timer = New-Object -TypeName System.Windows.Forms.Timer
		$timer.Interval = ($timeout * 1000)
		$timer.Add_Tick({
			Write-Log -Message ("{4}{9}{1}{12}{3}{7}{13}{5}{2}{11}{10}{6}{8}{0}"-f'me.','acti','a reaso',' n','In','within ','ble amo','ot taken','unt of ti','stallation ','a','n','on',' ') -Source ${CmdletName}
			$buttonAbort.PerformClick()
		})
		
		
		If ($persistPrompt) {
			$timerPersist = New-Object -TypeName System.Windows.Forms.Timer
			$timerPersist.Interval = ($configInstallationPersistInterval * 1000)
			[scriptblock]$timerPersist_Tick = { Refresh-InstallationPrompt }
			$timerPersist.add_Tick($timerPersist_Tick)
			$timerPersist.Start()
		}
		
		
		$InitialFormInstallationPromptWindowState = $formInstallationPrompt.WindowState
		
		$formInstallationPrompt.add_Load($Form_StateCorrection_Load)
		
		$formInstallationPrompt.add_FormClosed($Form_Cleanup_FormClosed)
		
		
		$timer.Start()
		
		Function Refresh-InstallationPrompt {
			$formInstallationPrompt.BringToFront()
			$formInstallationPrompt.Location = "$($formInstallationPromptStartPosition.X),$($formInstallationPromptStartPosition.Y)"
			$formInstallationPrompt.Refresh()
		}
		
		
		Close-InstallationProgress
		
		[string]$installPromptLoggedParameters = ($installPromptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{1}{4}{2}{0}{3}"-f 'ramet','Sw','chPa','er','it')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{0}{1}" -f 'Bool','ean')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}"-f'2','Int3')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' '
		Write-Log -Message ('D'+'ispla'+'ying'+' '+'cust'+'om '+'ins'+'t'+'allati'+'on'+' '+'pr'+'ompt '+'wi'+'th '+'th'+'e '+'no'+'n-de'+'fau'+'lt '+'param'+'e'+'ter'+'s: '+"[$installPromptLoggedParameters]...") -Source ${CmdletName}
		
		
		If ($NoWait) {
			
			$installPromptParameters.Remove(("{1}{0}" -f't','NoWai'))
			
			[string]$installPromptParameters = ($installPromptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{2}{3}{0}{4}{1}" -f'hPara','eter','Sw','itc','m')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}"-f 'n','Boolea')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}" -f'nt32','I')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' '
			Start-Process -FilePath "$PSHOME\powershell.exe" -ArgumentList ('-'+'Ex'+'ecuti'+'onPolic'+'y '+'By'+'pas'+'s '+'-NoPro'+'fil'+'e '+'-'+'NoLogo'+' '+'-W'+'indo'+'wStyle'+' '+'H'+'i'+'dden '+'-Co'+'mman'+'d '+"`"$scriptPath`" "+'-Refe'+'rri'+'n'+'gAppl'+'icatio'+'n '+"`"$installName`" "+'-Sho'+'wInst'+'allation'+'Pro'+'mpt'+' '+"$installPromptParameters") -WindowStyle Hidden -ErrorAction ("{3}{0}{2}{1}{4}" -f'l','n','yCo','Silent','tinue')
		}
		
		Else {
			$showDialog = $true
			While ($showDialog) {
				
				If ($minimizeWindows) { $shellApp.MinimizeAll() | Out-Null }
				
				$result = $formInstallationPrompt.ShowDialog()
				If (($result -eq 'Yes') -or ($result -eq 'No') -or ($result -eq ("{1}{0}" -f're','Igno')) -or ($result -eq ("{1}{0}"-f't','Abor'))) {
					$showDialog = $false
				}
			}
			$formInstallationPrompt.Dispose()
			Switch ($result) {
				'Yes' { Write-Output $buttonRightText }
				'No' { Write-Output $buttonLeftText }
				("{0}{2}{1}" -f'Ig','e','nor') { Write-Output $buttonMiddleText }
				("{1}{0}" -f'bort','A') {
					
					$shellApp.UndoMinimizeAll() | Out-Null
					If ($ExitOnTimeout) {
						Exit-Script -ExitCode $configInstallationUIExitCode
					}
					Else {
						Write-Log -Message ('U'+'I '+'ti'+'med'+' '+'out'+' '+'but'+' '+"`$ExitOnTimeout "+'se'+'t '+'to'+' '+"`$false. "+'C'+'o'+'ntinue.'+'..') -Source ${CmdletName}
					}
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-DialogBox {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,Position=0,HelpMessage={"{4}{1}{5}{7}{3}{0}{6}{2}"-f' d','sage','box','r the','Enter a mes',' f','ialog ','o'})]
		[ValidateNotNullorEmpty()]
		[string]$Text,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Title = $installTitle,
		[Parameter(Mandatory=$false)]
		[ValidateSet('OK',{"{1}{2}{0}"-f'el','OKCan','c'},{"{4}{2}{3}{0}{1}"-f'Ig','nore','rtRetr','y','Abo'},{"{1}{2}{0}"-f 'ancel','Y','esNoC'},{"{1}{0}"-f'No','Yes'},{"{2}{0}{3}{1}" -f'etr','ancel','R','yC'},{"{1}{0}{3}{2}"-f'TryAgainC','Cancel','nue','onti'})]
		[string]$Buttons = 'OK',
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{0}{1}"-f'Fi','rst'},{"{1}{0}" -f'cond','Se'},{"{0}{1}"-f'Th','ird'})]
		[string]$DefaultButton = ("{0}{1}" -f'Fir','st'),
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{2}{1}{0}" -f 'ation','xclam','E'},{"{2}{3}{0}{1}" -f 'tio','n','In','forma'},{"{0}{1}" -f'No','ne'},{"{0}{1}" -f 'St','op'},{"{1}{0}{2}"-f 'tio','Ques','n'})]
		[string]$Icon = ("{1}{0}" -f 'e','Non'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Timeout = $configInstallationUITimeout,
		[Parameter(Mandatory=$false)]
		[switch]$TopMost = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) {
			Write-Log -Message ('By'+'passi'+'n'+'g '+'D'+'ialo'+'g '+'Box'+' '+'[M'+'od'+'e: '+"$deployMode]: "+"$Text...") -Source ${CmdletName}
			Return
		}
		
		
		If (-not $IsProcessUserInteractive) {
			[string]$DialogBoxResponse = Invoke-PSCommandAsUser -PassThru -Command ([scriptblock]::Create(('Sho'+'w'+'-DialogBo'+'x '+'-'+'Text '+"'$Test' "+'-T'+'itle '+"'$Title' "+'-But'+'t'+'ons '+"'$Buttons' "+'-'+'De'+'fa'+'ul'+'tButton '+"'$DefaultButton' "+'-'+'Icon '+"'$Icon' "+'-'+'T'+'imeout '+"'$Timeout' "+"-Topmost:`$$Topmost")))
			Return $DialogBoxResponse
		}
		
		Write-Log -Message ('Di'+'s'+'play '+'Di'+'alog'+' '+'Box'+' '+'wi'+'th '+'messag'+'e'+': '+"$Text...") -Source ${CmdletName}
		
		[hashtable]$dialogButtons = @{
			'OK' = 0
			("{2}{1}{0}"-f 'l','nce','OKCa') = 1
			("{2}{1}{0}{3}"-f'ryIgnor','Ret','Abort','e') = 2
			("{2}{0}{1}" -f 'e','l','YesNoCanc') = 3
			("{0}{1}" -f 'Y','esNo') = 4
			("{1}{0}{2}"-f'y','Retr','Cancel') = 5
			("{3}{1}{5}{4}{0}{2}"-f 'inu','Co','e','CancelTryAgain','t','n') = 6
		}
		
		[hashtable]$dialogIcons = @{
			("{0}{1}" -f'No','ne') = 0
			("{1}{0}"-f 'op','St') = 16
			("{2}{0}{1}"-f'est','ion','Qu') = 32
			("{0}{2}{1}" -f'Excl','tion','ama') = 48
			("{0}{1}{2}{3}"-f 'In','forma','t','ion') = 64
		}
		
		[hashtable]$dialogDefaultButton = @{
			("{0}{1}"-f 'Fir','st') = 0
			("{1}{0}" -f 'cond','Se') = 256
			("{1}{0}" -f 'ird','Th') = 512
		}
		
		Switch ($TopMost) {
			$true { $dialogTopMost = 4096 }
			$false { $dialogTopMost = 0 }
		}
		
		$response = $Shell.Popup($Text, $Timeout, $Title, ($dialogButtons[$Buttons] + $dialogIcons[$Icon] + $dialogDefaultButton[$DefaultButton] + $dialogTopMost))
		
		Switch ($response) {
			1 {
				Write-Log -Message ("{0}{7}{5}{1}{4}{6}{2}{3}"-f'D',' ','e: ','OK','Box ','log','Respons','ia') -Source ${CmdletName}
				Write-Output 'OK'
			}
			2 {
				Write-Log -Message ("{5}{3}{4}{2}{0}{1}"-f' C','ancel','nse:','alog Box R','espo','Di') -Source ${CmdletName}
				Write-Output ("{2}{1}{0}" -f 'l','e','Canc')
			}
			3 {
				Write-Log -Message ("{6}{5}{3}{1}{4}{2}{0}" -f 'ort','x ','e: Ab','o','Respons',' B','Dialog') -Source ${CmdletName}
				Write-Output ("{0}{1}"-f'Abor','t')
			}
			4 {
				Write-Log -Message ("{3}{0}{1}{4}{2}" -f'alog Box ','Respon','Retry','Di','se: ') -Source ${CmdletName}
				Write-Output ("{1}{0}"-f 'try','Re')
			}
			5 {
				Write-Log -Message ("{5}{0}{1}{6}{3}{4}{2}" -f' Box ','Re','Ignore','ons','e: ','Dialog','sp') -Source ${CmdletName}
				Write-Output ("{2}{1}{0}" -f'e','r','Igno')
			}
			6 {
				Write-Log -Message ("{3}{2}{5}{4}{1}{0}" -f ' Yes','Response:','ialo','D','x ','g Bo') -Source ${CmdletName}
				Write-Output 'Yes'
			}
			7 {
				Write-Log -Message ("{1}{6}{2}{0}{4}{3}{5}"-f'espons','Di','x R',':','e',' No','alog Bo') -Source ${CmdletName}
				Write-Output 'No'
			}
			10 {
				Write-Log -Message ("{3}{0}{6}{4}{1}{5}{2}{7}"-f 'g Bo','se: T','y Ag','Dialo','spon','r','x Re','ain') -Source ${CmdletName}
				Write-Output ("{1}{2}{0}"-f'Again','Tr','y ')
			}
			11 {
				Write-Log -Message ("{6}{3}{5}{4}{2}{1}{0}"-f'inue','nt',': Co','ialo','onse','g Box Resp','D') -Source ${CmdletName}
				Write-Output ("{0}{1}{2}" -f 'C','ontinu','e')
			}
			-1 {
				Write-Log -Message ("{2}{3}{1}{4}{0}{5}" -f 'd Ou','log ','D','ia','Box Time','t...') -Source ${CmdletName}
				Write-Output ("{1}{0}"-f 'out','Time')
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-HardwarePlatform {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ("{4}{1}{3}{2}{7}{5}{8}{9}{6}{0}"-f '.',' ha','dwa','r','Retrieve','la','ion','re p','tfor','m informat') -Source ${CmdletName}
			$hwBios = Get-WmiObject -Class Win32_BIOS -ErrorAction ("{1}{0}" -f 'op','St') | Select-Object -Property Version, SerialNnumber
			$hwMakeModel = Get-WMIObject -Class Win32_ComputerSystem -ErrorAction ("{1}{0}"-f 'top','S') | Select-Object -Property Model, Manufacturer
			
			If ($hwBIOS.Version -match ("{1}{0}" -f 'UAL','VRT')) { $hwType = ("{2}{1}{0}"-f'per-V','y','Virtual:H') }
			ElseIf ($hwBIOS.Version -match ("{1}{0}"-f'M I','A ')) { $hwType = ("{3}{0}{2}{1}" -f'rtual:Virt',' PC','ual','Vi') }
			ElseIf ($hwBIOS.Version -like ("{0}{1}" -f '*Xen','*')) { $hwType = ("{0}{1}{2}" -f 'Vi','r','tual:Xen') }
			ElseIf ($hwBIOS.SerialNumber -like ("{1}{2}{0}" -f'*','*V','Mware')) { $hwType = ("{1}{0}{3}{2}" -f 'VM','Virtual:','re','Wa') }
			ElseIf ($hwMakeModel.Manufacturer -like ("{1}{2}{0}{3}" -f'ic','*','M','rosoft*')) { $hwType = ("{3}{2}{4}{1}{0}"-f 'Hyper-V','l:','r','Vi','tua') }
			ElseIf ($hwMakeModel.Manufacturer -like ("{0}{2}{1}" -f '*V','Ware*','M')) { $hwType = ("{2}{4}{0}{1}{3}" -f 'M','W','Virt','are','ual:V') }
			ElseIf ($hwMakeModel.Model -like ("{2}{0}{1}"-f 'al','*','*Virtu')) { $hwType = ("{1}{2}{0}" -f'ual','Vir','t') }
			Else { $hwType = ("{1}{0}{2}"-f'ysica','Ph','l') }
			
			Write-Output $hwType
		}
		Catch {
			Write-Log -Message "Failed to retrieve hardware platform information. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to retrieve hardware platform information: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-FreeDiskSpace {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Drive = $envSystemDrive,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ('Retr'+'ie'+'ve '+'fr'+'ee '+'dis'+'k '+'sp'+'a'+'ce '+'for'+' '+'dr'+'iv'+'e '+"[$Drive].") -Source ${CmdletName}
			$disk = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='$Drive'" -ErrorAction ("{1}{0}"-f'top','S')
			[double]$freeDiskSpace = [math]::Round($disk.FreeSpace / 1MB)

			Write-Log -Message ('Free'+' '+'d'+'isk '+'space'+' '+'fo'+'r '+'driv'+'e'+' '+"[$Drive]: "+"[$freeDiskSpace "+'MB]'+'.') -Source ${CmdletName}
			Write-Output $freeDiskSpace
		}
		Catch {
			Write-Log -Message "Failed to retrieve free disk space for drive [$Drive]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to retrieve free disk space for drive [$Drive]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-InstalledApplication {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string[]]$Name,
		[Parameter(Mandatory=$false)]
		[switch]$Exact = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$ProductCode,
		[Parameter(Mandatory=$false)]
		[switch]$IncludeUpdatesAndHotfixes
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($name) {
			Write-Log -Message "Get information for installed Application Name(s) [$($name -join ', ')]... " -Source ${CmdletName}
		}
		If ($productCode) {
			Write-Log -Message ('Get'+' '+'in'+'for'+'m'+'ation '+'for'+' '+'in'+'stal'+'led'+' '+'Pr'+'od'+'uct '+'Co'+'de '+"[$ProductCode]...") -Source ${CmdletName}
		}
		
		[psobject[]]$installedApplication = @()
		ForEach ($regKey in $regKeyApplications) {
			Try {
				If (Test-Path -Path $regKey -ErrorAction ("{0}{1}"-f'St','op')) {
					[psobject[]]$regKeyApplication = Get-ChildItem -Path $regKey -ErrorAction ("{0}{1}"-f'Sto','p') | ForEach-Object { Get-ItemProperty -LiteralPath $_.PSPath -ErrorAction ("{1}{3}{0}{2}{4}"-f'Conti','Sil','nu','ently','e') | Where-Object { $_.DisplayName } }
					ForEach ($regKeyApp in $regKeyApplication) {
						Try {
							[string]$appDisplayName = ''
							[string]$appDisplayVersion = ''
							[string]$appPublisher = ''
							
							
							If (-not $IncludeUpdatesAndHotfixes) {
								If ($regKeyApp.DisplayName -match ((("{0}{1}{2}"-f '(?i)kba7q','d','+'))  -rePLacE  'a7q',[ChAR]92)) { Continue }
								If ($regKeyApp.DisplayName -match ("{0}{5}{3}{2}{4}{1}" -f 'Cumula','te','pd','U','a','tive ')) { Continue }
								If ($regKeyApp.DisplayName -match ("{2}{0}{1}{3}"-f'e','cu','S','rity Update')) { Continue }
								If ($regKeyApp.DisplayName -match ("{1}{0}"-f 'fix','Hot')) { Continue }
							}
							
							
							$appDisplayName = $regKeyApp.DisplayName -replace ((("{0}{4}{1}{3}{5}{2}"-f'[^{0}','0','F]','01F-{0}','u','u007'))  -F [cHAR]92),''
							$appDisplayVersion = $regKeyApp.DisplayVersion -replace ((("{0}{4}{1}{5}{3}{2}" -f '[','{','F]','u001F-{0}u007','^','0}')) -F [CHar]92),''
							$appPublisher = $regKeyApp.Publisher -replace ((("{0}{5}{1}{2}{4}{3}" -f '[','Yu00','1F','pYu007F]','-R','^Rp')) -CRePlaCE([ChAr]82+[ChAr]112+[ChAr]89),[ChAr]92),''

							
							[boolean]$Is64BitApp = If (($is64Bit) -and ($regKey -notmatch ((("{5}{4}{2}{7}{1}{0}{6}{3}" -f'43','w6','M:SOFTWARE','e','L','^HK','2Nod','DaKDaKWo')).replAce(([CHar]68+[CHar]97+[CHar]75),'\')))) { $true } Else { $false }
							
							If ($ProductCode) {
								
								If ($regKeyApp.PSChildName -match [regex]::Escape($productCode)) {
									Write-Log -Message ('F'+'ound '+'i'+'ns'+'talled '+'a'+'ppl'+'ica'+'tion '+"[$appDisplayName] "+'versio'+'n '+"[$appDisplayVersion] "+'mat'+'chin'+'g '+'pro'+'duct '+'co'+'de '+"[$productCode]") -Source ${CmdletName}
									$installedApplication += New-Object -TypeName PSObject -Property @{
										ProductCode = $regKeyApp.PSChildName
										DisplayName = $appDisplayName
										DisplayVersion = $appDisplayVersion
										UninstallString = $regKeyApp.UninstallString
										InstallSource = $regKeyApp.InstallSource
										InstallLocation = $regKeyApp.InstallLocation
										InstallDate = $regKeyApp.InstallDate
										Publisher = $appPublisher
										Is64BitApplication = $Is64BitApp
									}
								}
							}
							
							If ($name) {
								
								ForEach ($application in $Name) {
									$applicationMatched = $false
									If ($exact) {
										
										If ($regKeyApp.DisplayName -eq $application) {
											$applicationMatched = $true
											Write-Log -Message ('Foun'+'d '+'in'+'stalled'+' '+'ap'+'plication'+' '+"[$appDisplayName] "+'versi'+'o'+'n '+"[$appDisplayVersion] "+'e'+'xa'+'ctly '+'ma'+'t'+'ching '+'applicatio'+'n'+' '+'name'+' '+"[$application]") -Source ${CmdletName}
										}
									}
									
									ElseIf ($regKeyApp.DisplayName -match [regex]::Escape($application)) {
										$applicationMatched = $true
										Write-Log -Message ('Found'+' '+'in'+'sta'+'lled '+'ap'+'pl'+'i'+'cation '+"[$appDisplayName] "+'ve'+'rsion '+"[$appDisplayVersion] "+'m'+'atchin'+'g '+'a'+'ppl'+'ication '+'na'+'me '+"[$application]") -Source ${CmdletName}
									}
									
									If ($applicationMatched) {
										$installedApplication += New-Object -TypeName PSObject -Property @{
											ProductCode = $regKeyApp.PSChildName
											DisplayName = $appDisplayName
											DisplayVersion = $appDisplayVersion
											UninstallString = $regKeyApp.UninstallString
											InstallSource = $regKeyApp.InstallSource
											InstallLocation = $regKeyApp.InstallLocation
											InstallDate = $regKeyApp.InstallDate
											Publisher = $appPublisher
											Is64BitApplication = $Is64BitApp
										}
									}
								}
							}
						}
						Catch {
							Write-Log -Message "Failed to resolve application details from registry for [$appDisplayName]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
							Continue
						}
					}
				}
			}
			Catch {
				Write-Log -Message "Failed to resolve registry path [$regKey]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				Continue
			}
		}
		Write-Output $installedApplication
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Execute-MSI {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateSet({"{0}{1}{2}" -f'I','nsta','ll'},{"{3}{0}{1}{2}"-f'inst','al','l','Un'},{"{1}{0}" -f'tch','Pa'},{"{1}{0}"-f'air','Rep'},{"{0}{2}{1}" -f 'Ac','tup','tiveSe'})]
		[string]$Action,
		[Parameter(Mandatory=$true,HelpMessage={"{9}{6}{14}{3}{13}{10}{1}{18}{11}{4}{12}{8}{16}{17}{2}{0}{7}{5}{15}"-f ' P','ther the pa',' the',' ent','/M','u','le','rod','ile','P','r ei','h to the MSI','SP f','e','ase','ctCode',' o','r','t'})]
		[ValidateScript({($_ -match $MSIProductCodeRegExPattern) -or (("{0}{1}"-f '.m','si'),("{0}{1}" -f '.m','sp') -contains [System.IO.Path]::GetExtension($_))})]
		[Alias({"{0}{2}{1}" -f 'Fil','Path','e'})]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Transform,
		[Parameter(Mandatory=$false)]
		[Alias({"{0}{1}" -f 'Argument','s'})]
		[ValidateNotNullorEmpty()]
		[string]$Parameters,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Patch,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$private:LogName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$WorkingDirectory,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		[boolean]$PathIsProductCode = $false
		
		
		If ($Path -match $MSIProductCodeRegExPattern) {
			
			[boolean]$PathIsProductCode = $true
			
			
			Write-Log -Message ("{9}{11}{7}{5}{10}{0}{12}{8}{2}{1}{3}{6}{4}" -f'ode ',' n','on','am',' version.','ct ','e, and','u','plicati','Resolve pr','c','od','to a publisher, ap') -Source ${CmdletName}
			[psobject]$productCodeNameVersion = Get-InstalledApplication -ProductCode $path | Select-Object -Property Publisher, DisplayName, DisplayVersion -First 1 -ErrorAction ("{1}{3}{2}{0}" -f 'ntinue','Silent','Co','ly')
			
			
			If (-not $logName) {
				If ($productCodeNameVersion) {
					If ($productCodeNameVersion.Publisher) {
						$logName = ($productCodeNameVersion.Publisher + '_' + $productCodeNameVersion.DisplayName + '_' + $productCodeNameVersion.DisplayVersion) -replace "[$invalidFileNameChars]",'' -replace ' ',''
					}
					Else {
						$logName = ($productCodeNameVersion.DisplayName + '_' + $productCodeNameVersion.DisplayVersion) -replace "[$invalidFileNameChars]",'' -replace ' ',''
					}
				}
				Else {
					
					$logName = $Path
				}
			}
		}
		Else {
			
			If (-not $logName) { $logName = ([System.IO.FileInfo]$path).BaseName } ElseIf (("{1}{0}"-f'og','.l'),("{0}{1}"-f '.t','xt') -contains [System.IO.Path]::GetExtension($logName)) { $logName = [System.IO.Path]::GetFileNameWithoutExtension($logName) }
		}
		
		If ($configToolkitCompressLogs) {
			
			[string]$logPath = Join-Path -Path $logTempFolder -ChildPath $logName
		}
		Else {
			
			If (-not (Test-Path -Path $configMSILogDir -PathType Container -ErrorAction ("{5}{3}{2}{0}{4}{1}"-f 'i','e','lyCont','ent','nu','Sil'))) {
				New-Item -Path $configMSILogDir -ItemType Directory -ErrorAction ("{4}{2}{1}{3}{0}"-f 'ue','n','yCo','tin','Silentl') | Out-Null
			}
			
			[string]$logPath = Join-Path -Path $configMSILogDir -ChildPath $logName
		}
		
		
		If ($deployModeSilent) {
			$msiInstallDefaultParams = $configMSISilentParams
			$msiUninstallDefaultParams = $configMSISilentParams
		}
		Else {
			$msiInstallDefaultParams = $configMSIInstallParams
			$msiUninstallDefaultParams = $configMSIUninstallParams
		}
		
		
		Switch ($action) {
			("{1}{2}{0}" -f'tall','In','s') { $option = '/i'; [string]$msiLogFile = "$logPath" + ("{0}{2}{1}" -f'_Ins','l','tal'); $msiDefaultParams = $msiInstallDefaultParams }
			("{3}{0}{2}{1}" -f'nsta','l','l','Uni') { $option = '/x'; [string]$msiLogFile = "$logPath" + ("{0}{1}{2}"-f'_Un','insta','ll'); $msiDefaultParams = $msiUninstallDefaultParams }
			("{0}{1}" -f'P','atch') { $option = ("{1}{2}{0}"-f 'te','/','upda'); [string]$msiLogFile = "$logPath" + ("{0}{1}{2}"-f '_Pa','tc','h'); $msiDefaultParams = $msiInstallDefaultParams }
			("{1}{0}" -f 'air','Rep') { $option = '/f'; [string]$msiLogFile = "$logPath" + ("{0}{1}" -f'_Repa','ir'); $msiDefaultParams = $msiInstallDefaultParams }
			("{2}{0}{1}" -f'eSetu','p','Activ') { $option = ("{0}{1}"-f '/','fups'); [string]$msiLogFile = "$logPath" + ("{3}{2}{0}{1}" -f'tiveS','etup','c','_A') }
		}
		
		
		If ([System.IO.Path]::GetExtension($msiLogFile) -ne ("{1}{0}" -f'log','.')) {
			[string]$msiLogFile = $msiLogFile + ("{1}{0}"-f 'log','.')
			[string]$msiLogFile = "`"$msiLogFile`""
		}
		
		
		If (Test-Path -Path (Join-Path -Path $dirFiles -ChildPath $path -ErrorAction ("{2}{3}{1}{0}"-f'yContinue','ntl','S','ile')) -PathType Leaf -ErrorAction ("{0}{4}{1}{2}{3}" -f 'Sil','lyCo','ntin','ue','ent')) {
			[string]$msiFile = Join-Path -Path $dirFiles -ChildPath $path
		}
		Else {
			[string]$msiFile = $Path
		}
		
		
		If ((-not $PathIsProductCode) -and (-not $workingDirectory)) { [string]$workingDirectory = Split-Path -Path $msiFile -Parent }
		
		
		If ($PathIsProductCode) {
			[string]$MSIProductCode = $path
		}
		Else {
			Try {
				[string]$MSIProductCode = Get-MsiTableProperty -Path $msiFile -Table ("{2}{0}{1}" -f 'o','perty','Pr') -ContinueOnError $false | Select-Object -ExpandProperty ProductCode -ErrorAction ("{0}{1}" -f'St','op')
			}
			Catch {
				Write-Log -Message ('Fai'+'led '+'to'+' '+'ge'+'t '+'th'+'e '+'Produc'+'t'+'Cod'+'e '+'from'+' '+'th'+'e '+'MSI'+' '+'file'+'. '+'Con'+'ti'+'nue '+'wit'+'h '+'re'+'qu'+'ested '+'ac'+'tion '+"[$Action]...") -Source ${CmdletName}
			}
		}
		
		
		[string]$msiFile = "`"$msiFile`""
		
		[string]$mstFile = "`"$transform`""
		
		[string]$mspFile = "`"$patch`""

		
		[string]$argsMSI = ("$option "+"$msiFile")
		
		If ($transform) { $argsMSI = ("$argsMSI "+"TRANSFORMS=$mstFile "+'TRANSFORM'+'SSECUR'+'E'+'=1') }
		
		If ($patch) { $argsMSI = ("$argsMSI "+"PATCH=$mspFile") }
		
		If ($Parameters) { $argsMSI = ("$argsMSI "+"$Parameters") } Else { $argsMSI = ("$argsMSI "+"$msiDefaultParams") }
		
		$argsMSI = ("$argsMSI "+"$configMSILoggingOptions "+"$msiLogFile")
		
		
		If ($MSIProductCode) {
			[psobject]$IsMsiInstalled = Get-InstalledApplication -ProductCode $MSIProductCode
		}
		Else {
			If ($Action -eq ("{2}{1}{0}"-f'l','l','Insta')) { [boolean]$IsMsiInstalled = $false } Else { [boolean]$IsMsiInstalled = $true }
		}
		
		If (($IsMsiInstalled) -and ($Action -eq ("{2}{0}{1}"-f 'a','ll','Inst'))) {
			Write-Log -Message ('The'+' '+'MS'+'I '+'is'+' '+'al'+'read'+'y '+'i'+'n'+'stalled'+' '+'on'+' '+'th'+'is '+'s'+'ystem'+'. '+'Skippin'+'g'+' '+'action'+' '+"[$Action]...") -Source ${CmdletName}
		}
		ElseIf (((-not $IsMsiInstalled) -and ($Action -eq ("{1}{0}" -f'all','Inst'))) -or ($IsMsiInstalled)) {
			
			Write-Log -Message ('Ex'+'ecutin'+'g '+'MSI'+' '+'a'+'c'+'tion '+"[$Action]...") -Source ${CmdletName}
			If ($ContinueOnError) {
				If ($WorkingDirectory) {
					Execute-Process -Path $exeMsiexec -Parameters $argsMSI -WorkingDirectory $WorkingDirectory -WindowStyle Normal -ContinueOnError $true
				}
				Else {
					Execute-Process -Path $exeMsiexec -Parameters $argsMSI -WindowStyle Normal -ContinueOnError $true
				}
			}
			Else {
				If ($WorkingDirectory) {
					Execute-Process -Path $exeMsiexec -Parameters $argsMSI -WorkingDirectory $WorkingDirectory -WindowStyle Normal
				}
				Else {
					Execute-Process -Path $exeMsiexec -Parameters $argsMSI -WindowStyle Normal
				}
			}
		}
		Else {
			Write-Log -Message ('The'+' '+'M'+'SI '+'i'+'s '+'n'+'ot '+'insta'+'l'+'le'+'d '+'on'+' '+'thi'+'s '+'sy'+'ste'+'m. '+'Sk'+'ippi'+'ng'+' '+'ac'+'tion'+' '+"[$Action]...") -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Remove-MSIApplications {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[switch]$Exact = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($Exact) {
			[psobject[]]$installedApplications = Get-InstalledApplication -Name $name -Exact
		}
		Else {
			[psobject[]]$installedApplications = Get-InstalledApplication -Name $name
		}
		
		If (($null -ne $installedApplications) -and ($installedApplications.Count)) {
			ForEach ($installedApplication in $installedApplications) {
				If ($installedApplication.UninstallString -match ("{0}{1}" -f'msie','xec')) {
					Write-Log -Message "Remove application [$($installedApplication.DisplayName) $($installedApplication.Version)]. " -Source ${CmdletName}
					If ($ContinueOnError) {
						Execute-MSI -Action Uninstall -Path $installedApplication.ProductCode -ContinueOnError $true
					}
					Else {
						Execute-MSI -Action Uninstall -Path $installedApplication.ProductCode
					}
				}
				Else {
					Write-Log -Message "[$($installedApplication.DisplayName)] uninstall string [$($installedApplication.UninstallString)] does not match `"msiexec`", so removal will not proceed. " -Severity 2 -Source ${CmdletName}
				}
			}
		}
		Else {
			Write-Log -Message ("{5}{4}{1}{2}{3}{6}{7}{0}" -f 'tinue...','i','on','s found for removal.','licat','No app',' C','on') -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Execute-Process {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[Alias({"{2}{0}{1}" -f 'ilePat','h','F'})]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[Alias({"{2}{1}{0}" -f 's','ument','Arg'})]
		[ValidateNotNullorEmpty()]
		[string[]]$Parameters,
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{1}{0}" -f 'ormal','N'},{"{1}{2}{0}"-f 'den','Hi','d'},{"{2}{1}{0}" -f'ed','ximiz','Ma'},{"{3}{2}{0}{1}" -f'i','zed','m','Mini'})]
		[System.Diagnostics.ProcessWindowStyle]$WindowStyle = ("{2}{1}{0}" -f 'l','orma','N'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[switch]$CreateNoWindow = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$WorkingDirectory,
		[Parameter(Mandatory=$false)]
		[switch]$NoWait = $false,
		[Parameter(Mandatory=$false)]
		[switch]$PassThru = $false,
		[Parameter(Mandatory=$false)]
		[switch]$WaitForMsiExec = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[timespan]$MsiExecWaitTime = $(New-TimeSpan -Seconds $configMSIMutexWaitTime),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$IgnoreExitCodes,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			$returnCode = $null
			
			
			If (([System.IO.Path]::IsPathRooted($Path)) -and ([System.IO.Path]::HasExtension($Path))) {
				Write-Log -Message ("[$Path] "+'is'+' '+'a '+'val'+'id'+' '+'fu'+'ll'+'y '+'qua'+'l'+'ified '+'p'+'ath'+', '+'co'+'ntinue.') -Source ${CmdletName}
				If (-not (Test-Path -Path $Path -PathType Leaf -ErrorAction ("{1}{0}"-f'p','Sto'))) {
					Throw ('F'+'ile '+"[$Path] "+'n'+'ot '+'fo'+'un'+'d.')
				}
			}
			Else {
				
				[string]$PathFolders = $dirFiles
				
				[string]$PathFolders = $PathFolders + ';' + (Get-Location -PSProvider ("{0}{2}{1}" -f 'Fi','m','leSyste')).Path
				
				$env:PATH = $PathFolders + ';' + $env:PATH
				
				
				[string]$FullyQualifiedPath = Get-Command -Name $Path -CommandType ("{0}{2}{1}" -f'Ap','ation','plic') -TotalCount 1 -Syntax -ErrorAction ("{2}{1}{0}{3}"-f 'Continu','ilently','S','e')
				
				
				$env:PATH = $env:PATH -replace [regex]::Escape($PathFolders + ';'), ''
				
				If ($FullyQualifiedPath) {
					Write-Log -Message ("[$Path] "+'su'+'ccess'+'fully '+'re'+'solved '+'to'+' '+'f'+'ully '+'qu'+'al'+'ified '+'p'+'ath '+"[$FullyQualifiedPath].") -Source ${CmdletName}
					$Path = $FullyQualifiedPath
				}
				Else {
					Throw ("[$Path] "+'cont'+'ain'+'s '+'an'+' '+'invalid'+' '+'path'+' '+'o'+'r '+'file'+' '+'na'+'me.')
				}
			}
			
			
			If (-not $WorkingDirectory) { $WorkingDirectory = Split-Path -Path $Path -Parent -ErrorAction ("{0}{1}" -f'S','top') }
			
			
			
			
			If (($Path -match ("{0}{2}{1}" -f'm','ec','siex')) -or ($WaitForMsiExec)) {
				[boolean]$MsiExecAvailable = Test-MsiExecMutex -MsiExecWaitTime $MsiExecWaitTime
				Start-Sleep -Seconds 1
				If (-not $MsiExecAvailable) {
					
					[int32]$returnCode = 1618
					Throw ("{8}{10}{3}{13}{12}{9}{4}{6}{5}{14}{15}{7}{1}{2}{11}{0}" -f'.','th ','this','omp',' i','f','nstallation be','eding wi','P','s MSI','lease c',' install','e in progres','let','ore proc','e')
				}
			}
			
			Try {
				
				$env:SEE_MASK_NOZONECHECKS = 1
				
				
				$private:ErrorActionPreference = ("{0}{1}" -f'S','top')
				
				
				$processStartInfo = New-Object -TypeName System.Diagnostics.ProcessStartInfo -ErrorAction ("{1}{0}" -f 'top','S')
				$processStartInfo.FileName = $Path
				$processStartInfo.WorkingDirectory = $WorkingDirectory
				$processStartInfo.UseShellExecute = $false
				$processStartInfo.ErrorDialog = $false
				$processStartInfo.RedirectStandardOutput = $true
				$processStartInfo.RedirectStandardError = $true
				$processStartInfo.CreateNoWindow = $CreateNoWindow
				If ($Parameters) { $processStartInfo.Arguments = $Parameters }
				If ($windowStyle) { $processStartInfo.WindowStyle = $WindowStyle }
				$process = New-Object -TypeName System.Diagnostics.Process -ErrorAction ("{0}{1}"-f 'St','op')
				$process.StartInfo = $processStartInfo
				
				
				[scriptblock]$processEventHandler = { If (-not [string]::IsNullOrEmpty($EventArgs.Data)) { $Event.MessageData.AppendLine($EventArgs.Data) } }
				$stdOutBuilder = New-Object -TypeName System.Text.StringBuilder -ArgumentList ''
				$stdOutEvent = Register-ObjectEvent -InputObject $process -Action $processEventHandler -EventName ("{1}{3}{0}{2}{4}"-f'Re','Ou','ce','tputData','ived') -MessageData $stdOutBuilder -ErrorAction ("{0}{1}" -f 'S','top')
				
				
				Write-Log -Message ('Work'+'i'+'ng '+'D'+'i'+'rectory '+'is'+' '+"[$WorkingDirectory]") -Source ${CmdletName}
				If ($Parameters) {
					If ($Parameters -match ((("{0}{3}{4}{2}{1}"-f '-','V&','K8','Com','mand '))-REpLacE'K8V',[chaR]92)) {
						Write-Log -Message ('Ex'+'ecu'+'t'+'ing '+"[$Path "+'[Po'+'wer'+'Shell'+' '+'Sc'+'riptBlock]'+']'+'..'+'.') -Source ${CmdletName}
					}
					Else{
						Write-Log -Message ('Exec'+'utin'+'g '+"[$Path "+"$Parameters]...") -Source ${CmdletName}
					}
				}
				Else {
					Write-Log -Message ('Ex'+'ecu'+'ting '+"[$Path]...") -Source ${CmdletName}
				}
				[boolean]$processStarted = $process.Start()
				
				If ($NoWait) {
					Write-Log -Message ("{8}{5}{3}{2}{6}{0}{7}{4}{9}{1}{10}{11}"-f 'ed.','waiting for ','er ',' paramet','nuing with','t','specifi',' Conti','NoWai','out ','exit c','ode...') -Source ${CmdletName}
				}
				Else {
					$process.BeginOutputReadLine()
					$stdErr = $($process.StandardError.ReadToEnd()).ToString() -replace $null,''
					
					
					$process.WaitForExit()
					
					
					While (-not ($process.HasExited)) { $process.Refresh(); Start-Sleep -Seconds 1 }
					
					
					[int32]$returnCode = $process.ExitCode
					
					
					If ($stdOutEvent) { Unregister-Event -SourceIdentifier $stdOutEvent.Name -ErrorAction ("{0}{1}"-f'St','op'); $stdOutEvent = $null }
					$stdOut = $stdOutBuilder.ToString() -replace $null,''
					
					If ($stdErr.Length -gt 0) {
						Write-Log -Message ('Standa'+'rd '+'erro'+'r'+' '+'outp'+'ut '+'f'+'rom '+'t'+'he '+'proces'+'s:'+' '+"$stdErr") -Severity 3 -Source ${CmdletName}
					}
				}
			}
			Finally {
				
				If ($stdOutEvent) { Unregister-Event -SourceIdentifier $stdOutEvent.Name -ErrorAction ("{1}{0}" -f'op','St')}
				
				
				If ($process) { $process.Close() }
				
				
				Remove-Item -Path env:SEE_MASK_NOZONECHECKS -ErrorAction ("{1}{0}{3}{4}{2}" -f 'len','Si','yContinue','t','l')
			}
			
			If (-not $NoWait) {
				
				$ignoreExitCodeMatch = $false
				If ($ignoreExitCodes) {
					
					[int32[]]$ignoreExitCodesArray = $ignoreExitCodes -split ','
					ForEach ($ignoreCode in $ignoreExitCodesArray) {
						If ($returnCode -eq $ignoreCode) { $ignoreExitCodeMatch = $true }
					}
				}
				
				If ($ContinueOnError) { $ignoreExitCodeMatch = $true }
				
				
				If ($PassThru) {
					Write-Log -Message ('E'+'xecu'+'tion '+'comple'+'t'+'ed'+' '+'wi'+'th '+'e'+'xit '+'c'+'ode '+"[$returnCode]") -Source ${CmdletName}
					[psobject]$ExecutionResults = New-Object -TypeName PSObject -Property @{ ExitCode = $returnCode; StdOut = $stdOut; StdErr = $stdErr }
					Write-Output $ExecutionResults
				}
				ElseIf ($ignoreExitCodeMatch) {
					Write-Log -Message ('Ex'+'ec'+'ution '+'comp'+'l'+'et'+'e '+'and'+' '+'the'+' '+'exit'+' '+'code'+' '+"[$returncode] "+'is'+' '+'being'+' '+'ig'+'nored') -Source ${CmdletName}
				}
				ElseIf (($returnCode -eq 3010) -or ($returnCode -eq 1641)) {
					Write-Log -Message ('Ex'+'ecut'+'ion '+'comp'+'let'+'ed '+'succe'+'s'+'sfully'+' '+'wit'+'h '+'exit'+' '+'c'+'ode '+"[$returnCode]. "+'A '+'r'+'eboot '+'i'+'s '+'requ'+'ired.') -Severity 2 -Source ${CmdletName}
					Set-Variable -Name msiRebootDetected -Value $true -Scope Script
				}
				ElseIf (($returnCode -eq 1605) -and ($Path -match ("{1}{0}" -f 'ec','msiex'))) {
					Write-Log -Message ('Exe'+'cution'+' '+'fa'+'ile'+'d '+'with'+' '+'e'+'xit '+'cod'+'e '+"[$returnCode] "+'be'+'c'+'ause '+'th'+'e '+'pro'+'duct '+'is'+' '+'no'+'t '+'c'+'urrently'+' '+'in'+'st'+'alled.') -Severity 3 -Source ${CmdletName}
				}
				ElseIf (($returnCode -eq -2145124329) -and ($Path -match ("{1}{0}"-f 'sa','wu'))) {
					Write-Log -Message ('Exe'+'cu'+'tion '+'fa'+'ile'+'d '+'wit'+'h '+'exi'+'t '+'code'+' '+"[$returnCode] "+'beca'+'use'+' '+'t'+'he '+'Windo'+'ws '+'Upd'+'ate '+'is'+' '+'n'+'ot '+'a'+'pplicable'+' '+'t'+'o '+'t'+'his '+'sys'+'te'+'m.') -Severity 3 -Source ${CmdletName}
				}
				ElseIf (($returnCode -eq 17025) -and ($Path -match ("{2}{1}{0}" -f 'file','ull','f'))) {
					Write-Log -Message ('Execut'+'ion'+' '+'fa'+'ile'+'d '+'with'+' '+'e'+'xit '+'c'+'ode '+"[$returnCode] "+'be'+'cause'+' '+'the'+' '+'Off'+'ice '+'Up'+'dat'+'e '+'i'+'s '+'no'+'t '+'app'+'l'+'icable'+' '+'t'+'o '+'th'+'is '+'s'+'yste'+'m.') -Severity 3 -Source ${CmdletName}
				}
				ElseIf ($returnCode -eq 0) {
					Write-Log -Message ('Execu'+'t'+'i'+'on '+'com'+'pl'+'eted '+'successfu'+'l'+'ly '+'with'+' '+'exi'+'t '+'code'+' '+"[$returnCode]") -Source ${CmdletName}
				}
				Else {
					[string]$MsiExitCodeMessage = ''
					If ($Path -match ("{1}{2}{0}"-f 'xec','ms','ie')) {
						[string]$MsiExitCodeMessage = Get-MsiExitCodeMessage -MsiExitCode $returnCode
					}
					
					If ($MsiExitCodeMessage) {
						Write-Log -Message ('Exe'+'cu'+'ti'+'on '+'fail'+'ed '+'w'+'ith '+'e'+'xit '+'code'+' '+"[$returnCode]: "+"$MsiExitCodeMessage") -Severity 3 -Source ${CmdletName}
					}
					Else {
						Write-Log -Message ('Exe'+'c'+'u'+'tion '+'fai'+'l'+'ed '+'wit'+'h '+'e'+'xit '+'co'+'de '+"[$returnCode]") -Severity 3 -Source ${CmdletName}
					}
					Exit-Script -ExitCode $returnCode
				}
			}
		}
		Catch {
			If ([string]::IsNullOrEmpty([string]$returnCode)) {
				[int32]$returnCode = 999
				Write-Log -Message "Function failed, setting exit code to [$returnCode]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			}
			Else {
				Write-Log -Message "Execution completed with exit code [$returnCode]. Function failed. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			}
			If ($PassThru) {
				[psobject]$ExecutionResults = New-Object -TypeName PSObject -Property @{ ExitCode = $returnCode; StdOut = If ($stdOut) { $stdOut } Else { '' }; StdErr = If ($stdErr) { $stdErr } Else { '' } }
				Write-Output $ExecutionResults
			}
			Else {
				Exit-Script -ExitCode $returnCode
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-MsiExitCodeMessage {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[int32]$MsiExitCode
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$MsiExitCodeMsgSource = @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;
		public class MsiExitCode
		{
			enum LoadLibraryFlags : int
			{
				DONT_RESOLVE_DLL_REFERENCES         = 0x00000001,
				LOAD_IGNORE_CODE_AUTHZ_LEVEL        = 0x00000010,
				LOAD_LIBRARY_AS_DATAFILE            = 0x00000002,
				LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE  = 0x00000040,
				LOAD_LIBRARY_AS_IMAGE_RESOURCE      = 0x00000020,
				LOAD_WITH_ALTERED_SEARCH_PATH       = 0x00000008
			}
			
			[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
			static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, LoadLibraryFlags dwFlags);
			
			[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
			static extern int LoadString(IntPtr hInstance, int uID, StringBuilder lpBuffer, int nBufferMax);
			
			// Get MSI exit code message from msimsg.dll resource dll
			public static string GetMessageFromMsiExitCode(int errCode)
			{
				IntPtr hModuleInstance = LoadLibraryEx("msimsg.dll", IntPtr.Zero, LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE);
				
				StringBuilder sb = new StringBuilder(255);
				LoadString(hModuleInstance, errCode, sb, sb.Capacity + 1);
				
				return sb.ToString();
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{3}{0}{2}{1}" -f 'i','itCode','Ex','Ms')).Type) {
			Add-Type -TypeDefinition $MsiExitCodeMsgSource -Language CSharp -IgnoreWarnings -ErrorAction ("{1}{0}" -f 'top','S')
		}
	}
	Process {
		Try {
			Write-Log -Message ('G'+'et '+'mes'+'sage'+' '+'for'+' '+'ex'+'it '+'c'+'ode '+"[$MsiExitCode].") -Source ${CmdletName}
			[string]$MsiExitCodeMsg = [MsiExitCode]::GetMessageFromMsiExitCode($MsiExitCode)
			Write-Output $MsiExitCodeMsg
		}
		Catch {
			Write-Log -Message "Failed to get message for exit code [$MsiExitCode]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-MsiExecMutex {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[timespan]$MsiExecWaitTime = $(New-TimeSpan -Seconds $configMSIMutexWaitTime)
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$IsMsiExecFreeSource = @'
		using System;
		using System.Threading;
		public class MsiExec
		{
			public static bool IsMsiExecFree(TimeSpan maxWaitTime)
			{
				// Wait (up to a timeout) for the MSI installer service to become free.
				// Returns true for a successful wait, when the installer service has become free.
				// Returns false when waiting for the installer service has exceeded the timeout.
				const string installerServiceMutexName = "Global\\_MSIExecute";
				Mutex MSIExecuteMutex = null;
				bool isMsiExecFree = false;
				
				try
				{
					MSIExecuteMutex = Mutex.OpenExisting(installerServiceMutexName, System.Security.AccessControl.MutexRights.Synchronize);
					isMsiExecFree   = MSIExecuteMutex.WaitOne(maxWaitTime, false);
				}
				catch (WaitHandleCannotBeOpenedException)
				{
					// Mutex doesn't exist, do nothing
					isMsiExecFree = true;
				}
				catch (ObjectDisposedException)
				{
					// Mutex was disposed between opening it and attempting to wait on it, do nothing
					isMsiExecFree = true;
				}
				finally
				{
					if (MSIExecuteMutex != null && isMsiExecFree)
					MSIExecuteMutex.ReleaseMutex();
				}
				return isMsiExecFree;
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{2}{1}{0}"-f'Exec','i','Ms')).Type) {
			Add-Type -TypeDefinition $IsMsiExecFreeSource -Language CSharp -IgnoreWarnings -ErrorAction ("{1}{0}"-f 'top','S')
		}
	}
	Process {
		Try {
			If ($MsiExecWaitTime.TotalMinutes -gt 1) {
				[string]$WaitLogMsg = "$($MsiExecWaitTime.TotalMinutes) minutes "
			}
			ElseIf ($MsiExecWaitTime.TotalMinutes -eq 1) {
				[string]$WaitLogMsg = "$($MsiExecWaitTime.TotalMinutes) minute "
			}
			Else {
				[string]$WaitLogMsg = "$($MsiExecWaitTime.TotalSeconds) seconds "
			}
			Write-Log -Message ('Chec'+'k '+'t'+'o '+'s'+'ee '+'if'+' '+'mut'+'e'+'x '+(('[G'+'lo'+'balr'+'OYrOY_MSIE'+'xecute'+'] ')  -REPLACE  'rOY',[char]92)+'is'+' '+'avai'+'lable'+'. '+'Wait'+' '+'u'+'p '+'t'+'o '+"[$WaitLogMsg] "+'for'+' '+'th'+'e '+'mutex'+' '+'t'+'o '+'be'+'come '+'availab'+'le'+'.') -Source ${CmdletName}
			[boolean]$IsMsiExecInstallFree = [MsiExec]::IsMsiExecFree($MsiExecWaitTime)
			
			If ($IsMsiExecInstallFree) {
				Write-Log -Message ((("{2}{1}{3}{5}{4}{7}{0}{8}{6}"-f ' a','U','Mutex [Global','Bb','b_MSIExecute] i','UB','ble.','s','vaila'))-RePLaCE ([CHaR]85+[CHaR]66+[CHaR]98),[CHaR]92) -Source ${CmdletName}
			}
			Else {
				
				[string]$msiInProgressCmdLine = Get-WmiObject -Class Win32_Process -Filter ((("{6}{0}{8}{4}{1}{2}{3}{7}{5}" -f ' ','i','exe','c.ex','IZms','bIZ','name','e','= b'))-REPlaCE ([ChAR]98+[ChAR]73+[ChAR]90),[ChAR]39) | Select-Object -ExpandProperty CommandLine | Where-Object { $_ -match ((("{1}{2}{0}"-f 'i','toI.','ms')).replacE('toI',[sTRiNG][cHaR]92)) } | ForEach-Object { $_.Trim() }
				Write-Log -Message ('M'+'ute'+'x '+(('['+'Global'+'0hX0h'+'X_MS'+'IEx'+'ec'+'u'+'te] ') -RepLaCE'0hX',[cHAr]92)+'is'+' '+'n'+'ot '+'availa'+'bl'+'e '+'becau'+'s'+'e '+'t'+'he '+'fo'+'l'+'lowing '+'MS'+'I '+'installat'+'io'+'n '+'i'+'s '+'in'+' '+'pr'+'ogr'+'ess '+"[$msiInProgressCmdLine]") -Severity 2 -Source ${CmdletName}
			}
			Write-Output $IsMsiExecInstallFree
		}
		Catch {
			Write-Log -Message "Failed check for availability of mutex [Global\\_MSIExecute]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			
			Write-Output $true
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function New-Folder {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			If (-not (Test-Path -Path $Path -PathType Container)) {
				Write-Log -Message ('C'+'rea'+'te '+'f'+'older '+"[$Path].") -Source ${CmdletName}
				New-Item -Path $Path -ItemType Directory -ErrorAction ("{0}{1}"-f 'S','top')
			}
			Else {
				Write-Log -Message ('F'+'older'+' '+"[$Path] "+'alre'+'a'+'dy '+'e'+'xist'+'s.') -Source ${CmdletName}
			}
		}
		Catch {
			Write-Log -Message "Failed to create folder [$Path]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to create folder [$Path]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Remove-Folder {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			If (Test-Path -Path $Path -PathType Container) {
				Write-Log -Message ('D'+'ele'+'te '+'fol'+'de'+'r('+'s) '+'an'+'d '+'fi'+'le('+'s) '+'recursiv'+'el'+'y '+'f'+'rom '+'p'+'ath '+"[$path]...") -Source ${CmdletName}
				Remove-Item -Path $Path -Force -Recurse -ErrorAction ("{0}{1}" -f 'S','top') | Out-Null
			}
			Else {
				Write-Log -Message ('F'+'older '+"[$Path] "+'d'+'oes '+'no'+'t '+'exists.'+'..') -Source ${CmdletName}
			}
		}
		Catch {
			Write-Log -Message "Failed to delete folder(s) and file(s) recursively from path [$path]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to delete folder(s) and file(s) recursively from path [$path]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Copy-File {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Destination,
		[Parameter(Mandatory=$false)]
		[switch]$Recurse = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			If ((-not ([System.IO.Path]::HasExtension($Destination))) -and (-not (Test-Path -Path $Destination -PathType Container))) {
				New-Item -Path $Destination -Type ("{3}{2}{1}{0}"-f'y','or','irect','D') -Force -ErrorAction ("{1}{0}" -f 'p','Sto') | Out-Null
			}
			
			If ($Recurse) {
				Write-Log -Message ('Copy'+' '+'f'+'ile'+'(s) '+'recurs'+'i'+'vely '+'in'+' '+'pat'+'h '+"[$path] "+'t'+'o '+'dest'+'ination'+' '+"[$destination]") -Source ${CmdletName}
				Copy-Item -Path $Path -Destination $destination -Force -Recurse -ErrorAction ("{1}{0}"-f'top','S') | Out-Null
			}
			Else {
				Write-Log -Message ('Copy'+' '+'f'+'ile '+'in'+' '+'pa'+'th '+"[$path] "+'to'+' '+'des'+'t'+'inat'+'ion '+"[$destination]") -Source ${CmdletName}
				Copy-Item -Path $Path -Destination $destination -Force -ErrorAction ("{0}{1}"-f'S','top') | Out-Null
			}
		}
		Catch {
			Write-Log -Message "Failed to copy file(s) in path [$path] to destination [$destination]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to copy file(s) in path [$path] to destination [$destination]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Remove-File {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[switch]$Recurse,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			If ($Recurse) {
				Write-Log -Message ('Dele'+'te '+'fi'+'le(s)'+' '+'re'+'c'+'ursively '+'i'+'n '+'pa'+'th '+"[$path]...") -Source ${CmdletName}
				Remove-Item -Path $path -Force -Recurse -ErrorAction ("{0}{1}" -f 'St','op') | Out-Null
			}
			Else {
				Write-Log -Message ('Del'+'e'+'te '+'fi'+'le '+'i'+'n '+'p'+'ath '+"[$path]...") -Source ${CmdletName}
				Remove-Item -Path $path -Force -ErrorAction ("{1}{0}"-f 'top','S') | Out-Null
			}
		}
		Catch {
			Write-Log -Message "Failed to delete file(s) in path [$path]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to delete file(s) in path [$path]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Convert-RegistryPath {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$SID
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($Key -match ((("{8}{10}{17}{20}{7}{3}{14}{1}{2}{15}{4}{19}{16}{6}{0}{11}{12}{9}{13}{5}{18}"-f 'C','0','J','^HK','KU:n0Jn0J','Jn0','KC','uM','^HKLM:n0Jn0JauM','M','^',':n','0Jn0Jau','^HKPD:n0','CR:n0Jn','auM^H','uM^H','HKCU:n0Jn0','J','a','Ja'))  -CrEPlacE([CHaR]110+[CHaR]48+[CHaR]74),[CHaR]92 -RePlACE  ([CHaR]97+[CHaR]117+[CHaR]77),[CHaR]124)) {
			
			$key = $key -replace ((("{0}{2}{1}{3}" -f'^','KLM:iy9iy','H','9')).repLaCe('iy9',[strinG][ChAr]92)), ((("{6}{4}{3}{1}{0}{2}{5}"-f'OCA','Y_L','L_MACHINE','E','K','ZN1','H')).REPlACe(([cHar]90+[cHar]78+[cHar]49),[sTrING][cHar]92))
			$key = $key -replace ((("{2}{1}{0}{3}"-f 'R:Ki1K','KC','^H','i1')) -rEplACE  'Ki1',[Char]92), ((("{1}{0}{3}{4}{2}" -f'LAS','HKEY_C','fL','S','ES_ROOTu')).rePlacE(([cHAr]117+[cHAr]102+[cHAr]76),[StrIng][cHAr]92))
			$key = $key -replace ((("{0}{3}{1}{2}{4}" -f'^',':2w','g2','HKCU','wg')).REpLaCE('2wg',[StrinG][chAr]92)), ((("{3}{4}{0}{2}{1}"-f'T','5V','_USERv','HKEY_CU','RREN'))  -CREplACe  ([chAr]118+[chAr]53+[chAr]86),[chAr]92)
			$key = $key -replace ((("{2}{1}{0}" -f '0}{0}','KU:{','^H'))-f [chAR]92), ((("{1}{2}{0}"-f '0}','HKEY_','USERS{'))  -F [chAr]92)
			$key = $key -replace ((("{0}{2}{1}" -f '^','C:i8Ji8J','HKC'))-RePlAce  ([cHAr]105+[cHAr]56+[cHAr]74),[cHAr]92), ((("{0}{5}{4}{1}{3}{2}"-f'HKEY_CU','ON','IGEx9','F','ENT_C','RR')).RePlace(([CHAR]69+[CHAR]120+[CHAR]57),'\'))
			$key = $key -replace ((("{1}{0}{2}"-f 'PD:CpFCp','^HK','F'))-RePlACe  ([CHAR]67+[CHAR]112+[CHAR]70),[CHAR]92), ((("{1}{3}{5}{2}{0}{4}" -f 'O','HKEY_','DATAQ','PERFOR','s','MANCE_')) -CReplaCE'QOs',[CHaR]92)
		}
		ElseIf ($Key -match ((("{2}{14}{5}{1}{7}{9}{8}{0}{6}{10}{12}{11}{3}{15}{4}{13}"-f'i',':i','^H','U:ioe^','KCC:ioe^HKPD','LM','o','o','^HKCU:','e','e^H','CR:ioe^HK','K',':','K','H')).rEPlAcE(([cHaR]105+[cHaR]111+[cHaR]101),'|'))) {
			
			$key = $key -replace ("{1}{2}{0}" -f'M:','^','HKL'), ((("{3}{0}{2}{1}{4}" -f'EY_LO','NEc7','CAL_MACHI','HK','l'))-CREPlaCe 'c7l',[cHaR]92)
			$key = $key -replace ("{0}{1}"-f '^HKCR',':'), ((("{2}{0}{4}{1}{3}{5}" -f 'CLASS','R','HKEY_','OOT{0','ES_','}'))  -F [ChaR]92)
			$key = $key -replace ("{0}{1}" -f'^','HKCU:'), ((("{4}{3}{1}{0}{2}{5}" -f '_CURRENT_','Y','USER','E','HK','uPY'))-CReplaCe  'uPY',[ChaR]92)
			$key = $key -replace ("{0}{1}"-f'^HKU',':'), ((("{2}{1}{0}"-f 'yL','KEY_USERSl','H'))-RepLace([CHaR]108+[CHaR]121+[CHaR]76),[CHaR]92)
			$key = $key -replace ("{1}{0}"-f 'C:','^HKC'), ((("{3}{4}{6}{1}{2}{0}{5}" -f'{','ONF','IG','HKEY_CUR','RENT_','0}','C'))-f  [chAr]92)
			$key = $key -replace ("{0}{1}" -f '^','HKPD:'), ((("{1}{0}{2}{3}" -f 'ANCE_DA','HKEY_PERFORM','TAS','mI')) -cReplACe 'SmI',[ChAR]92)
		}
		ElseIf ($Key -match ((("{2}{12}{16}{13}{11}{3}{4}{0}{10}{14}{15}{7}{9}{6}{8}{1}{5}{17}"-f'aFbaFbYzx','aFbaFb','^HK','x^','HKCU','Yz','Yz','HKUaF','x^HKCC','baFb','^HKCRaFba','bYz','L','FbaF','FbYz','x^','Ma','x^HKPDaFbaFb')).repLACe(([chAr]97+[chAr]70+[chAr]98),[striNg][chAr]92).repLACe('Yzx','|'))) {
			
			$key = $key -replace ((("{2}{0}{1}" -f'VouVo','u','^HKLM'))  -REpLace  'Vou',[ChAR]92), ((("{0}{4}{1}{3}{2}" -f 'H','Y_LOC','CHINErHS','AL_MA','KE'))-rEPLACe  ([ChaR]114+[ChaR]72+[ChaR]83),[ChaR]92)
			$key = $key -replace ((("{1}{0}{2}" -f'KCRoWQo','^H','WQ')).rEpLAce(([Char]111+[Char]87+[Char]81),'\')), ((("{0}{2}{1}{3}"-f 'HKEY_','ASSES_ROO','CL','T{0}'))  -F [char]92)
			$key = $key -replace ((("{2}{0}{3}{1}"-f'KCUE1','E1p','^H','p')).repLAcE('E1p','\')), ((("{3}{2}{1}{0}" -f'RfWl','RENT_USE','CUR','HKEY_')).ReplaCE('fWl','\'))
			$key = $key -replace ((("{1}{2}{0}" -f 'bPa','^H','KUbPa'))-crEPLAcE  'bPa',[ChAr]92), ((("{1}{2}{0}" -f 'S{0}','H','KEY_USER'))  -F[ChaR]92)
			$key = $key -replace ((("{0}{2}{1}"-f'^H','e4be4','KCCb')).replaCe('be4',[strING][chaR]92)), ((("{3}{2}{1}{0}{4}"-f'E','CURR','EY_','HK','NT_CONFIGpvA'))-ReplacE'pvA',[char]92)
			$key = $key -replace ((("{0}{1}"-f '^HKP','D{0}{0}'))-F [chAR]92), ((("{5}{0}{7}{6}{4}{2}{1}{3}" -f 'EY_PE','u','DATAi','2','MANCE_','HK','R','RFO')).RepLace(([chAr]105+[chAr]117+[chAr]50),'\'))
		}
		
		
		If ($PSBoundParameters.ContainsKey('SID')) {
			If ($key -match ((("{3}{5}{1}{2}{4}{0}{6}"-f 'ENT_USERQOFQO','C','UR','^HKE','R','Y_','F')).REPlacE('QOF','\'))) { $key = $key -replace ((("{7}{1}{2}{6}{5}{3}{0}{4}" -f'}','HK','EY_','T_USER{0','{0}','RREN','CU','^')) -F [CHar]92), "HKEY_USERS\$SID\" }
		}
		
		
		If ($key -notmatch ("{1}{2}{0}" -f 'try::','^','Regis')) { [string]$key = "Registry::$key" }
		
		Write-Log -Message ('Retu'+'r'+'n '+'fu'+'lly '+'qu'+'a'+'lified '+'regis'+'try'+' '+'k'+'ey '+'p'+'ath '+"[$key]") -Source ${CmdletName}
		Write-Output $key
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-RegistryKey {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Value,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$SID,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[switch]$ReturnEmptyKeyIfExists,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If ($PSBoundParameters.ContainsKey('SID')) {
				[string]$key = Convert-RegistryPath -Key $key -SID $SID
			}
			Else {
				[string]$key = Convert-RegistryPath -Key $key
			}
			
			
			If (-not (Test-Path -Path $key -ErrorAction ("{0}{1}"-f 'Sto','p'))) {
				Write-Log -Message ('R'+'egi'+'stry '+'key'+' '+"[$key] "+'doe'+'s '+'no'+'t '+'exi'+'st') -Severity 2 -Source ${CmdletName}
				$regKeyValue = $null
			}
			Else {
				If (-not $Value) {
					
					Write-Log -Message ('Ge'+'t '+'re'+'gi'+'st'+'ry '+'ke'+'y '+"[$key] "+'an'+'d '+'a'+'ll '+'pro'+'pe'+'rty'+' '+'val'+'ues') -Source ${CmdletName}
					$regKeyValue = Get-ItemProperty -Path $key -ErrorAction ("{1}{0}" -f'p','Sto')
					If ((-not $regKeyValue) -and ($ReturnEmptyKeyIfExists)) {
						Write-Log -Message ('N'+'o '+'pr'+'ope'+'rty '+'v'+'alues '+'fou'+'nd '+'for'+' '+'r'+'egi'+'stry '+'ke'+'y. '+'G'+'et '+'re'+'gist'+'ry '+'k'+'ey '+"[$key]") -Source ${CmdletName}
						$regKeyValue = Get-Item -Path $key -Force -ErrorAction ("{1}{0}" -f 'p','Sto')
					}
				}
				Else {
					
					Write-Log -Message ('Get'+' '+'regi'+'s'+'try '+'k'+'ey '+"[$key] "+'value'+' '+"[$value]") -Source ${CmdletName}
					$regKeyValue = Get-ItemProperty -Path $key -ErrorAction ("{1}{0}" -f'op','St') | Select-Object -ExpandProperty $Value -ErrorAction ("{2}{1}{0}{3}" -f 'lentlyCo','i','S','ntinue')
				}
			}
			
			If ($regKeyValue) { Write-Output $regKeyValue } Else { Write-Output $null }
		}
		Catch {
			If (-not $Value) {
				Write-Log -Message "Failed to read registry key [$key]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to read registry key [$key]: $($_.Exception.Message) "
				}
			}
			Else {
				Write-Log -Message "Failed to read registry key [$key] value [$value]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to read registry key [$key] value [$value]: $($_.Exception.Message) "
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-RegistryKey {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		$Value,
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{0}{1}"-f'Bin','ary'},{"{0}{1}" -f'DWo','rd'},{"{2}{0}{1}{3}" -f'x','pand','E','String'},{"{0}{2}{1}{3}" -f'Mul','n','tiStri','g'},{"{1}{0}"-f 'ne','No'},{"{1}{0}"-f'ord','QW'},{"{0}{1}" -f'S','tring'},{"{0}{1}"-f'U','nknown'})]
		[Microsoft.Win32.RegistryValueKind]$Type = ("{1}{2}{0}"-f 'g','Stri','n'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$SID,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			[string]$RegistryValueWriteAction = 'set'
			
			
			If ($PSBoundParameters.ContainsKey('SID')) {
				[string]$key = Convert-RegistryPath -Key $key -SID $SID
			}
			Else {
				[string]$key = Convert-RegistryPath -Key $key
			}
			
			
			If (-not (Test-Path -Path $key -ErrorAction ("{1}{0}"-f 'op','St'))) {
				Try {
					Write-Log -Message ('Cr'+'ea'+'te '+'regis'+'try'+' '+'ke'+'y '+"[$key].") -Source ${CmdletName}
					New-Item -Path $key -ItemType Registry -Force -ErrorAction ("{1}{0}" -f'op','St') | Out-Null
				}
				Catch {
					Throw
				}
			}
			
			If ($Name) {
				
				If (-not (Get-ItemProperty -Path $key -Name $Name -ErrorAction ("{4}{3}{2}{1}{0}"-f 'ontinue','yC','l','t','Silen'))) {
					Write-Log -Message ('Se'+'t '+'regi'+'stry '+'ke'+'y '+'v'+'alue: '+"[$key] "+"[$name "+'= '+"$value]") -Source ${CmdletName}
					New-ItemProperty -Path $key -Name $name -Value $value -PropertyType $Type -ErrorAction ("{0}{1}" -f 'Sto','p') | Out-Null
				}
				
				Else {
					[string]$RegistryValueWriteAction = ("{1}{0}" -f'pdate','u')
					Write-Log -Message ('Updat'+'e '+'reg'+'istry '+'key'+' '+'v'+'alu'+'e: '+"[$key] "+"[$name "+'= '+"$value]") -Source ${CmdletName}
					Set-ItemProperty -Path $key -Name $name -Value $value -ErrorAction ("{0}{1}" -f 'Sto','p') | Out-Null
				}
			}
		}
		Catch {
			If ($Name) {
				Write-Log -Message "Failed to $RegistryValueWriteAction value [$value] for registry key [$key] [$name]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to $RegistryValueWriteAction value [$value] for registry key [$key] [$name]: $($_.Exception.Message) "
				}
			}
			Else {
				Write-Log -Message "Failed to set registry key [$key]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to set registry key [$key]: $($_.Exception.Message) "
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Remove-RegistryKey {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[switch]$Recurse,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$SID,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If ($PSBoundParameters.ContainsKey('SID')) {
				[string]$key = Convert-RegistryPath -Key $key -SID $SID
			}
			Else {
				[string]$key = Convert-RegistryPath -Key $key
			}
			
			If (-not ($name)) {
				If ($Recurse) {
					Write-Log -Message ('Dele'+'t'+'e '+'re'+'gist'+'ry '+'key'+' '+'r'+'ecursi'+'vely '+"[$key]") -Source ${CmdletName}
					Remove-Item -Path $Key -ErrorAction ("{0}{1}"-f 'St','op') -Force -Recurse | Out-Null
				}
				Else {
					Write-Log -Message ('Delete'+' '+'re'+'gist'+'ry '+'ke'+'y '+"[$key]") -Source ${CmdletName}
					Remove-Item -Path $Key -ErrorAction ("{0}{1}"-f 'St','op') -Force | Out-Null
				}
			}
			Else {
				Write-Log -Message ('Del'+'e'+'te '+'r'+'egistry'+' '+'value'+' '+"[$key] "+"[$name]") -Source ${CmdletName}
				Remove-ItemProperty -Path $Key -Name $Name -ErrorAction ("{0}{1}"-f 'Sto','p') -Force | Out-Null
			}
		}
		Catch {
			If (-not ($name)) {
				Write-Log -Message "Failed to delete registry key [$key]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to delete registry key [$key]: $($_.Exception.Message) "
				}
			}
			Else {
				Write-Log -Message "Failed to delete registry value [$key] [$name]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to delete registry value [$key] [$name]: $($_.Exception.Message) "
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Invoke-HKCURegistrySettingsForAllUsers {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[scriptblock]$RegistrySettings,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[psobject[]]$UserProfiles = (Get-UserProfiles)
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		ForEach ($UserProfile in $UserProfiles) {
			Try {
				
				[string]$UserRegistryPath = "Registry::HKEY_USERS\$($UserProfile.SID)"
				
				
				[string]$UserRegistryHiveFile = Join-Path -Path $UserProfile.ProfilePath -ChildPath ("{1}{2}{0}"-f 'SER.DAT','NT','U')
				
				
				[boolean]$ManuallyLoadedRegHive = $false
				If (-not (Test-Path -Path $UserRegistryPath)) {
					
					If (Test-Path -Path $UserRegistryHiveFile -PathType Leaf) {
						Write-Log -Message "Load the User [$($UserProfile.NTAccount)] registry hive in path [HKEY_USERS\$($UserProfile.SID)] " -Source ${CmdletName}
						[string]$HiveLoadResult = & reg.exe load "`"HKEY_USERS\$($UserProfile.SID)`"" "`"$UserRegistryHiveFile`""
						
						If ($global:LastExitCode -ne 0) {
							Throw "Failed to load the registry hive for User [$($UserProfile.NTAccount)] with SID [$($UserProfile.SID)]. Failure message [$HiveLoadResult]. Continue... "
						}
						
						[boolean]$ManuallyLoadedRegHive = $true
					}
					Else {
						Throw "Failed to find the registry hive file [$UserRegistryHiveFile] for User [$($UserProfile.NTAccount)] with SID [$($UserProfile.SID)]. Continue... "
					}
				}
				Else {
					Write-Log -Message "The User [$($UserProfile.NTAccount)] registry hive is already loaded in path [HKEY_USERS\$($UserProfile.SID)] " -Source ${CmdletName}
				}
				
				
				
				
				Write-Log -Message ("{1}{16}{18}{15}{6}{0}{5}{7}{10}{4}{17}{13}{14}{2}{8}{11}{12}{9}{3}" -f'ify H','Execute Scr','r','.','registry ','K','mod','CU',' a','rs',' ','ll ','use','tt','ings fo','to ','iptBlo','se','ck ') -Source ${CmdletName}
				& $RegistrySettings
			}
			Catch {
				Write-Log -Message "Failed to modify the registry hive for User [$($UserProfile.NTAccount)] with SID [$($UserProfile.SID)] `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			}
			Finally {
				If ($ManuallyLoadedRegHive) {
					Try {
						Write-Log -Message "Unload the User [$($UserProfile.NTAccount)] registry hive in path [HKEY_USERS\$($UserProfile.SID)] " -Source ${CmdletName}
						[string]$HiveLoadResult = & reg.exe unload "`"HKEY_USERS\$($UserProfile.SID)`""
						
						If ($global:LastExitCode -ne 0) { Throw "$HiveLoadResult" }
					}
					Catch {
						Write-Log -Message "Failed to unload the registry hive for User [$($UserProfile.NTAccount)] with SID [$($UserProfile.SID)]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
					}
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function ConvertTo-NTAccountOrSID {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,ParameterSetName="NtAcc`O`UNTt`OSid",ValueFromPipelineByPropertyName=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$AccountName,
		[Parameter(Mandatory=$true,ParameterSetName="si`D`TOnta`ccount",ValueFromPipelineByPropertyName=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$SID,
		[Parameter(Mandatory=$true,ParameterSetName="WeLlknown`Na`mE",ValueFromPipelineByPropertyName=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$WellKnownSIDName,
		[Parameter(Mandatory=$false,ParameterSetName="WelLKN`OW`N`NAMe")]
		[ValidateNotNullOrEmpty()]
		[switch]$WellKnownToNTAccount
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Switch ($PSCmdlet.ParameterSetName) {
				("{0}{1}{2}" -f'SIDToNTA','cco','unt') {
					[string]$msg = ('the'+' '+'SID'+' '+"[$SID] "+'t'+'o '+'a'+'n '+'NT'+' '+'Ac'+'count'+' '+'n'+'ame')
					Write-Log -Message ('Con'+'vert '+"$msg.") -Source ${CmdletName}
					
					$NTAccountSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList $SID
					$NTAccount = $NTAccountSID.Translate([System.Security.Principal.NTAccount])
					Write-Output $NTAccount
				}
				("{0}{2}{1}{3}" -f'N','unt','TAcco','ToSID') {
					[string]$msg = ('th'+'e '+'NT'+' '+'A'+'cc'+'ount '+"[$AccountName] "+'to'+' '+'a '+'S'+'ID')
					Write-Log -Message ('Conve'+'rt '+"$msg.") -Source ${CmdletName}
					
					$NTAccount = New-Object -TypeName System.Security.Principal.NTAccount -ArgumentList $AccountName
					$NTAccountSID = $NTAccount.Translate([System.Security.Principal.SecurityIdentifier])
					Write-Output $NTAccountSID
				}
				("{1}{2}{0}{3}{4}" -f'Known','W','ell','Na','me') {
					If ($WellKnownToNTAccount) {
						[string]$ConversionType = ("{0}{1}"-f'NTAcc','ount')
					}
					Else {
						[string]$ConversionType = 'SID'
					}
					[string]$msg = ('the'+' '+'We'+'ll '+'K'+'nown '+'S'+'ID '+'Name'+' '+"[$WellKnownSIDName] "+'to'+' '+'a '+"$ConversionType")
					Write-Log -Message ('Convert'+' '+"$msg.") -Source ${CmdletName}
					
					
					Try {
						$MachineRootDomain = (Get-WmiObject -Class Win32_ComputerSystem -ErrorAction ("{0}{1}" -f'St','op')).Domain.ToLower()
						$ADDomainObj = New-Object -TypeName System.DirectoryServices.DirectoryEntry -ArgumentList "LDAP://$MachineRootDomain"
						$DomainSidInBinary = $ADDomainObj.ObjectSid
						$DomainSid = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList ($DomainSidInBinary[0], 0)
					}
					Catch {
						Write-Log -Message ('U'+'nable '+'t'+'o '+'g'+'et '+'D'+'omain '+'SI'+'D '+'f'+'rom '+'Act'+'ive'+' '+'D'+'irec'+'tory. '+'Se'+'tting '+'Do'+'ma'+'in '+'SI'+'D '+'t'+'o '+('v0Cn'+'u'+'ll.').rEpLaCE('v0C','$')) -Severity 2 -Source ${CmdletName}
						$DomainSid = $null
					}
					
					
					$WellKnownSidType = [Security.Principal.WellKnownSidType]::$WellKnownSIDName
					$NTAccountSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList ($WellKnownSidType, $DomainSid)
					
					If ($WellKnownToNTAccount) {
						$NTAccount = $NTAccountSID.Translate([System.Security.Principal.NTAccount])
						Write-Output $NTAccount
					}
					Else {
						Write-Output $NTAccountSID
					}
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to convert $msg. It may not be a valid account anymore or there is some other problem. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-UserProfiles {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string[]]$ExcludeNTAccount,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ExcludeSystemProfiles = $true,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$ExcludeDefaultUser = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ("{2}{20}{13}{14}{19}{11}{5}{4}{21}{16}{12}{25}{27}{9}{10}{7}{24}{15}{3}{1}{6}{0}{26}{18}{23}{17}{8}{22}" -f 'at lo','s t','Get','r',', an','ount SID','h','n',' ma','A','ccou','cc','he','r Pro','file ',' all use',' t','the','o','Path, User A',' the Use','d','chine.',' ','t Name for',' Us','g ont','er ') -Source ${CmdletName}
			
			
			[string]$UserProfileListRegKey = ((("{19}{10}{2}{18}{17}{1}{6}{15}{13}{14}{22}{9}{0}{3}{16}{4}{12}{5}{21}{20}{7}{11}{8}" -f'AREPaIMic','AL','try::','r','sof','ndows NTPaI','_M','io','fileList','TW','s','nPaIPro','tPaIWi','NE','P','ACHI','o','OC','HKEY_L','Regi','ntVers','Curre','aISOF'))  -ReplAce 'PaI',[CHAr]92)
			[psobject[]]$UserProfiles = Get-ChildItem -Path $UserProfileListRegKey -ErrorAction ("{1}{0}" -f'p','Sto') |
			ForEach-Object {
				Get-ItemProperty -LiteralPath $_.PSPath -ErrorAction ("{0}{1}" -f 'Sto','p') | Where-Object { ($_.ProfileImagePath) } |
				Select-Object @{ Label = ("{1}{2}{0}"-f'count','N','TAc'); Expression = { $(ConvertTo-NTAccountOrSID -SID $_.PSChildName).Value } }, @{ Label = 'SID'; Expression = { $_.PSChildName } }, @{ Label = ("{0}{3}{1}{2}" -f 'Prof','P','ath','ile'); Expression = { $_.ProfileImagePath } }
			}
			If ($ExcludeSystemProfiles) {
				[string[]]$SystemProfiles = ("{1}{2}{0}"-f '18','S-','1-5-'), ("{2}{0}{1}" -f'-','19','S-1-5'), ("{2}{0}{1}" -f'1-','5-20','S-')
				[psobject[]]$UserProfiles = $UserProfiles | Where-Object { $SystemProfiles -notcontains $_.SID }
			}
			If ($ExcludeNTAccount) {
				[psobject[]]$UserProfiles = $UserProfiles | Where-Object { $ExcludeNTAccount -notcontains $_.NTAccount }
			}
			
			
			If (-not $ExcludeDefaultUser) {
				[string]$UserProfilesDirectory = Get-ItemProperty -LiteralPath $UserProfileListRegKey -Name ProfilesDirectory -ErrorAction ("{0}{1}"-f'Sto','p') | Select-Object -ExpandProperty ProfilesDirectory

				
				If ([System.Environment]::OSVersion.Version.Major -gt 5) {
					
					[string]$DefaultUserProfileDirectory = Get-ItemProperty -LiteralPath $UserProfileListRegKey -Name ("{1}{0}" -f'efault','D') -ErrorAction ("{1}{0}" -f 'top','S') | Select-Object -ExpandProperty ("{0}{1}" -f 'De','fault')
				}
				
				Else {
					
					[string]$DefaultUserProfileName = Get-ItemProperty -LiteralPath $UserProfileListRegKey -Name ("{5}{1}{4}{0}{3}{2}" -f'Prof','ultUser','e','il','s','Defa') -ErrorAction ("{0}{1}" -f'S','top') | Select-Object -ExpandProperty ("{2}{1}{3}{0}"-f'e','au','Def','ltUsersProfil')
					
					
					[string]$DefaultUserProfileDirectory = Join-Path -Path $UserProfilesDirectory -ChildPath $DefaultUserProfileName
				}
				
				
				
				
				$DefaultUserProfile = New-Object -TypeName PSObject
				$DefaultUserProfile | Add-Member -MemberType NoteProperty -Name NTAccount -Value ("{1}{2}{3}{0}" -f'lt User','D','ef','au') -Force -ErrorAction ("{1}{0}"-f 'p','Sto')
				$DefaultUserProfile | Add-Member -MemberType NoteProperty -Name SID -Value ("{0}{5}{2}{1}{4}{3}"-f'S-1-5-','au','ef','ser','lt-U','21-D') -Force -ErrorAction ("{0}{1}"-f 'Sto','p')
				$DefaultUserProfile | Add-Member -MemberType NoteProperty -Name ProfilePath -Value $DefaultUserProfileDirectory -Force -ErrorAction ("{0}{1}" -f 'S','top')
				
				
				$UserProfiles += $DefaultUserProfile
			}
			
			Write-Output $UserProfiles
		}
		Catch {
			Write-Log -Message "Failed to create a custom object representing all user profiles on the machine. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-FileVersion {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$File,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ('Get'+' '+'f'+'ile '+'v'+'ersi'+'on '+'inf'+'o '+'f'+'or '+'fil'+'e '+"[$file]") -Source ${CmdletName}
			
			If (Test-Path -Path $File -PathType Leaf) {
				$fileVersion = (Get-Command -Name $file -ErrorAction ("{1}{0}"-f 'top','S')).FileVersionInfo.FileVersion
				If ($fileVersion) {
					
					$fileVersion = ($fileVersion -split ' ' | Select-Object -First 1)
					
					Write-Log -Message ('F'+'ile '+'ve'+'r'+'sion '+'i'+'s '+"[$fileVersion]") -Source ${CmdletName}
					Write-Output $fileVersion
				}
				Else {
					Write-Log -Message ("{8}{0}{3}{2}{4}{7}{1}{6}{5}" -f 'i','on','e ','l','v','tion found.',' informa','ersi','No f') -Source ${CmdletName}
				}
			}
			Else {
				Throw ('Fil'+'e '+'p'+'ath '+"[$file] "+'doe'+'s '+'no'+'t '+'exis'+'t.')
			}
		}
		Catch {
			Write-Log -Message "Failed to get file version info. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to get file version info: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function New-Shortcut {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$TargetPath,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Arguments,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$IconLocation,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$IconIndex,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Description,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$WorkingDirectory,
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{0}{1}" -f'N','ormal'},{"{1}{2}{0}" -f 'zed','Maxim','i'},{"{2}{1}{0}" -f'd','nimize','Mi'})]
		[string]$WindowStyle,
		[Parameter(Mandatory=$false)]
		[switch]$RunAsAdmin,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		If (-not $Shell) { [__comobject]$Shell = New-Object -ComObject WScript.Shell -ErrorAction ("{1}{0}" -f'top','S') }
	}
	Process {
		Try {
			Try {
				[System.IO.FileInfo]$Path = [System.IO.FileInfo]$Path
				[string]$PathDirectory = $Path.DirectoryName
				
				If (-not (Test-Path -Path $PathDirectory -PathType Container -ErrorAction ("{0}{1}"-f'Sto','p'))) {
					Write-Log -Message ('Cr'+'eate '+'sho'+'rtcu'+'t '+'dir'+'e'+'ctory '+"[$PathDirectory]") -Source ${CmdletName}
					New-Item -Path $PathDirectory -ItemType Directory -Force -ErrorAction ("{1}{0}" -f 'top','S') | Out-Null
				}
			}
			Catch {
				Write-Log -Message "Failed to create shortcut directory [$PathDirectory]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				Throw
			}
			
			Write-Log -Message "Create shortcut [$($path.FullName)] " -Source ${CmdletName}
			If (($path.FullName).EndsWith(("{0}{1}"-f '.','url'))) {
				[string[]]$URLFile = ("{0}{3}{2}{1}"-f '[Inter',']','hortcut','netS')
				$URLFile += "URL=$targetPath"
				If ($iconIndex) { $URLFile += "IconIndex=$iconIndex" }
				If ($IconLocation) { $URLFile += "IconFile=$iconLocation" }
				$URLFile | Out-File -FilePath $path.FullName -Force -Encoding default -ErrorAction ("{1}{0}"-f'op','St')
			}
			ElseIf (($path.FullName).EndsWith(("{1}{0}" -f 'nk','.l'))) {
				If (($iconLocation -and $iconIndex) -and (-not ($iconLocation.Contains(',')))) {
					$iconLocation = $iconLocation + ",$iconIndex"
				}
				Switch ($windowStyle) {
					("{1}{2}{0}" -f'l','N','orma') { $windowStyleInt = 1 }
					("{2}{0}{1}" -f 'xi','mized','Ma') { $windowStyleInt = 3 }
					("{1}{2}{0}"-f'd','Minimiz','e') { $windowStyleInt = 7 }
					Default { $windowStyleInt = 1 }
				}
				$shortcut = $shell.CreateShortcut($path.FullName)
				$shortcut.TargetPath = $targetPath
				$shortcut.Arguments = $arguments
				$shortcut.Description = $description
				$shortcut.WorkingDirectory = $workingDirectory
				$shortcut.WindowStyle = $windowStyleInt
				If ($iconLocation) { $shortcut.IconLocation = $iconLocation }
				$shortcut.Save()
				
				
				If ($RunAsAdmin) {
					Write-Log -Message ("{1}{0}{13}{9}{3}{10}{2}{8}{12}{6}{11}{4}{5}{7}" -f't sho','Se','ogram','un','i','strato','dm','r.',' as ','t to r',' pr','in','a','rtcu') -Source ${CmdletName}
					$TempFileName = [System.IO.Path]::GetRandomFileName()
					$TempFile = [System.IO.FileInfo][IO.Path]::Combine($Path.Directory, $TempFileName)
					$Writer = New-Object -TypeName System.IO.FileStream -ArgumentList ($TempFile, ([System.IO.FileMode]::Create)) -ErrorAction ("{1}{0}" -f 'top','S')
					$Reader = $Path.OpenRead()
					While ($Reader.Position -lt $Reader.Length) {
						$Byte = $Reader.ReadByte()
						If ($Reader.Position -eq 22) { $Byte = 34 }
						$Writer.WriteByte($Byte)
					}
					$Reader.Close()
					$Writer.Close()
					$Path.Delete()
					Rename-Item -Path $TempFile -NewName $Path.Name -Force -ErrorAction ("{0}{1}" -f'St','op') | Out-Null
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to create shortcut [$($path.FullName)]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to create shortcut [$($path.FullName)]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Execute-ProcessAsUser {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$UserName,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Parameters = '',
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{2}{0}{3}{1}" -f 'e','ailable','High','stAv'},{"{3}{2}{0}{4}{1}" -f 'tPr','ege','eas','L','ivil'})]
		[string]$RunLevel = ("{2}{4}{1}{3}{0}" -f 'le','vail','Highest','ab','A'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$Wait = $false,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If (Test-Path -Path ("{7}{5}{0}{2}{4}{1}{6}{3}"-f'e:execu','sAsUserExitCo','t','e','eProces','l','d','variab')) { Remove-Variable -Name executeProcessAsUserExitCode -Scope Global}
		$global:executeProcessAsUserExitCode = $null
		
		
		If (($RunLevel -eq ("{2}{1}{0}{3}{4}"-f 'he','ig','H','stAvai','lable')) -and (-not $IsAdmin)) {
			Write-Log -Message "The function [${CmdletName}] requires the toolkit to be running with Administrator privileges if the [-RunLevel] parameter is set to 'HighestAvailable'." -Severity 3 -Source ${CmdletName}
			If ($ContinueOnError) {
				Return
			}
			Else {
				[int32]$global:executeProcessAsUserExitCode = 1
				Exit
			}
		}
		
		
		[string]$schTaskName = "$appDeployToolkitName-ExecuteAsUser"
		
		
		If (-not (Test-Path -Path $dirAppDeployTemp -PathType Container)) {
			New-Item -Path $dirAppDeployTemp -ItemType Directory -Force -ErrorAction ("{1}{0}" -f 'p','Sto')
		}
		
		
		If (($Path -eq ("{2}{0}{1}"-f'hell.e','xe','PowerS')) -or ((Split-Path -Path $Path -Leaf) -eq ("{2}{0}{1}"-f 'hel','l.exe','PowerS'))) {
			[string]$executeProcessAsUserParametersVBS = ("{0}{1}{3}{2}"-f 'chr(3','4',' & ',')') + "`"$($Path)`"" + ("{1}{2}{3}{4}{0}"-f ' & ',' & ','c','hr(','34)') + '" ' + ($Parameters -replace '"', ("`" "+'& '+'c'+'hr(34)'+' '+'& '+"`"") -replace (' '+'& '+('chrcOe'+'(34cO'+'e) ').rEpLACe('cOe',[STRinG][ChAr]92)+'& '+('SL6n'+'HX').rEPlaCe('nHX',[StRINg][ChAr]36).rEPlaCe('SL6',[StRINg][ChAr]34)),'') + '"'
			[string[]]$executeProcessAsUserScript = ('strC'+'o'+'mmand '+'= '+"$executeProcessAsUserParametersVBS")
			$executeProcessAsUserScript += ((("{5}{8}{7}{4}{3}{2}{0}{1}{6}"-f 't(zTaWScri','pt.ShellzT','c','ll = CreateObje','he','se','a)',' oWS','t'))  -CreplAcE 'zTa',[ChAr]34)
			$executeProcessAsUserScript += ("{6}{3}{7}{0}{2}{4}{1}{5}{8}"-f 'hell','mand, 0','.Run(strC','urn = o','om',',','intRet','WS',' true)')
			$executeProcessAsUserScript += ("{3}{0}{2}{4}{5}{6}{1}" -f 'cri','n','p','WS','t.','Quit int','Retur')
			$executeProcessAsUserScript | Out-File -FilePath "$dirAppDeployTemp\$($schTaskName).vbs" -Force -Encoding default -ErrorAction ("{2}{3}{1}{0}"-f'inue','ont','Silently','C')
			$Path = ("{1}{0}{2}" -f'script.','w','exe')
			$Parameters = "`"$dirAppDeployTemp\$($schTaskName).vbs`""
		}
		
		
		[string]$xmlSchTask = (('{0}
<?x'+'m'+'l ')  -f [chAr]34+('version={'+'0}1.'+'0'+'{0} ') -F  [cHar]34+('enco'+'ding={0}U'+'T'+'F-'+'16{0'+'}?'+'>
'+'<'+'Task'+' ')-f[cHar]34+(('version=dwA1'+'.2'+'dwA ')  -REPLAce 'dwA',[char]34)+(('x'+'mlns=MC8ht'+'tp'+':'+'//schema'+'s.'+'mi'+'cros'+'of'+'t.co'+'m/window'+'s'+'/2004/'+'02/'+'mit/tas'+'k'+'MC'+'8>
 ') -RepLacE 'MC8',[cHar]34)+' '+'<'+'Re'+'g'+'istrati'+'o'+'nInfo '+'/'+'>
 '+' '+'<T'+'r'+'iggers '+'/>
'+' '+' '+'<Set'+'t'+'in'+'gs>
	'+'<Mu'+'l'+'tip'+'le'+'InstancesP'+'olicy>'+'StopExi'+'sti'+'ng</M'+'ult'+'ipl'+'eInstan'+'ces'+'P'+'oli'+'cy'+'>
'+'	'+'<Disa'+'llo'+'w'+'StartIf'+'OnB'+'atte'+'ri'+'e'+'s>false'+'</D'+'isallo'+'w'+'Sta'+'rt'+'IfOn'+'Ba'+'t'+'teri'+'es'+'>'+'
'+'	<St'+'o'+'pI'+'f'+'Going'+'O'+'n'+'Ba'+'t'+'t'+'e'+'rie'+'s'+'>f'+'als'+'e<'+'/St'+'opI'+'fGo'+'i'+'ngO'+'n'+'Batteries>'+'
	<Allow'+'HardTermina'+'te>'+'t'+'rue</'+'AllowHar'+'dTer'+'minate'+'>'+'
	<Start'+'WhenA'+'vailabl'+'e>'+'fa'+'ls'+'e</S'+'tartW'+'henAvailable>'+'
'+'	<R'+'un'+'OnlyIfNe'+'tworkA'+'vai'+'l'+'ab'+'le>fal'+'se<'+'/'+'RunOnlyI'+'fNetw'+'or'+'kAva'+'i'+'lable>
	'+'<IdleSet'+'tings'+' '+'/>
	<Al'+'l'+'o'+'w'+'Star'+'tOnDema'+'nd'+'>true</AllowS'+'ta'+'rtOn'+'Demand>
	<E'+'na'+'bled>t'+'r'+'u'+'e</Enabled>
'+'	<'+'H'+'id'+'den>false</Hidden'+'>
	<RunOnlyIfIdle'+'>f'+'alse'+'</RunOnlyIf'+'Idle>
	'+'<'+'WakeToRun>false</WakeTo'+'Run>
	<Ex'+'ecutionTimeLi'+'m'+'it>'+'PT72H</Exe'+'cutionTi'+'me'+'Limit'+'>
	<Pri'+'ority>7</Prio'+'r'+'i'+'ty'+'>'+'
 '+' '+'</'+'Settin'+'gs>'+'
 '+' '+'<Acti'+'ons '+('Cont'+'ext={0}A'+'utho'+'r{0}'+'>
	<'+'Exec>'+'
	'+' ')-f  [Char]34+' '+('<Co'+'mmand>{0}Path'+'</C'+'om'+'man'+'d>
	 ')-f[ChAr]36+' '+('<Arg'+'ument'+'s'+'>'+'{0}Par'+'ameter'+'s</Arg'+'um'+'ents>'+'
	</'+'Exec>
 ')  -F[CHAr]36+' '+'</A'+'ctions>
'+' '+' '+'<'+'P'+'ri'+'n'+'cipals>
	'+'<'+'Principa'+'l '+('i'+'d={0'+'}A'+'u'+'t'+'hor{0}'+'>
	 ')-f  [cHar]34+' '+(('<Us'+'er'+'I'+'d>q8'+'s'+'UserName<'+'/U'+'serId>
'+'	 ') -cREpLaCe'q8s',[char]36)+' '+'<Logo'+'nTyp'+'e>Inte'+'racti'+'ve'+'Token</Logo'+'nType'+'>
	 '+' '+(('<R'+'unLevel'+'>2IsR'+'unLevel</RunLevel>
'+'	<'+'/P'+'r'+'incipa'+'l>
 ')  -crEPlacE  ([cHaR]50+[cHaR]73+[cHaR]115),[cHaR]36)+' '+('</Princ'+'i'+'pals'+'>
</T'+'ask>
'+'{0'+'}') -F [CHAR]34)
		
		Try {
			
			[string]$xmlSchTaskFilePath = "$dirAppDeployTemp\$schTaskName.xml"
			[string]$xmlSchTask | Out-File -FilePath $xmlSchTaskFilePath -Force -ErrorAction Stop
		}
		Catch {
			Write-Log -Message "Failed to export the scheduled task XML file. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If ($ContinueOnError) {
				Return
			}
			Else {
				[int32]$global:executeProcessAsUserExitCode = $schTaskResult.ExitCode
				Exit
			}
		}
		
		
		Try {
			If ($Parameters) {
				Write-Log -Message ('Cre'+'a'+'te '+'sch'+'edu'+'led '+'ta'+'sk '+'to'+' '+'ru'+'n '+'the'+' '+'pr'+'oc'+'ess '+"[$Path "+"$Parameters] "+'a'+'s '+'t'+'he '+'logged-'+'o'+'n '+'u'+'ser '+"[$userName]...") -Source ${CmdletName}
			}
			Else {
				Write-Log -Message ('C'+'rea'+'te '+'sche'+'dul'+'ed '+'t'+'ask '+'to'+' '+'r'+'un '+'th'+'e '+'pro'+'cess '+"[$Path] "+'as'+' '+'the'+' '+'logged-'+'on'+' '+'user'+' '+"[$userName]...") -Source ${CmdletName}
			}
			
			[psobject]$schTaskResult = Execute-Process -Path $exeSchTasks -Parameters ('/'+'create '+'/f'+' '+'/t'+'n '+"$schTaskName "+'/'+'xml '+"`"$xmlSchTaskFilePath`"") -WindowStyle Hidden -CreateNoWindow -PassThru
			If ($schTaskResult.ExitCode -ne 0) {
				If ($ContinueOnError) {
					Return
				}
				Else {
					[int32]$global:executeProcessAsUserExitCode = $schTaskResult.ExitCode
					Exit
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to create scheduled task. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If ($ContinueOnError) {
				Return
			}
			Else {
				[int32]$global:executeProcessAsUserExitCode = $schTaskResult.ExitCode
				Exit
			}
		}
		
		
		Try {
			If ($Parameters) {
				Write-Log -Message ('Tr'+'ig'+'ger '+'e'+'xecutio'+'n '+'o'+'f '+'schedu'+'led'+' '+'task'+' '+'w'+'ith '+'comman'+'d '+"[$Path "+"$Parameters] "+'a'+'s '+'the'+' '+'logg'+'ed-'+'on'+' '+'user'+' '+"[$userName]...") -Source ${CmdletName}
			}
			Else {
				Write-Log -Message ('Tr'+'igge'+'r '+'execu'+'tio'+'n '+'of'+' '+'sched'+'ul'+'ed '+'task'+' '+'wit'+'h '+'comm'+'an'+'d '+"[$Path] "+'as'+' '+'t'+'he '+'l'+'o'+'gged-on '+'u'+'ser '+"[$userName]...") -Source ${CmdletName}
			}
			[psobject]$schTaskResult = Execute-Process -Path $exeSchTasks -Parameters ('/r'+'un '+'/i'+' '+'/'+'tn '+"$schTaskName") -WindowStyle Hidden -CreateNoWindow -Passthru
			If ($schTaskResult.ExitCode -ne 0) {
				If ($ContinueOnError) {
					Return
				}
				Else {
					[int32]$global:executeProcessAsUserExitCode = $schTaskResult.ExitCode
					Exit
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to trigger scheduled task. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			
			Write-Log -Message ("{9}{4}{7}{0}{5}{3}{6}{1}{8}{10}{2}"-f 'ed task','d ','.','ch','lete the',' whi',' di',' schedul','no','De','t to trigger') -Source ${CmdletName}
			Execute-Process -Path $exeSchTasks -Parameters ('/d'+'elete '+'/t'+'n '+"$schTaskName "+'/f') -WindowStyle Hidden -CreateNoWindow -ContinueOnError $true
			If ($ContinueOnError) {
				Return
			}
			Else {
				[int32]$global:executeProcessAsUserExitCode = $schTaskResult.ExitCode
				Exit
			}
		}
		
		
		If ($Wait) {
			Write-Log -Message ('W'+'aiti'+'ng '+'f'+'or '+'th'+'e '+'pro'+'cess '+'l'+'aunc'+'hed '+'b'+'y '+'the'+' '+'sc'+'hedule'+'d '+'t'+'ask '+"[$schTaskName] "+'to'+' '+'com'+'plet'+'e '+'e'+'xe'+'cution '+'(t'+'h'+'is '+'m'+'ay '+'t'+'ake '+'some'+' '+'tim'+'e).'+'..') -Source ${CmdletName}
			Start-Sleep -Seconds 1
			While ((($exeSchTasksResult = & $exeSchTasks /query /TN $schTaskName /V /FO CSV) | ConvertFrom-CSV | Select-Object -ExpandProperty ("{1}{0}" -f's','Statu') | Select-Object -First 1) -eq ("{1}{0}"-f 'ng','Runni')) {
				Start-Sleep -Seconds 5
			}
			
			[int32]$global:executeProcessAsUserExitCode = ($exeSchTasksResult = & $exeSchTasks /query /TN $schTaskName /V /FO CSV) | ConvertFrom-CSV | Select-Object -ExpandProperty ("{1}{3}{2}{0}"-f't','Last R','l','esu') | Select-Object -First 1
			Write-Log -Message ('E'+'xit '+'code'+' '+'fro'+'m '+'pr'+'ocess'+' '+'launc'+'he'+'d '+'b'+'y '+'sch'+'edul'+'ed'+' '+'ta'+'sk '+"[$global:executeProcessAsUserExitCode]") -Source ${CmdletName}
		}
		
		
		Try {
			Write-Log -Message ('D'+'ele'+'te '+'sc'+'hedule'+'d '+'tas'+'k '+"[$schTaskName].") -Source ${CmdletName}
			Execute-Process -Path $exeSchTasks -Parameters ('/d'+'elet'+'e '+'/t'+'n '+"$schTaskName "+'/f') -WindowStyle Hidden -CreateNoWindow -ErrorAction ("{0}{1}"-f'Sto','p')
		}
		Catch {
			Write-Log -Message "Failed to delete scheduled task [$schTaskName]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
		
		
		
		Exit
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Refresh-Desktop {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$refreshDesktopSource = @'
		private static readonly IntPtr HWND_BROADCAST = new IntPtr(0xffff);
		private const int WM_SETTINGCHANGE = 0x1a;
		private const int SMTO_ABORTIFHUNG = 0x0002;
		
		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
		static extern bool SendNotifyMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
		
		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
		private static extern IntPtr SendMessageTimeout(IntPtr hWnd, int Msg, IntPtr wParam, string lParam, int fuFlags, int uTimeout, IntPtr lpdwResult);
		
		[DllImport("shell32.dll", CharSet = CharSet.Auto, SetLastError = false)]
		private static extern int SHChangeNotify(int eventId, int flags, IntPtr item1, IntPtr item2);
		
		public static void Refresh()
		{
			// Update desktop icons
			SHChangeNotify(0x8000000, 0x1000, IntPtr.Zero, IntPtr.Zero);
			// Update environment variables
			SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, IntPtr.Zero, null, SMTO_ABORTIFHUNG, 100, IntPtr.Zero);
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{5}{1}{4}{2}{3}{0}" -f 'r','yWinAPI.E','p','lore','x','M')).Type) {
			Add-Type -MemberDefinition $refreshDesktopSource -Namespace MyWinAPI -Name Explorer -Language CSharp -IgnoreWarnings -ErrorAction ("{1}{0}" -f 'op','St')
		}
	}
	Process {
		Try {
			Write-Log -Message ("{11}{13}{2}{18}{4}{7}{16}{6}{1}{20}{14}{10}{5}{19}{12}{0}{15}{17}{9}{8}{3}"-f'iro','nd t','es','block',' th','r ','p a','e ','ess ','roc','Windows Explore','Re','v','fr',' ','nme','Deskto','nt p','h','en','he') -Source ${CmdletName}
			[MyWinAPI.Explorer]::Refresh()
		}
		Catch {
			Write-Log -Message "Failed to refresh the Desktop and the Windows Explorer environment process block. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to refresh the Desktop and the Windows Explorer environment process block: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Refresh-SessionEnvironmentVariables {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		[scriptblock]$GetEnvironmentVar = {
			Param (
				$Key,
				$Scope
			)
			[System.Environment]::GetEnvironmentVariable($Key, $Scope)
		}
	}
	Process {
		Try {
			Write-Log -Message ("{9}{11}{8}{5}{10}{1}{7}{12}{4}{2}{0}{6}{3}"-f 'o','nment va','P','ll session.','is ','en','werShe','riables','e ','R','viro','efresh th',' for th') -Source ${CmdletName}
			
			[string]$CurrentUserEnvironmentSID = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value
			[string]$MachineEnvironmentVars = ((("{16}{18}{9}{6}{17}{3}{12}{15}{2}{4}{5}{11}{0}{8}{14}{1}{7}{10}{13}" -f'0Y2Co','l0Y2Se','H','L_M','I','NE0Y2SY','HKEY','ssion Manager0Y2En','nt','::','vironme','STEM0Y2CurrentControlSet','A','nt','ro','C','R','_LOCA','egistry')).rEPlaCE(([chaR]48+[chaR]89+[chaR]50),'\'))
			[string]$UserEnvironmentVars = "Registry::HKEY_USERS\$CurrentUserEnvironmentSID\Environment"
			
			
			$MachineEnvironmentVars, $UserEnvironmentVars | Get-Item | Where-Object { $_ } | ForEach-Object { $envRegPath = $_.PSPath; $_ | Select-Object -ExpandProperty Property | ForEach-Object { Set-Item -Path "env:$($_)" -Value (Get-ItemProperty -Path $envRegPath -Name $_).$_ } }
			
			
			[string[]]$PathFolders = ("{2}{1}{0}" -f'e','in','Mach'), ("{1}{0}" -f 'er','Us') | ForEach-Object { (& $GetEnvironmentVar -Key ("{0}{1}"-f'PA','TH') -Scope $_) } | Where-Object { $_ } | ForEach-Object { $_.Trim(';') } | ForEach-Object { $_.Split(';') } | ForEach-Object { $_.Trim() } | ForEach-Object { $_.Trim('"') } | Select-Object -Unique
			$env:PATH = $PathFolders -join ';'
		}
		Catch {
			Write-Log -Message "Failed to refresh the environment variables for this PowerShell session. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to refresh the environment variables for this PowerShell session: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-ScheduledTask {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$TaskName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		If (-not $exeSchTasks) { [string]$exeSchTasks = "$env:WINDIR\system32\schtasks.exe" }
		[psobject[]]$ScheduledTasks = @()
	}
	Process {
		Try {
			Write-Log -Message ("{3}{6}{0}{1}{4}{5}{2}" -f 'u','le','sks','Retrieve Sc','d T','a','hed') -Source ${CmdletName}
			[string[]]$exeSchtasksResults = & $exeSchTasks /Query /V /FO CSV
			If ($global:LastExitCode -ne 0) { Throw ('Fail'+'ed'+' '+'t'+'o '+'ret'+'r'+'ieve '+'sche'+'d'+'uled '+'t'+'asks '+'usi'+'ng '+"[$exeSchTasks].") }
			[psobject[]]$SchtasksResults = $exeSchtasksResults | ConvertFrom-CSV -ErrorAction ("{0}{1}" -f 'S','top')
			
			If ($SchtasksResults) {
				ForEach ($SchtasksResult in $SchtasksResults) {
					If ($SchtasksResult.TaskName -match $TaskName) {
						$SchtasksResult  | Get-Member -MemberType Properties |
						ForEach -Begin { 
							[hashtable]$Task = @{}
						} -Process {
							
							($Task.($($_.Name).Replace(' ','').Replace(':',''))) = If ($_.Name -ne $SchtasksResult.($_.Name)) { $SchtasksResult.($_.Name) }
						} -End {
							
							If (($Task.Values | Select-Object -Unique | Measure-Object).Count) {
								$ScheduledTasks += New-Object -TypeName PSObject -Property $Task
							}
						}
					}
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to retrieve scheduled tasks. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to retrieve scheduled tasks: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-Output $ScheduledTasks
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Block-AppExecution {

	[CmdletBinding()]
	Param (
		
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string[]]$ProcessName
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) {
			Write-Log -Message "Bypassing Function [${CmdletName}] [Mode: $deployMode]" -Source ${CmdletName}
			Return
		}
		
		[string]$schTaskBlockedAppsName = $installName + ("{1}{0}{2}" -f'Bloc','_','kedApps')
		
		
		If (-not (Test-Path -Path $dirAppDeployTemp -PathType Container -ErrorAction ("{2}{1}{0}" -f 'ntinue','yCo','Silentl'))) {
			New-Item -Path $dirAppDeployTemp -ItemType Directory -ErrorAction ("{2}{4}{0}{1}{3}"-f 'lyCont','i','Si','nue','lent') | Out-Null
		}
		Copy-Item -Path "$scriptRoot\*.*" -Destination $dirAppDeployTemp -Exclude ("{2}{1}{0}"-f 'umbs.db','h','t') -Force -Recurse -ErrorAction ("{4}{3}{0}{2}{1}" -f'tlyCo','tinue','n','ilen','S')
		
		
		[string]$debuggerBlockMessageCmd = ("`"powershell.exe "+'-Ex'+'ecut'+'ionPol'+'icy'+' '+'Bypas'+'s'+' '+'-N'+'oProfil'+'e '+'-NoL'+'og'+'o '+'-Wind'+'owS'+'t'+'yle '+'Hidde'+'n '+'-Fil'+'e '+"`" "+'& '+'chr(34)'+' '+'& '+"`"$dirAppDeployTemp\$scriptFileName`" "+'& '+'ch'+'r('+'34) '+'& '+"`" "+'-'+'Sho'+'w'+'BlockedAppDi'+'a'+'lo'+'g '+'-Re'+'fe'+'rringAp'+'p'+'l'+'icati'+'on '+"`" "+'& '+'c'+'hr('+'34) '+'& '+"`"$installName`" "+'& '+'c'+'hr(34'+')')
		[string[]]$debuggerBlockScript = ('strCo'+'mmand'+' '+'= '+"$debuggerBlockMessageCmd")
		$debuggerBlockScript += ((("{6}{10}{4}{9}{1}{2}{8}{5}{11}{3}{7}{12}{0}" -f ')','reateObj','ec','.ShellC','ll ','WSc','set oW','p','t(Cpk','= C','She','ript','k')).RePLAcE(([ChAR]67+[ChAR]112+[ChAR]107),[StrINg][ChAR]34))
		$debuggerBlockScript += ("{2}{5}{1}{4}{3}{0}"-f 'alse','C','oWShell.Run','mand, 0, f','om',' str')
		$debuggerBlockScript | Out-File -FilePath "$dirAppDeployTemp\AppDeployToolkit_BlockAppExecutionMessage.vbs" -Force -Encoding default -ErrorAction ("{3}{1}{2}{4}{0}" -f'nue','ilen','tlyCo','S','nti')
		[string]$debuggerBlockValue = ('w'+'script.'+'exe '+"`"$dirAppDeployTemp\AppDeployToolkit_BlockAppExecutionMessage.vbs`"")
		
		
		Write-Log -Message ("{17}{14}{15}{16}{20}{5}{9}{1}{6}{7}{12}{4}{10}{3}{2}{18}{13}{0}{8}{11}{19}" -f'nstal','eanup','n c',' i','ati',' to c',' ','blocked a','lation is','l','ons',' in','pplic','e i','e','d ','tas','Create schedul','as','terrupted.','k') -Source ${CmdletName}
		If (Get-ScheduledTask -ContinueOnError $true | Select-Object -Property TaskName | Where-Object { $_.TaskName -eq "\$schTaskBlockedAppsName" }) {
			Write-Log -Message ('Sched'+'ul'+'ed '+'tas'+'k '+"[$schTaskBlockedAppsName] "+'a'+'l'+'ready '+'ex'+'i'+'sts.') -Source ${CmdletName}
		}
		Else {
			[string[]]$schTaskCreationBatchFile = ("{1}{0}{2}"-f 'O','@ECHO ','FF')
			$schTaskCreationBatchFile += ('powersh'+'e'+'ll.'+'exe '+'-'+'Execu'+'t'+'ion'+'Policy '+'By'+'pa'+'ss '+'-'+'No'+'Pr'+'ofile '+'-NoL'+'og'+'o '+'-W'+'ind'+'owStyle '+'H'+'idden'+' '+'-'+'File '+"`"$dirAppDeployTemp\$scriptFileName`" "+'-C'+'lean'+'upBlo'+'cke'+'dApps '+'-Re'+'ferri'+'n'+'gApp'+'licati'+'o'+'n '+"`"$installName`"")
			$schTaskCreationBatchFile | Out-File -FilePath "$dirAppDeployTemp\AppDeployToolkit_UnBlockApps.bat" -Force -Encoding default -ErrorAction ("{0}{1}{2}{3}{4}"-f'S','i','lentlyCont','i','nue')
			$schTaskCreation = Execute-Process -Path $exeSchTasks -Parameters ('/Cre'+'a'+'te '+'/'+'TN '+"$schTaskBlockedAppsName "+'/'+'RU '+"`"$LocalSystemNTAccount`" "+'/'+'SC '+'ONS'+'TART'+' '+'/T'+'R '+"`"$dirAppDeployTemp\AppDeployToolkit_UnBlockApps.bat`"") -PassThru
		}
		
		[string[]]$blockProcessName = $processName
		
		[string[]]$blockProcessName = $blockProcessName | ForEach-Object { $_ + ("{1}{0}"-f'exe','.') } -ErrorAction ("{2}{3}{1}{0}{4}"-f 't','yCon','Silen','tl','inue')
		
		
		ForEach ($blockProcess in $blockProcessName) {
			Write-Log -Message ('Set'+' '+'the'+' '+'Image'+' '+'Fi'+'le '+'E'+'xecu'+'ti'+'on '+'Op'+'tion'+' '+'regis'+'try '+'ke'+'y '+'to'+' '+'blo'+'ck '+'e'+'xecu'+'tion '+'o'+'f '+"[$blockProcess].") -Source ${CmdletName}
			Set-RegistryKey -Key (Join-Path -Path $regKeyAppExecution -ChildPath $blockProcess) -Name ("{0}{2}{1}"-f'Debug','r','ge') -Value $debuggerBlockValue -ContinueOnError $true
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Unblock-AppExecution {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) {
			Write-Log -Message "Bypassing Function [${CmdletName}] [Mode: $deployMode]" -Source ${CmdletName}
			Return
		}
		
		
		[psobject[]]$unblockProcesses = $null
		[psobject[]]$unblockProcesses += (Get-ChildItem -Path $regKeyAppExecution -Recurse -ErrorAction ("{0}{2}{4}{1}{3}"-f 'S','t','ilen','inue','tlyCon') | ForEach-Object { Get-ItemProperty -LiteralPath $_.PSPath -ErrorAction ("{0}{4}{1}{2}{3}" -f'Si','e','ntlyConti','nue','l')})
		ForEach ($unblockProcess in ($unblockProcesses | Where-Object { $_.Debugger -like ("{6}{5}{0}{4}{2}{1}{8}{7}{3}{9}"-f 't_B','E','ckApp','utio','lo','pDeployToolki','*Ap','ec','x','nMessage*') })) {
			Write-Log -Message "Remove the Image File Execution Options registry key to unblock execution of [$($unblockProcess.PSChildName)]. " -Source ${CmdletName} 
			$unblockProcess | Remove-ItemProperty -Name Debugger -ErrorAction ("{2}{3}{0}{1}"-f 'yCo','ntinue','Silen','tl')
		}
		
		
		If ($BlockExecution) {
			
			Set-Variable -Name BlockExecution -Value $false -Scope Script
		}
		
		
		[string]$schTaskBlockedAppsName = $installName + ("{1}{2}{0}" -f'kedApps','_Bl','oc')
		If (Get-ScheduledTask -ContinueOnError $true | Select-Object -Property TaskName | Where-Object { $_.TaskName -eq "\$schTaskBlockedAppsName" }) {
			Write-Log -Message ('Dele'+'te'+' '+'S'+'chedul'+'ed '+'Tas'+'k '+"[$schTaskBlockedAppsName].") -Source ${CmdletName}
			Execute-Process -Path $exeSchTasks -Parameters ('/'+'De'+'lete '+'/TN'+' '+"$schTaskBlockedAppsName "+'/F')
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-DeferHistory {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Write-Log -Message ("{3}{6}{0}{5}{4}{2}{1}" -f'ferral h','..','ry.','Get','sto','i',' de') -Source ${CmdletName}
		Get-RegistryKey -Key $regKeyDeferHistory -ContinueOnError $true
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-DeferHistory {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[string]$deferTimesRemaining,
		[Parameter(Mandatory=$false)]
		[string]$deferDeadline
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($deferTimesRemaining -and ($deferTimesRemaining -ge 0)) {
			Write-Log -Message ('Se'+'t '+'d'+'efer'+'ral '+'h'+'i'+'story: '+'[Def'+'er'+'TimesR'+'emai'+'ni'+'ng'+' '+'= '+"$deferTimes]") -Source ${CmdletName}
			Set-RegistryKey -Key $regKeyDeferHistory -Name ("{4}{3}{1}{5}{2}{0}" -f'g','Tim','n','fer','De','esRemaini') -Value $deferTimesRemaining -ContinueOnError $true
		}
		If ($deferDeadline) {
			Write-Log -Message ('Se'+'t '+'defe'+'rr'+'a'+'l '+'his'+'t'+'ory: '+'[D'+'eferDead'+'lin'+'e '+'= '+"$deferDeadline]") -Source ${CmdletName}
			Set-RegistryKey -Key $regKeyDeferHistory -Name ("{0}{2}{1}" -f 'D','line','eferDead') -Value $deferDeadline -ContinueOnError $true
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-UniversalDate {

	[CmdletBinding()]
	Param (
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$DateTime = ((Get-Date -Format ($culture).DateTimeFormat.FullDateTimePattern).ToString()),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		$ContinueOnError = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If ($DateTime -match 'Z$') { $DateTime = $DateTime -replace 'Z$', '' }
			[datetime]$DateTime = [datetime]::Parse($DateTime, $culture)
			
			
			Write-Log -Message "Convert the date [$DateTime] to a universal sortable date time pattern based on the current culture [$($culture.Name)] " -Source ${CmdletName}
			[string]$universalDateTime = (Get-Date -Date $DateTime -Format ($culture).DateTimeFormat.UniversalSortableDateTimePattern -ErrorAction ("{1}{0}" -f'op','St')).ToString()
			Write-Output $universalDateTime
		}
		Catch {
			Write-Log -Message "The specified date/time [$DateTime] is not in a format recognized by the current culture [$($culture.Name)]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "The specified date/time [$DateTime] is not in a format recognized by the current culture: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-RunningProcesses {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[psobject[]]$ProcessObjects
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($processObjects) {
			[string]$runningAppsCheck = ($processObjects | ForEach-Object { $_.ProcessName }) -join ','
			Write-Log -Message ('Check'+' '+'f'+'or '+'r'+'unning'+' '+'a'+'ppli'+'ca'+'tion(s'+') '+"[$runningAppsCheck]...") -Source ${CmdletName}
			
			
			
			[string]$processNames = ($processObjects | ForEach-Object { [regex]::Escape($_.ProcessName) }) -join '|'
			
			
			[System.Diagnostics.Process[]]$runningProcesses = Get-Process | Where-Object { $_.ProcessName -match $processNames }
			
			[array]$runningProcesses = $runningProcesses | ForEach-Object { $_ } | Select-Object -Property ProcessName, Description, ID
			If ($runningProcesses) {
				[string]$runningProcessList = ($runningProcesses | ForEach-Object { $_.ProcessName } | Select-Object -Unique) -join ','
				Write-Log -Message ('The'+' '+'fol'+'lowing'+' '+'p'+'r'+'ocesses '+'a'+'re '+'runni'+'ng: '+"[$runningProcessList]") -Source ${CmdletName}
				Write-Log -Message ("{0}{4}{2}{1}{5}{3}" -f'Resolve p','es','ocess d','...','r','criptions') -Source ${CmdletName}
				
				
				
				
				ForEach ($runningProcess in $runningProcesses) {
					ForEach ($processObject in $processObjects) {
						If ($runningProcess.ProcessName -eq ($processObject.ProcessName -replace ("{1}{0}"-f 'e','.ex'), '')) {
							If ($processObject.ProcessDescription) {
								$runningProcess | Add-Member -MemberType NoteProperty -Name Description -Value $processObject.ProcessDescription -Force -ErrorAction ("{2}{1}{0}{3}" -f 'Continu','ilently','S','e')
							}
						}
					}
					
					If (-not ($runningProcess.Description)) {
						$runningProcess | Add-Member -MemberType NoteProperty -Name Description -Value $runningProcess.ProcessName -Force -ErrorAction ("{0}{2}{3}{1}" -f'S','tinue','ilentlyC','on')
					}
				}
			}
			Else {
				Write-Log -Message ("{0}{6}{2}{1}{4}{7}{3}{5}" -f 'Ap','on','licati','runni','(','ng.','p','s) are not ') -Source ${CmdletName}
			}
			
			Write-Log -Message (("{9}{2}{8}{5}{3}{0}{1}{7}{6}{4}"-f 'ati','on','check','ing applic','.','runn',')','(s','ing ','Finished ')) -Source ${CmdletName}
			Write-Output $runningProcesses
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-InstallationWelcome {

	[CmdletBinding()]
	Param (
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$CloseApps,
		
		[Parameter(Mandatory=$false)]
		[switch]$Silent = $false,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$CloseAppsCountdown = 0,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$ForceCloseAppsCountdown = 0,
		
		[Parameter(Mandatory=$false)]
		[switch]$PersistPrompt = $false,
		
		[Parameter(Mandatory=$false)]
		[switch]$BlockExecution = $false,
		
		[Parameter(Mandatory=$false)]
		[switch]$AllowDefer = $false,
		
		[Parameter(Mandatory=$false)]
		[switch]$AllowDeferCloseApps = $false,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$DeferTimes = 0,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$DeferDays = 0,
		
		[Parameter(Mandatory=$false)]
		[string]$DeferDeadline = '',
		
		[Parameter(Mandatory=$false)]
		[switch]$CheckDiskSpace = $false,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$RequiredDiskSpace = 0,
		
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$MinimizeWindows = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) { $Silent = $true }
		
		
		If ($CheckDiskSpace) {
			Write-Log -Message ("{1}{4}{3}{5}{0}{2}" -f 'remen','E','ts.','aluate disk space req','v','ui') -Source ${CmdletName}
			[double]$freeDiskSpace = Get-FreeDiskSpace
			If ($RequiredDiskSpace -eq 0) {
				Try {
					
					$fso = New-Object -ComObject Scripting.FileSystemObject -ErrorAction ("{1}{0}" -f'p','Sto')
					$RequiredDiskSpace = [math]::Round((($fso.GetFolder($scriptParentPath).Size) / 1MB))
				}
				Catch {
					Write-Log -Message "Failed to calculate disk space requirement from source files. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				}
			}
			If ($freeDiskSpace -lt $RequiredDiskSpace) {
				Write-Log -Message ('Fai'+'l'+'ed '+'t'+'o '+'m'+'eet '+'min'+'imu'+'m '+'disk'+' '+'sp'+'a'+'ce '+'r'+'eq'+'uiremen'+'t. '+'S'+'pace'+' '+'R'+'equi'+'r'+'ed '+"[$RequiredDiskSpace "+'MB'+'], '+'S'+'pace '+'Ava'+'ilab'+'le '+"[$freeDiskSpace "+'M'+'B].') -Severity 3 -Source ${CmdletName}
				If (-not $Silent) {
					Show-InstallationPrompt -Message ($configDiskSpaceMessage -f $installTitle, $RequiredDiskSpace, ($freeDiskSpace)) -ButtonRightText 'OK' -Icon ("{0}{1}"-f 'Erro','r')
				}
				Exit-Script -ExitCode $configInstallationUIExitCode
			}
			Else {
				Write-Log -Message ("{0}{10}{4}{5}{2}{6}{1}{7}{11}{8}{9}{3}{12}"-f'Suc',' d',' mi','ement chec','essfu','lly passed','nimum','isk spa','equi','r','c','ce r','k.') -Source ${CmdletName}
			}
		}
		
		If ($CloseApps) {
			
			[psobject[]]$processObjects = @()
			
			ForEach ($process in ($CloseApps -split ',' | Where-Object { -not ([string]::IsNullOrEmpty($_)) })) {
				$process = $process -split '='
				$processObjects += New-Object -TypeName PSObject -Property @{
					ProcessName = $process[0]
					ProcessDescription = $process[1]
				}
			}
		}
		
		
		If (($allowDefer) -or ($AllowDeferCloseApps)) {
			
			$allowDefer = $true
			
			
			$deferHistory = Get-DeferHistory
			$deferHistoryTimes = $deferHistory | Select-Object -ExpandProperty DeferTimesRemaining -ErrorAction ("{0}{1}{3}{2}"-f 'S','il','ntlyContinue','e')
			$deferHistoryDeadline = $deferHistory | Select-Object -ExpandProperty DeferDeadline -ErrorAction ("{1}{2}{0}"-f 'tinue','Si','lentlyCon')
			
			
			$checkDeferDays = $false
			$checkDeferDeadline = $false
			If ($DeferDays -ne 0) { $checkDeferDays = $true }
			If ($DeferDeadline) { $checkDeferDeadline = $true }
			If ($DeferTimes -ne 0) {
				If ($deferHistoryTimes -ge 0) {
					Write-Log -Message "Defer history shows [$($deferHistory.DeferTimesRemaining)] deferrals remaining. " -Source ${CmdletName}
					$DeferTimes = $deferHistory.DeferTimesRemaining - 1
				}
				Else {
					$DeferTimes = $DeferTimes - 1
				}
				Write-Log -Message ('Us'+'er '+'ha'+'s '+"[$deferTimes] "+'deferra'+'l'+'s '+'re'+'mainin'+'g.') -Source ${CmdletName}
				If ($DeferTimes -lt 0) {
					Write-Log -Message ("{6}{3}{0}{5}{4}{2}{1}" -f'f','.','ired','e','xp','erral has e','D') -Source ${CmdletName}
					$AllowDefer = $false
				}
			}
			Else {
				[string]$DeferTimes = ''
			}
			If ($checkDeferDays -and $allowDefer) {
				If ($deferHistoryDeadline) {
					Write-Log -Message ('Defe'+'r '+'histo'+'ry '+'sh'+'ows '+'a '+'dead'+'li'+'ne '+'date'+' '+'of'+' '+"[$deferHistoryDeadline].") -Source ${CmdletName}
					[string]$deferDeadlineUniversal = Get-UniversalDate -DateTime $deferHistoryDeadline
				}
				Else {
					[string]$deferDeadlineUniversal = Get-UniversalDate -DateTime (Get-Date -Date ((Get-Date).AddDays($deferDays)) -Format ($culture).DateTimeFormat.FullDateTimePattern)
				}
				Write-Log -Message ('User'+' '+'ha'+'s '+'u'+'ntil '+"[$deferDeadlineUniversal] "+'befo'+'re '+'d'+'eferr'+'al '+'expire'+'s.') -Source ${CmdletName}
				If ((Get-UniversalDate) -gt $deferDeadlineUniversal) {
					Write-Log -Message ("{3}{1}{4}{2}{0}"-f 'pired.','efe','has ex','D','rral ') -Source ${CmdletName}
					$AllowDefer = $false
				}
			}
			If ($checkDeferDeadline -and $allowDefer) {
				
				Try {
					[string]$deferDeadlineUniversal = Get-UniversalDate -DateTime $deferDeadline -ErrorAction ("{1}{0}" -f 'op','St')
				}
				Catch {
					Write-Log -Message "Date is not in the correct format for the current culture. Type the date in the current locale format, such as 20/08/2014 (Europe) or 08/20/2014 (United States). If the script is intended for multiple cultures, specify the date in the universal sortable date/time format, e.g. '2013-08-22 11:51:52Z'. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
					Throw "Date is not in the correct format for the current culture. Type the date in the current locale format, such as 20/08/2014 (Europe) or 08/20/2014 (United States). If the script is intended for multiple cultures, specify the date in the universal sortable date/time format, e.g. '2013-08-22 11:51:52Z': $($_.Exception.Message) "
				}
				Write-Log -Message ('Us'+'er '+'has'+' '+'u'+'nti'+'l '+"[$deferDeadlineUniversal] "+'rema'+'i'+'ning.') -Source ${CmdletName}
				If ((Get-UniversalDate) -gt $deferDeadlineUniversal) {
					Write-Log -Message ("{0}{2}{1}{4}{3}" -f 'Deferral h','xpir','as e','d.','e') -Source ${CmdletName}
					$AllowDefer = $false
				}
			}
		}
		If (($deferTimes -lt 0) -and (-not ($deferDeadlineUniversal))) { $AllowDefer = $false }
		
		
		If (-not ($deployModeSilent) -and (-not ($silent))) {
			If ($forceCloseAppsCountdown -gt 0) {
				
				$closeAppsCountdown = $forceCloseAppsCountdown
				
				[boolean]$forceCloseAppsCountdown = $true
			}
			Set-Variable -Name closeAppsCountdownGlobal -Value $closeAppsCountdown -Scope Script
			While ((Get-RunningProcesses -ProcessObjects $processObjects | Select-Object -Property * -OutVariable RunningProcesses) -or (($promptResult -ne ("{1}{0}"-f 'r','Defe')) -and ($promptResult -ne ("{0}{1}"-f 'Clo','se')))) {
				[string]$runningProcessDescriptions = ($runningProcesses | Select-Object -ExpandProperty Description | Select-Object -Unique | Sort-Object) -join ','
				
				If ($allowDefer) {
					
					If ($AllowDeferCloseApps -and ($runningProcessDescriptions -eq '')) {
						Break
					}
					
					ElseIf (($promptResult -ne ("{1}{0}" -f'lose','C')) -or (($runningProcessDescriptions -ne '') -and ($promptResult -ne ("{1}{0}"-f'inue','Cont')))) {
						[string]$promptResult = Show-WelcomePrompt -ProcessDescriptions $runningProcessDescriptions -CloseAppsCountdown $closeAppsCountdownGlobal -ForceCloseAppsCountdown $forceCloseAppsCountdown -PersistPrompt $PersistPrompt -AllowDefer -DeferTimes $deferTimes -DeferDeadline $deferDeadlineUniversal -MinimizeWindows $minimizeWindows
					}
				}
				
				ElseIf ($runningProcessDescriptions -ne '') {
					[string]$promptResult = Show-WelcomePrompt -ProcessDescriptions $runningProcessDescriptions -CloseAppsCountdown $closeAppsCountdownGlobal -ForceCloseAppsCountdown $forceCloseAppsCountdown -PersistPrompt $PersistPrompt -MinimizeWindows $minimizeWindows
				}
				
				Else {
					Break
				}
				
				
				If ($promptResult -eq ("{2}{1}{0}" -f'ue','ntin','Co')) {
					Write-Log -Message ("{4}{2}{1}{6}{5}{3}{0}"-f 'nue...','r ','e','d to conti','Us','cte','sele') -Source ${CmdletName}
					Start-Sleep -Seconds 2
					
					
					If (-not ($runningProcesses)) { Break }
				}
				
				ElseIf ($promptResult -eq ("{1}{0}" -f'e','Clos')) {
					Write-Log -Message ("{4}{12}{10}{2}{11}{5}{8}{0}{3}{6}{7}{13}{1}{9}" -f 'n(','.',' the ap','s)','User selec','licat',' ','to clos','io','..','ed to force','p','t','e') -Source ${CmdletName}
					ForEach ($runningProcess in $runningProcesses) {
						Write-Log -Message "Stop process $($runningProcess.Name)... " -Source ${CmdletName}
						Stop-Process -Id ($runningProcess | Select-Object -ExpandProperty Id) -Force -ErrorAction ("{1}{0}{3}{4}{2}"-f 'ilent','S','ue','l','yContin')
					}
					Start-Sleep -Seconds 2
				}
				
				ElseIf ($promptResult -eq ("{1}{2}{0}"-f 't','Tim','eou')) {
					Write-Log -Message ("{1}{4}{6}{0}{7}{3}{8}{5}{2}"-f'cti','Insta','ut value.','or','llation not','e timeo',' a','oned bef','e th') -Source ${CmdletName}
					$BlockExecution = $false
					
					If (($deferTimes) -or ($deferDeadlineUniversal)) {
						Set-DeferHistory -DeferTimesRemaining $DeferTimes -DeferDeadline $deferDeadlineUniversal
					}
					
					If ($script:welcomeTimer) {
						Try {
							$script:welcomeTimer.Dispose()
							$script:welcomeTimer = $null
						}
						Catch { }
					}
					
					Exit-Script -ExitCode $configInstallationUIExitCode
				}
				
				ElseIf ($promptResult -eq ("{0}{1}" -f 'De','fer')) {
					Write-Log -Message ("{1}{0}{2}{5}{4}{3}" -f'stallation def','In','e','.','red by the user','r') -Source ${CmdletName}
					$BlockExecution = $false
					
					Set-DeferHistory -DeferTimesRemaining $DeferTimes -DeferDeadline $deferDeadlineUniversal
					
					Exit-Script -ExitCode $configInstallationDeferExitCode
				}
			}
		}
		
		
		If (($Silent -or $deployModeSilent) -and $CloseApps) {
			[array]$runningProcesses = $null
			[array]$runningProcesses = Get-RunningProcesses $processObjects
			If ($runningProcesses) {
				[string]$runningProcessDescriptions = ($runningProcesses | Select-Object -ExpandProperty Description | Select-Object -Unique | Sort-Object) -join ','
				Write-Log -Message "Force close application(s) [$($runningProcessDescriptions)] without prompting user. " -Source ${CmdletName}
				$runningProcesses | Stop-Process -Force -ErrorAction ("{2}{0}{1}{3}{4}"-f 'ntly','Contin','Sile','u','e')
				Start-Sleep -Seconds 2
			}
		}
		
		
		If (($processObjects | ForEach-Object { $_.ProcessName }) -match ("{1}{0}"-f'tes','no')) {
			[string]$notesPath = Get-Item -Path $regKeyLotusNotes -ErrorAction ("{4}{0}{1}{3}{2}" -f 'ilently','Conti','e','nu','S') | Get-ItemProperty | Select-Object -ExpandProperty Path
			
			If ($notesPath) {
				[string]$notesNSDExecutable = Join-Path -Path $notesPath -ChildPath ("{0}{1}{2}"-f'NSD','.','Exe')
				Try {
					If (Test-Path -Path $notesNSDExecutable -PathType Leaf -ErrorAction ("{0}{1}" -f'S','top')) {
						Write-Log -Message ('E'+'xec'+'ute '+"[$notesNSDExecutable] "+'wi'+'th '+'the'+' '+'-'+'kill'+' '+'a'+'rgument..'+'.') -Source ${CmdletName}
						[System.Diagnostics.Process]$notesNSDProcess = Start-Process -FilePath $notesNSDExecutable -ArgumentList ("{0}{1}"-f'-k','ill') -WindowStyle Hidden -PassThru -ErrorAction ("{1}{0}"-f 'op','St')
						
						If (-not ($notesNSDProcess.WaitForExit(10000))) {
							Write-Log -Message ("[$notesNSDExecutable] "+'did'+' '+'no'+'t '+'e'+'nd '+'in'+' '+'a '+'timely'+' '+'ma'+'nner.'+' '+'Force'+' '+'termi'+'nat'+'e'+' '+'p'+'rocess.') -Source ${CmdletName}
							Stop-Process -Name 'NSD' -Force -ErrorAction ("{0}{1}{2}" -f'Silent','lyCon','tinue')
						}
					}
				}
				Catch {
					Write-Log -Message "Failed to launch [$notesNSDExecutable]. `n$(Resolve-Error) " -Source ${CmdletName}
				}
				
				Write-Log -Message "[$notesNSDExecutable] returned exit code [$($notesNSDProcess.Exitcode)] " -Source ${CmdletName}
				
				
				Stop-Process -Name 'NSD' -Force -ErrorAction ("{0}{3}{1}{4}{2}"-f'Si','yCo','ue','lentl','ntin')
			}
			
			
			[string[]]$notesPathExes = Get-ChildItem -Path $notesPath -Filter ("{1}{0}"-f '.exe','*') -Recurse | Select-Object -ExpandProperty BaseName | Sort-Object
			
			If ($notesPathExes) {
				[array]$processesIgnoringNotesExceptions = Compare-Object -ReferenceObject ($processObjects | Select-Object -ExpandProperty ProcessName | Sort-Object) -DifferenceObject $notesPathExes -IncludeEqual | Where-Object { ($_.SideIndicator -eq '<=') -or ($_.InputObject -eq ("{1}{0}"-f'otes','n')) } | Select-Object -ExpandProperty InputObject
				[array]$processObjects = $processObjects | Where-Object { $processesIgnoringNotesExceptions -contains $_.ProcessName }
			}
		}
		
		
		If ($BlockExecution) {
			
			Set-Variable -Name BlockExecution -Value $BlockExecution -Scope Script
			Write-Log -Message ("{5}{7}{6}{8}{1}{2}{4}{3}{0}"-f'.',' paramete','r speci','ied','f','[-BlockExecut','o','i','n]') -Source ${CmdletName}
			Block-AppExecution -ProcessName ($processObjects | Select-Object -ExpandProperty ProcessName)
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-WelcomePrompt {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[string]$ProcessDescriptions,
		[Parameter(Mandatory=$false)]
		[int32]$CloseAppsCountdown,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ForceCloseAppsCountdown,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$PersistPrompt = $false,
		[Parameter(Mandatory=$false)]
		[switch]$AllowDefer = $false,
		[Parameter(Mandatory=$false)]
		[int32]$DeferTimes,
		[Parameter(Mandatory=$false)]
		[string]$DeferDeadline,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$MinimizeWindows = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If (-not $IsProcessUserInteractive) {
			[string]$promptResult = Invoke-PSCommandAsUser -PassThru -Command ([scriptblock]::Create(('Show-Wel'+'com'+'ePro'+'m'+'p'+'t '+'-'+'Pro'+'c'+'es'+'sDescriptions '+"'$ProcessDescriptions' "+'-Cl'+'oseA'+'pp'+'sCountdo'+'wn '+"$CloseAppsCountdown "+'-For'+'ceCl'+'oseAppsCount'+'dow'+'n '+"`$$ForceCloseAppsCountdown "+'-'+'PersistP'+'r'+'ompt '+"`$$PersistPrompt "+"-AllowDefer:`$$AllowDefer "+'-De'+'ferTime'+'s'+' '+"$DeferTimes "+'-Def'+'erDe'+'adlin'+'e '+"'$DeferDeadline' "+'-'+'Minimiz'+'eW'+'i'+'n'+'dows '+"`$$MinimizeWindows")))
			Return $promptResult
		}

		
		[boolean]$showCloseApps = $false
		[boolean]$showDefer = $false
		[boolean]$persistWindow = $false
		
		
		[datetime]$startTime = Get-Date
		[datetime]$countdownTime = $startTime
		
		
		If ($CloseAppsCountdown) {
			If ($CloseAppsCountdown -gt $configInstallationUITimeout) {
				Throw ("{18}{12}{30}{7}{36}{23}{9}{35}{17}{16}{32}{5}{10}{28}{4}{27}{22}{26}{33}{19}{39}{0}{14}{8}{3}{29}{25}{11}{6}{34}{21}{2}{1}{38}{24}{13}{31}{20}{15}{37}"-f' XML co','ialogs',' d','a','e longer than the ','m','stalla','licati','r','c','e','n','e close ap',' ','nfigu','eo','down ','nt','Th','ed in th','m','ion UI','imeout speci',' ','o','for i','f','t',' cannot b','tion ','p','ti','ti','i','t','ou','ons','ut.',' t','e')
			}
		}
		
		
		If ($processDescriptions) {
			Write-Log -Message ('Promp'+'t'+' '+'user'+' '+'t'+'o '+'clo'+'se'+' '+'a'+'pplica'+'tion'+'('+'s) '+"[$runningProcessDescriptions]...") -Source ${CmdletName}
			$showCloseApps = $true
		}
		If (($allowDefer) -and (($deferTimes -ge 0) -or ($deferDeadline))) {
			Write-Log -Message ("{2}{1}{5}{0}{4}{3}" -f' t','r has t','Use','er.','o def','he option') -Source ${CmdletName}
			$showDefer = $true
			If ($deferDeadline) {
				
				$deferDeadline = $deferDeadline -replace 'Z',''
				
				[string]$deferDeadline = (Get-Date -Date $deferDeadline).ToString()
			}
		}
		
		
		If ($showDefer) {
			If ($closeAppsCountdown -gt 0) {
				Write-Log -Message ('C'+'lose'+' '+'ap'+'pl'+'ications '+'co'+'u'+'ntdown '+'h'+'as '+"[$closeAppsCountdown] "+'s'+'econ'+'ds '+'rem'+'a'+'ining.') -Source ${CmdletName}
				$showCountdown = $true
			}
			If ($persistPrompt) { $persistWindow = $true }
		}
		
		
		If ($forceCloseAppsCountdown -eq $true) {
			Write-Log -Message ('Clos'+'e'+' '+'ap'+'p'+'lications '+'c'+'oun'+'tdown '+'has'+' '+"[$closeAppsCountdown] "+'s'+'econd'+'s '+'remain'+'in'+'g.') -Source ${CmdletName}
			$showCountdown = $true
		}
		
		[string[]]$processDescriptions = $processDescriptions.Split(',')
		[System.Windows.Forms.Application]::EnableVisualStyles()
		
		$formWelcome = New-Object -TypeName System.Windows.Forms.Form
		$pictureBanner = New-Object -TypeName System.Windows.Forms.PictureBox
		$labelAppName = New-Object -TypeName System.Windows.Forms.Label
		$labelCountdown = New-Object -TypeName System.Windows.Forms.Label
		$labelDefer = New-Object -TypeName System.Windows.Forms.Label
		$listBoxCloseApps = New-Object -TypeName System.Windows.Forms.ListBox
		$buttonContinue = New-Object -TypeName System.Windows.Forms.Button
		$buttonDefer = New-Object -TypeName System.Windows.Forms.Button
		$buttonCloseApps = New-Object -TypeName System.Windows.Forms.Button
		$buttonAbort = New-Object -TypeName System.Windows.Forms.Button
		$formWelcomeWindowState = New-Object -TypeName System.Windows.Forms.FormWindowState
		$flowLayoutPanel = New-Object -TypeName System.Windows.Forms.FlowLayoutPanel
		$panelButtons = New-Object -TypeName System.Windows.Forms.Panel
		
		
		[scriptblock]$Form_Cleanup_FormClosed = {
			Try {
				$labelAppName.remove_Click($handler_labelAppName_Click)
				$labelDefer.remove_Click($handler_labelDefer_Click)
				$buttonCloseApps.remove_Click($buttonCloseApps_OnClick)
				$buttonContinue.remove_Click($buttonContinue_OnClick)
				$buttonDefer.remove_Click($buttonDefer_OnClick)
				$buttonAbort.remove_Click($buttonAbort_OnClick)
				$script:welcomeTimer.remove_Tick($timer_Tick)
				$timerPersist.remove_Tick($timerPersist_Tick)
				$formWelcome.remove_Load($Form_StateCorrection_Load)
				$formWelcome.remove_FormClosed($Form_Cleanup_FormClosed)
			}
			Catch {
			}
		}
		
		[scriptblock]$Form_StateCorrection_Load = {
			
			$formWelcome.WindowState = ("{0}{1}{2}"-f 'N','orma','l')
			$formWelcome.AutoSize = $true
			$formWelcome.TopMost = $true
			$formWelcome.BringToFront()
			
			Set-Variable -Name formWelcomeStartPosition -Value $formWelcome.Location -Scope Script
			
			
			[datetime]$currentTime = Get-Date
			[datetime]$countdownTime = $startTime.AddSeconds($CloseAppsCountdown)
			$script:welcomeTimer.Start()
			
			
			[timespan]$remainingTime = $countdownTime.Subtract($currentTime)
			[string]$labelCountdownSeconds = [string]::Format('{0}:{1:d2}:{2:d2}', $remainingTime.Hours, $remainingTime.Minutes, $remainingTime.Seconds)
			$labelCountdown.Text = "$configClosePromptCountdownMessage`n$labelCountdownSeconds"
		}
		
		
		If (-not ($script:welcomeTimer)) {
			$script:welcomeTimer = New-Object -TypeName System.Windows.Forms.Timer
		}
		
		If ($showCountdown) {
			[scriptblock]$timer_Tick = {
				
				[datetime]$currentTime = Get-Date
				[datetime]$countdownTime = $startTime.AddSeconds($CloseAppsCountdown)
				[timespan]$remainingTime = $countdownTime.Subtract($currentTime)
				Set-Variable -Name closeAppsCountdownGlobal -Value $remainingTime.TotalSeconds -Scope Script
				
				
				If ($countdownTime -lt $currentTime) {
					Write-Log -Message (("{5}{12}{15}{6}{11}{2}{7}{0}{9}{10}{14}{4}{13}{8}{1}{3}"-f'n timer ','g application',') coun','(s).','psed. ','Close ap','ti','tdow','losin','ha','s e','on(s','p','Force c','la','lica')) -Source ${CmdletName}
					$buttonCloseApps.PerformClick()
				}
				Else {
					
					[string]$labelCountdownSeconds = [string]::Format('{0}:{1:d2}:{2:d2}', $remainingTime.Hours, $remainingTime.Minutes, $remainingTime.Seconds)
					$labelCountdown.Text = "$configClosePromptCountdownMessage`n$labelCountdownSeconds"
					[System.Windows.Forms.Application]::DoEvents()
				}
			}
		}
		Else {
			$script:welcomeTimer.Interval = ($configInstallationUITimeout * 1000)
			[scriptblock]$timer_Tick = { $buttonAbort.PerformClick() }
		}
		
		$script:welcomeTimer.add_Tick($timer_Tick)
		
		
		If ($persistWindow) {
			$timerPersist = New-Object -TypeName System.Windows.Forms.Timer
			$timerPersist.Interval = ($configInstallationPersistInterval * 1000)
			[scriptblock]$timerPersist_Tick = { Refresh-InstallationWelcome }
			$timerPersist.add_Tick($timerPersist_Tick)
			$timerPersist.Start()
		}
		
		
		$formWelcome.Controls.Add($pictureBanner)
		$formWelcome.Controls.Add($buttonAbort)
		
		
		
		$paddingNone = New-Object -TypeName System.Windows.Forms.Padding
		$paddingNone.Top = 0
		$paddingNone.Bottom = 0
		$paddingNone.Left = 0
		$paddingNone.Right = 0
		
		
		$labelPadding = ("{1}{3}{0}{2}"-f '20,','20','0',',0,')
		
		
		$buttonWidth = 110
		$buttonHeight = 23
		$buttonPadding = 50
		$buttonSize = New-Object -TypeName System.Drawing.Size
		$buttonSize.Width = $buttonWidth
		$buttonSize.Height = $buttonHeight
		$buttonPadding = New-Object -TypeName System.Windows.Forms.Padding
		$buttonPadding.Top = 0
		$buttonPadding.Bottom = 5
		$buttonPadding.Left = 50
		$buttonPadding.Right = 0
		
		
		$pictureBanner.DataBindings.DefaultDataSourceUpdateMode = 0
		$pictureBanner.ImageLocation = $appDeployLogoBanner
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 0
		$System_Drawing_Point.Y = 0
		$pictureBanner.Location = $System_Drawing_Point
		$pictureBanner.Name = ("{1}{2}{0}" -f 'r','pictureBa','nne')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 50
		$System_Drawing_Size.Width = 450
		$pictureBanner.Size = $System_Drawing_Size
		$pictureBanner.SizeMode = ("{0}{3}{2}{1}" -f'Ce','e','erImag','nt')
		$pictureBanner.Margin = $paddingNone
		$pictureBanner.TabIndex = 0
		$pictureBanner.TabStop = $false
		
		
		$labelAppName.DataBindings.DefaultDataSourceUpdateMode = 0
		$labelAppName.Name = ("{2}{0}{1}" -f 'el','AppName','lab')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		If (-not $showCloseApps) {
			$System_Drawing_Size.Height = 40
		}
		Else {
			$System_Drawing_Size.Height = 65
		}
		$System_Drawing_Size.Width = 450
		$labelAppName.Size = $System_Drawing_Size
		$System_Drawing_Size.Height = 0
		$labelAppName.MaximumSize = $System_Drawing_Size
		$labelAppName.Margin = ("{2}{1}{0}"-f'0,15','5,','0,1')
		$labelAppName.Padding = $labelPadding
		$labelAppName.TabIndex = 1
		
		
		If ($showCloseApps) {
			$labelAppNameText = $configClosePromptMessage
		}
		ElseIf ($showDefer) {
			$labelAppNameText = ("$configDeferPromptWelcomeMessage "+"`n$installTitle")
		}
		$labelAppName.Text = $labelAppNameText
		$labelAppName.TextAlign = ("{0}{2}{1}" -f'To','Center','p')
		$labelAppName.Anchor = 'Top'
		$labelAppName.AutoSize = $true
		$labelAppName.add_Click($handler_labelAppName_Click)
		
		
		$listBoxCloseApps.DataBindings.DefaultDataSourceUpdateMode = 0
		$listBoxCloseApps.FormattingEnabled = $true
		$listBoxCloseApps.Name = ("{3}{1}{4}{0}{2}"-f'pp','s','s','li','tBoxCloseA')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 100
		$System_Drawing_Size.Width = 300
		$listBoxCloseApps.Size = $System_Drawing_Size
		$listBoxCloseApps.Margin = ("{1}{0}{2}" -f'5,0,','7','0,0')
		$listBoxCloseApps.TabIndex = 3
		ForEach ($processDescription in $ProcessDescriptions) {
			$listboxCloseApps.Items.Add($processDescription) | Out-Null
		}
		
		
		$labelDefer.DataBindings.DefaultDataSourceUpdateMode = 0
		$labelDefer.Name = ("{1}{0}{2}" -f 'lDefe','labe','r')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 90
		$System_Drawing_Size.Width = 450
		$labelDefer.Size = $System_Drawing_Size
		$System_Drawing_Size.Height = 0
		$labelDefer.MaximumSize = $System_Drawing_Size
		$labelDefer.Margin = $paddingNone
		$labelDefer.Padding = $labelPadding
		$labelDefer.TabIndex = 4
		$deferralText = "$configDeferPromptExpiryMessage`n"
		If ($deferTimes -ge 0) {
			$deferralText = ("$deferralText `n$configDeferPromptRemainingDeferrals $($deferTimes + 1) ")
		}
		If ($deferDeadline) {
			$deferralText = ("$deferralText "+"`n$configDeferPromptDeadline "+"$deferDeadline")
		}
		If (($deferTimes -lt 0) -and (-not $DeferDeadline)) {
			$deferralText = ("$deferralText "+"`n$configDeferPromptNoDeadline")
		}
		$deferralText = ("$deferralText "+"`n`n$configDeferPromptWarningMessage")
		$labelDefer.Text = $deferralText
		$labelDefer.TextAlign = ("{1}{0}{2}" -f't','MiddleCen','er')
		$labelDefer.AutoSize = $true
		$labelDefer.add_Click($handler_labelDefer_Click)
		
		
		$labelCountdown.DataBindings.DefaultDataSourceUpdateMode = 0
		$labelCountdown.Name = ("{1}{4}{0}{2}{3}" -f'elC','l','ountd','own','ab')
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 40
		$System_Drawing_Size.Width = 450
		$labelCountdown.Size = $System_Drawing_Size
		$System_Drawing_Size.Height = 0
		$labelCountdown.MaximumSize = $System_Drawing_Size
		$labelCountdown.Margin = $paddingNone
		$labelCountdown.Padding = $labelPadding
		$labelCountdown.TabIndex = 4
		$labelCountdown.Font = ("{4}{7}{1}{10}{6}{5}{3}{2}{9}{8}{0}"-f'Bold','soft S',' 9pt, s','f,','Micr','i',' Ser','o','e=','tyl','ans')
		$labelCountdown.Text = ("{1}{2}{0}"-f ':00','00:0','0')
		$labelCountdown.TextAlign = ("{1}{0}{2}" -f 'iddleCent','M','er')
		$labelCountdown.AutoSize = $true
		$labelCountdown.add_Click($handler_labelDefer_Click)
		
		
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 0
		$System_Drawing_Point.Y = 50
		$flowLayoutPanel.Location = $System_Drawing_Point
		$flowLayoutPanel.AutoSize = $true
		$flowLayoutPanel.Anchor = 'Top'
		$flowLayoutPanel.FlowDirection = ("{0}{1}" -f'Top','Down')
		$flowLayoutPanel.WrapContents = $true
		$flowLayoutPanel.Controls.Add($labelAppName)
		If ($showCloseApps) { $flowLayoutPanel.Controls.Add($listBoxCloseApps) }
		If ($showDefer) {
			$flowLayoutPanel.Controls.Add($labelDefer)
		}
		If ($showCloseApps -and $showCountdown) {
			$flowLayoutPanel.Controls.Add($labelCountdown)
		}
		
		
		$buttonCloseApps.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonCloseApps.Location = ("{0}{1}"-f'15,','0')
		$buttonCloseApps.Name = ("{2}{3}{0}{1}{4}"-f 'ttonC','loseA','b','u','pps')
		$buttonCloseApps.Size = $buttonSize
		$buttonCloseApps.TabIndex = 5
		$buttonCloseApps.Text = $configClosePromptButtonClose
		$buttonCloseApps.DialogResult = 'Yes'
		$buttonCloseApps.AutoSize = $true
		$buttonCloseApps.UseVisualStyleBackColor = $true
		$buttonCloseApps.add_Click($buttonCloseApps_OnClick)
		
		
		$buttonDefer.DataBindings.DefaultDataSourceUpdateMode = 0
		If (-not $showCloseApps) {
			$buttonDefer.Location = ("{0}{1}"-f '15,','0')
		}
		Else {
			$buttonDefer.Location = ("{1}{0}" -f'0,0','17')
		}
		$buttonDefer.Name = ("{1}{2}{0}"-f'efer','button','D')
		$buttonDefer.Size = $buttonSize
		$buttonDefer.TabIndex = 6
		$buttonDefer.Text = $configClosePromptButtonDefer
		$buttonDefer.DialogResult = 'No'
		$buttonDefer.AutoSize = $true
		$buttonDefer.UseVisualStyleBackColor = $true
		$buttonDefer.add_Click($buttonDefer_OnClick)
		
		
		$buttonContinue.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonContinue.Location = ("{1}{0}" -f'25,0','3')
		$buttonContinue.Name = ("{3}{0}{1}{2}" -f'ont','inu','e','buttonC')
		$buttonContinue.Size = $buttonSize
		$buttonContinue.TabIndex = 7
		$buttonContinue.Text = $configClosePromptButtonContinue
		$buttonContinue.DialogResult = 'OK'
		$buttonContinue.AutoSize = $true
		$buttonContinue.UseVisualStyleBackColor = $true
		$buttonContinue.add_Click($buttonContinue_OnClick)
		
		
		$buttonAbort.DataBindings.DefaultDataSourceUpdateMode = 0
		$buttonAbort.Name = ("{0}{2}{3}{1}" -f'b','Abort','utt','on')
		$buttonAbort.Size = '1,1'
		$buttonAbort.DialogResult = ("{1}{0}"-f 'ort','Ab')
		$buttonAbort.TabIndex = 5
		$buttonAbort.UseVisualStyleBackColor = $true
		$buttonAbort.add_Click($buttonAbort_OnClick)
		
		
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 0
		$System_Drawing_Size.Width = 0
		$formWelcome.Size = $System_Drawing_Size
		$formWelcome.Padding = $paddingNone
		$formWelcome.Margin = $paddingNone
		$formWelcome.DataBindings.DefaultDataSourceUpdateMode = 0
		$formWelcome.Name = ("{3}{2}{0}{1}" -f 'eFor','m','lcom','We')
		$formWelcome.Text = $installTitle
		$formWelcome.StartPosition = ("{3}{2}{0}{1}" -f 'e','n','nterScre','Ce')
		$formWelcome.FormBorderStyle = ("{2}{1}{0}" -f 'log','ia','FixedD')
		$formWelcome.MaximizeBox = $false
		$formWelcome.MinimizeBox = $false
		$formWelcome.TopMost = $true
		$formWelcome.TopLevel = $true
		$formWelcome.Icon = New-Object -TypeName System.Drawing.Icon -ArgumentList $AppDeployLogoIcon
		$formWelcome.AutoSize = $true
		$formWelcome.Controls.Add($pictureBanner)
		$formWelcome.Controls.Add($flowLayoutPanel)
		
		
		$System_Drawing_Point = New-Object -TypeName System.Drawing.Point
		$System_Drawing_Point.X = 0
		
		$System_Drawing_Point.Y = (($formWelcome.Size | Select-Object -ExpandProperty Height) - 10)
		$panelButtons.Location = $System_Drawing_Point
		$System_Drawing_Size = New-Object -TypeName System.Drawing.Size
		$System_Drawing_Size.Height = 40
		$System_Drawing_Size.Width = 450
		$panelButtons.Size = $System_Drawing_Size
		$panelButtons.AutoSize = $true
		$panelButtons.Anchor = 'Top'
		$padding = New-Object -TypeName System.Windows.Forms.Padding
		$padding.Top = 0
		$padding.Bottom = 0
		$padding.Left = 0
		$padding.Right = 0
		$panelButtons.Margin = $padding
		If ($showCloseApps) { $panelButtons.Controls.Add($buttonCloseApps) }
		If ($showDefer) { $panelButtons.Controls.Add($buttonDefer) }
		$panelButtons.Controls.Add($buttonContinue)
		
		
		$formWelcome.Controls.Add($panelButtons)
		
		
		$formWelcomeWindowState = $formWelcome.WindowState
		
		$formWelcome.add_Load($Form_StateCorrection_Load)
		
		$formWelcome.add_FormClosed($Form_Cleanup_FormClosed)
		
		Function Refresh-InstallationWelcome {
			$formWelcome.BringToFront()
			$formWelcome.Location = "$($formWelcomeStartPosition.X),$($formWelcomeStartPosition.Y)"
			$formWelcome.Refresh()
		}
		
		
		If ($minimizeWindows) { $shellApp.MinimizeAll() | Out-Null }
		
		
		$result = $formWelcome.ShowDialog()
		$formWelcome.Dispose()
		Switch ($result) {
			OK { $result = ("{2}{1}{0}"-f'nue','i','Cont') }
			No { $result = ("{0}{1}" -f 'De','fer'); $shellApp.UndoMinimizeAll() | Out-Null }
			Yes { $result = ("{1}{0}"-f 'ose','Cl')}
			Abort { $result = ("{0}{2}{1}" -f'T','meout','i'); $shellApp.UndoMinimizeAll() | Out-Null }
		}
		
		Write-Output $result
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-InstallationRestartPrompt {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$CountdownSeconds = 60,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[int32]$CountdownNoHideSeconds = 30,
		[Parameter(Mandatory=$false)]
		[switch]$NoCountdown = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If ($deployModeNonInteractive) {
			Write-Log -Message ('Bypas'+'s'+' '+'I'+'nstallatio'+'n '+'Re'+'start '+'Pro'+'m'+'pt '+'[Mode'+': '+"$deployMode]") -Source ${CmdletName}
			Return
		}

		
		If (-not $IsProcessUserInteractive) {
			Invoke-PSCommandAsUser -Command ([scriptblock]::Create(('Show-In'+'s'+'tal'+'la'+'t'+'ionResta'+'rtP'+'rompt '+'-Co'+'untdo'+'wn'+'S'+'econds '+"$CountdownSeconds "+'-Coun'+'t'+'do'+'wn'+'NoHideSec'+'o'+'nds '+"$CountdownNoHideSeconds "+"-NoCountdown:`$$NoCountdown")))
			Return
		}

		
		[hashtable]$installRestartPromptParameters = $psBoundParameters
		
		
		If (Get-Process | Where-Object { $_.MainWindowTitle -match $configRestartPromptTitle }) {
			Write-Log -Message "${CmdletName} was invoked, but an existing restart prompt was detected. Canceling restart prompt." -Severity 2 -Source ${CmdletName}
			Return
		}
		
		[datetime]$startTime = Get-Date
		[datetime]$countdownTime = $startTime
		
		[System.Windows.Forms.Application]::EnableVisualStyles()
		$formRestart = New-Object -TypeName System.Windows.Forms.Form
		$labelCountdown = New-Object -TypeName System.Windows.Forms.Label
		$labelTimeRemaining = New-Object -TypeName System.Windows.Forms.Label
		$labelMessage = New-Object -TypeName System.Windows.Forms.Label
		$buttonRestartLater = New-Object -TypeName System.Windows.Forms.Button
		$picturebox = New-Object -TypeName System.Windows.Forms.PictureBox
		$buttonRestartNow = New-Object -TypeName System.Windows.Forms.Button
		$timerCountdown = New-Object -TypeName System.Windows.Forms.Timer
		$InitialFormWindowState = New-Object -TypeName System.Windows.Forms.FormWindowState
		
		Function Perform-Restart {
			Write-Log -Message ("{1}{4}{7}{5}{8}{6}{0}{3}{2}" -f'art the compu','F','r...','te','or','e re','t','c','s') -Source ${CmdletName}
			Restart-Computer -Force
		}
		
		[scriptblock]$FormEvent_Load = {
			
			[datetime]$currentTime = Get-Date
			[datetime]$countdownTime = $startTime.AddSeconds($countdownSeconds)
			$timerCountdown.Start()
			
			[timespan]$remainingTime = $countdownTime.Subtract($currentTime)
			$labelCountdown.Text = [string]::Format('{0}:{1:d2}:{2:d2}', $remainingTime.Hours, $remainingTime.Minutes, $remainingTime.Seconds)
			If ($remainingTime.TotalSeconds -le $countdownNoHideSeconds) { $buttonRestartLater.Enabled = $false }
			$formRestart.WindowState = ("{1}{0}" -f 'ormal','N')
			$formRestart.TopMost = $true
			$formRestart.BringToFront()
		}
		
		[scriptblock]$Form_StateCorrection_Load = {
			
			$formRestart.WindowState = $InitialFormWindowState
			$formRestart.AutoSize = $true
			$formRestart.TopMost = $true
			$formRestart.BringToFront()
			
			Set-Variable -Name formInstallationRestartPromptStartPosition -Value $formRestart.Location -Scope Script
		}
		
		
		If ($NoCountdown) {
			$timerPersist = New-Object -TypeName System.Windows.Forms.Timer
			$timerPersist.Interval = ($configInstallationRestartPersistInterval * 1000)
			[scriptblock]$timerPersist_Tick = {
				
				$formRestart.WindowState = ("{0}{2}{1}"-f 'Nor','l','ma')
				$formRestart.TopMost = $true
				$formRestart.BringToFront()
				$formRestart.Location = "$($formInstallationRestartPromptStartPosition.X),$($formInstallationRestartPromptStartPosition.Y)"
				$formRestart.Refresh()
				[System.Windows.Forms.Application]::DoEvents()
			}
			$timerPersist.add_Tick($timerPersist_Tick)
			$timerPersist.Start()
		}
		
		[scriptblock]$buttonRestartLater_Click = {
			
			$formRestart.WindowState = ("{0}{2}{1}" -f 'Min','d','imize')
			
			$timerPersist.Stop()
			$timerPersist.Start()
		}
		
		
		[scriptblock]$buttonRestartNow_Click = { Perform-Restart }
		
		
		[scriptblock]$formRestart_Resize = { If ($formRestart.WindowState -eq ("{2}{0}{1}"-f 'e','d','Minimiz')) { $formRestart.WindowState = ("{2}{1}{0}"-f'ized','im','Min') } }
		
		[scriptblock]$timerCountdown_Tick = {
			
			[datetime]$currentTime = Get-Date
			[datetime]$countdownTime = $startTime.AddSeconds($countdownSeconds)
			[timespan]$remainingTime = $countdownTime.Subtract($currentTime)
			
			If ($countdownTime -lt $currentTime) {
				$buttonRestartNow.PerformClick()
			}
			Else {
				
				$labelCountdown.Text = [string]::Format('{0}:{1:d2}:{2:d2}', $remainingTime.Hours, $remainingTime.Minutes, $remainingTime.Seconds)
				If ($remainingTime.TotalSeconds -le $countdownNoHideSeconds) {
					$buttonRestartLater.Enabled = $false
					
					If ($formRestart.WindowState -eq ("{1}{0}{2}" -f'i','M','nimized')) {
						
						$formRestart.WindowState = ("{0}{1}" -f'N','ormal')
						$formRestart.TopMost = $true
						$formRestart.BringToFront()
						$formRestart.Location = "$($formInstallationRestartPromptStartPosition.X),$($formInstallationRestartPromptStartPosition.Y)"
						$formRestart.Refresh()
						[System.Windows.Forms.Application]::DoEvents()
					}
				}
				[System.Windows.Forms.Application]::DoEvents()
			}
		}
		
		
		[scriptblock]$Form_Cleanup_FormClosed = {
			Try {
				$buttonRestartLater.remove_Click($buttonRestartLater_Click)
				$buttonRestartNow.remove_Click($buttonRestartNow_Click)
				$formRestart.remove_Load($FormEvent_Load)
				$formRestart.remove_Resize($formRestart_Resize)
				$timerCountdown.remove_Tick($timerCountdown_Tick)
				$timerPersist.remove_Tick($timerPersist_Tick)
				$formRestart.remove_Load($Form_StateCorrection_Load)
				$formRestart.remove_FormClosed($Form_Cleanup_FormClosed)
			}
			Catch {
			}
		}
		
		
		If (-not $NoCountdown) {
			$formRestart.Controls.Add($labelCountdown)
			$formRestart.Controls.Add($labelTimeRemaining)
		}
		$formRestart.Controls.Add($labelMessage)
		$formRestart.Controls.Add($buttonRestartLater)
		$formRestart.Controls.Add($picturebox)
		$formRestart.Controls.Add($buttonRestartNow)
		$formRestart.ClientSize = ("{0}{1}"-f'4','50,260')
		$formRestart.ControlBox = $false
		$formRestart.FormBorderStyle = ("{3}{0}{2}{1}"-f'xedD','og','ial','Fi')
		$formRestart.Icon = New-Object -TypeName System.Drawing.Icon -ArgumentList $AppDeployLogoIcon
		$formRestart.MaximizeBox = $false
		$formRestart.MinimizeBox = $false
		$formRestart.Name = ("{3}{0}{2}{1}" -f'mRes','rt','ta','for')
		$formRestart.StartPosition = ("{2}{0}{1}{3}" -f'nterS','cree','Ce','n')
		$formRestart.Text = "$($configRestartPromptTitle): $installTitle "
		$formRestart.add_Load($FormEvent_Load)
		$formRestart.add_Resize($formRestart_Resize)
		
		
		$picturebox.Anchor = 'Top'
		$picturebox.Image = [System.Drawing.Image]::Fromfile($AppDeployLogoBanner)
		$picturebox.Location = '0,0'
		$picturebox.Name = ("{2}{0}{1}"-f'tureb','ox','pic')
		$picturebox.Size = ("{1}{2}{0}" -f'0','45','0,5')
		$picturebox.SizeMode = ("{2}{1}{0}" -f'ge','a','CenterIm')
		$picturebox.TabIndex = 1
		$picturebox.TabStop = $false
		
		
		$labelMessage.Location = ("{1}{0}" -f '8','20,5')
		$labelMessage.Name = ("{2}{1}{0}"-f'age','abelMess','l')
		$labelMessage.Size = ("{1}{0}" -f'0,79','40')
		$labelMessage.TabIndex = 3
		$labelMessage.Text = ("$configRestartPromptMessage "+"$configRestartPromptMessageTime "+"`n`n$configRestartPromptMessageRestart")
		If ($NoCountdown) { $labelMessage.Text = $configRestartPromptMessage }
		$labelMessage.TextAlign = ("{0}{2}{1}" -f 'MiddleC','ter','en')
		
		
		$labelTimeRemaining.Location = ("{1}{0}{2}" -f ',13','20','8')
		$labelTimeRemaining.Name = ("{0}{4}{1}{5}{3}{2}" -f'labe','Ti','ng','emaini','l','meR')
		$labelTimeRemaining.Size = ("{1}{0}"-f'00,23','4')
		$labelTimeRemaining.TabIndex = 4
		$labelTimeRemaining.Text = $configRestartPromptTimeRemaining
		$labelTimeRemaining.TextAlign = ("{2}{1}{0}{3}"-f 'Cent','le','Midd','er')
		
		
		$labelCountdown.Font = ("{5}{0}{4}{3}{7}{6}{1}{8}{2}"-f'oso','=Bo','d','Sans Serif','ft ','Micr','8pt, style',', 1','l')
		$labelCountdown.Location = ("{0}{1}" -f'2','0,165')
		$labelCountdown.Name = ("{0}{1}{3}{2}" -f'l','ab','own','elCountd')
		$labelCountdown.Size = ("{0}{1}"-f '400',',30')
		$labelCountdown.TabIndex = 5
		$labelCountdown.Text = ("{1}{2}{0}"-f '0','00',':00:0')
		$labelCountdown.TextAlign = ("{3}{1}{2}{0}" -f'r','iddleCe','nte','M')
		
		
		$buttonRestartLater.Anchor = ("{1}{2}{0}"-f 'om,Left','B','ott')
		$buttonRestartLater.Location = ("{0}{2}{1}" -f'2','216','0,')
		$buttonRestartLater.Name = ("{4}{3}{1}{2}{0}"-f 'r','tL','ate','Restar','button')
		$buttonRestartLater.Size = ("{0}{1}" -f'159',',23')
		$buttonRestartLater.TabIndex = 0
		$buttonRestartLater.Text = $configRestartPromptButtonRestartLater
		$buttonRestartLater.UseVisualStyleBackColor = $true
		$buttonRestartLater.add_Click($buttonRestartLater_Click)
		
		
		$buttonRestartNow.Anchor = ("{0}{1}{2}"-f 'Bottom,R','ig','ht')
		$buttonRestartNow.Location = ("{2}{1}{0}"-f '6','1','265,2')
		$buttonRestartNow.Name = ("{1}{0}{2}{3}"-f 'Re','button','st','artNow')
		$buttonRestartNow.Size = ("{1}{0}"-f ',23','159')
		$buttonRestartNow.TabIndex = 2
		$buttonRestartNow.Text = $configRestartPromptButtonRestartNow
		$buttonRestartNow.UseVisualStyleBackColor = $true
		$buttonRestartNow.add_Click($buttonRestartNow_Click)
		
		
		If (-not $NoCountdown) { $timerCountdown.add_Tick($timerCountdown_Tick) }
		
		
		
		
		$InitialFormWindowState = $formRestart.WindowState
		
		$formRestart.add_Load($Form_StateCorrection_Load)
		
		$formRestart.add_FormClosed($Form_Cleanup_FormClosed)
		$formRestartClosing = [System.Windows.Forms.FormClosingEventHandler]{ $_.Cancel = $true }
		$formRestart.add_FormClosing($formRestartClosing)
		
		
		If ($deployAppScriptFriendlyName) {
			If ($NoCountdown) {
				Write-Log -Message "Invoking ${CmdletName} asynchronously with no countdown..." -Source ${CmdletName}
			}
			Else {
				Write-Log -Message "Invoking ${CmdletName} asynchronously with a [$countDownSeconds] second countdown..." -Source ${CmdletName}
			}
			[string]$installRestartPromptParameters = ($installRestartPromptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{1}{3}{2}{0}" -f 'rameter','Sw','Pa','itch')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{0}{1}{2}" -f 'B','oolea','n')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}" -f '2','Int3')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' '
			Start-Process -FilePath "$PSHOME\powershell.exe" -ArgumentList ('-Execut'+'ionPol'+'i'+'cy '+'Byp'+'ass'+' '+'-NoPr'+'ofile'+' '+'-NoLo'+'g'+'o '+'-Wind'+'owStyl'+'e '+'Hi'+'dden '+'-C'+'ommand '+"`"$scriptPath`" "+'-'+'Refe'+'rrin'+'gAppl'+'ica'+'tion '+"`"$installName`" "+'-Show'+'I'+'nstal'+'latio'+'nRes'+'tar'+'tPrompt '+"$installRestartPromptParameters") -WindowStyle Hidden -ErrorAction ("{4}{2}{3}{1}{0}"-f'nue','nti','ently','Co','Sil')
		}
		Else {
			If ($NoCountdown) {
				Write-Log -Message ("{1}{7}{2}{4}{8}{6}{5}{10}{3}{9}{11}{0}" -f'ountdown.','D','r','ith ','e','ompt','pr','isplay ','start ','no',' w',' c') -Source ${CmdletName}
			}
			Else {
				Write-Log -Message ('D'+'isp'+'lay '+'res'+'tart'+' '+'prom'+'pt '+'w'+'ith '+'a '+"[$countDownSeconds] "+'s'+'econd '+'cou'+'n'+'td'+'own.') -Source ${CmdletName}
			}
			
			
			Write-Output $formRestart.ShowDialog()
			$formRestart.Dispose()
			
			[System.Diagnostics.Process]$powershellProcess = Get-Process | Where-Object { $_.MainWindowTitle -match $installTitle }
			[Microsoft.VisualBasic.Interaction]::AppActivate($powershellProcess.ID)
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-BalloonTip {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,Position=0)]
		[ValidateNotNullOrEmpty()]
		[string]$BalloonTipText,
		[Parameter(Mandatory=$false,Position=1)]
		[ValidateNotNullorEmpty()]
		[string]$BalloonTipTitle = $installTitle,
		[Parameter(Mandatory=$false,Position=2)]
		[ValidateSet({"{0}{1}" -f 'Erro','r'},{"{0}{1}" -f 'In','fo'},{"{1}{0}" -f'ne','No'},{"{1}{0}{2}"-f'n','War','ing'})]
		[System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = ("{0}{1}" -f'Inf','o'),
		[Parameter(Mandatory=$false,Position=3)]
		[ValidateNotNullorEmpty()]
		[int32]$BalloonTipTime = 10000
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		If (($deployModeSilent) -or (-not $configShowBalloonNotifications)) { Return }

		
		If (-not $IsProcessUserInteractive) {
			Invoke-PSCommandAsUser -Command ([scriptblock]::Create(('S'+'how-Ball'+'oo'+'nTip '+'-'+'B'+'allo'+'on'+'TipText '+"'$BalloonTipText' "+'-Bal'+'loonTi'+'pTitl'+'e '+"'$BalloonTipTitle' "+'-B'+'alloo'+'nT'+'ipIcon '+"'$BalloonTipIcon' "+'-Balloo'+'nT'+'ipTi'+'me '+"$BalloonTipTime")))
			Return
		}
		
		
		If ($global:notifyIcon) { Try { $global:notifyIcon.Dispose() } Catch {} }
		
		
		Try {
			[string]$callingFunction = (Get-Variable -Name MyInvocation -Scope 1 -ErrorAction ("{2}{0}{1}"-f'y','Continue','Silentl')).Value.MyCommand.Name
		}
		Catch { }
		
		If ($callingFunction -eq ("{0}{2}{1}" -f'E','ript','xit-Sc')) {
			Write-Log -Message ('Display'+' '+'b'+'al'+'loon '+'tip'+' '+'not'+'ification'+' '+'asy'+'hchronous'+'ly '+'wit'+'h '+'mess'+'age'+' '+"[$BalloonTipText]") -Source ${CmdletName}
			
			[scriptblock]$notifyIconScriptBlock = {
				Param (
					[Parameter(Mandatory=$true,Position=0)]
					[ValidateNotNullOrEmpty()]
					[string]$BalloonTipText,
					[Parameter(Mandatory=$false,Position=1)]
					[ValidateNotNullorEmpty()]
					[string]$BalloonTipTitle,
					[Parameter(Mandatory=$false,Position=2)]
					[ValidateSet({"{1}{0}" -f 'ror','Er'},{"{1}{0}"-f'fo','In'},{"{1}{0}" -f 'e','Non'},{"{1}{0}{2}"-f'arni','W','ng'})]
					$BalloonTipIcon, 
					[Parameter(Mandatory=$false,Position=3)]
					[ValidateNotNullorEmpty()]
					[int32]$BalloonTipTime,
					[Parameter(Mandatory=$false,Position=4)]
					[ValidateNotNullorEmpty()]
					[string]$AppDeployLogoIcon
				)
				
				
				Add-Type -AssemblyName System.Windows.Forms -ErrorAction ("{0}{1}"-f'St','op')
				Add-Type -AssemblyName System.Drawing -ErrorAction ("{0}{1}" -f 'St','op')
				
				[Windows.Forms.ToolTipIcon]$BalloonTipIcon = $BalloonTipIcon
				$global:notifyIcon = New-Object -TypeName Windows.Forms.NotifyIcon -Property @{
					BalloonTipIcon = $BalloonTipIcon
					BalloonTipText = $BalloonTipText
					BalloonTipTitle = $BalloonTipTitle
					Icon = New-Object -TypeName System.Drawing.Icon -ArgumentList $AppDeployLogoIcon
					Text = -join $BalloonTipText[0..62]
					Visible = $true
				}
				
				
				$global:NotifyIcon.ShowBalloonTip($BalloonTipTime)
				
				
				Start-Sleep -Milliseconds ($BalloonTipTime)
				$global:notifyIcon.Dispose()
			}
			
			
			Try {
				Execute-Process -Path "$PSHOME\powershell.exe" -Parameters "-ExecutionPolicy Bypass -NoProfile -NoLogo -WindowStyle Hidden -Command & {$notifyIconScriptBlock} '$BalloonTipText' '$BalloonTipTitle' '$BalloonTipIcon' '$BalloonTipTime' '$AppDeployLogoIcon'" -NoWait -WindowStyle Hidden -CreateNoWindow
			}
			Catch { }
		}
		
		Else {
			Write-Log -Message ('D'+'isplay '+'b'+'allo'+'on '+'tip'+' '+'not'+'ificati'+'on '+'with'+' '+'me'+'ss'+'age '+"[$BalloonTipText]") -Source ${CmdletName}
			[Windows.Forms.ToolTipIcon]$BalloonTipIcon = $BalloonTipIcon
			$global:notifyIcon = New-Object -TypeName Windows.Forms.NotifyIcon -Property @{
				BalloonTipIcon = $BalloonTipIcon
				BalloonTipText = $BalloonTipText
				BalloonTipTitle = $BalloonTipTitle
				Icon = New-Object -TypeName System.Drawing.Icon -ArgumentList $AppDeployLogoIcon
				Text = -join $BalloonTipText[0..62]
				Visible = $true
			}
			
			
			$global:NotifyIcon.ShowBalloonTip($BalloonTipTime)
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Show-InstallationProgress {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$StatusMessage = $configProgressMessageInstall,
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{1}{0}"-f'fault','De'},{"{0}{2}{3}{1}" -f'Bott','ight','o','mR'})]
		[string]$WindowLocation = ("{2}{0}{1}" -f 'aul','t','Def'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$TopMost = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($deployModeSilent) { Return }

		
		If (($statusMessage -eq $configProgressMessageInstall) -and ($deploymentType -eq ("{1}{2}{0}" -f 'nstall','U','ni'))) {
			$StatusMessage = $configProgressMessageUninstall
		}
		
		If ($envHost.Name -match ("{1}{0}"-f'rGUI','Powe')) {
			Write-Log -Message "$($envHost.Name) is not a supported host for WPF multithreading. Progress dialog with message [$statusMessage] will not be displayed. " -Severity 2 -Source ${CmdletName}
			Return
		}
		
		
		If (-not $IsProcessUserInteractive) {
			Invoke-PSCommandAsUser -NoWait -Command ([scriptblock]::Create(('S'+'how-Inst'+'allationPro'+'gr'+'ess '+'-St'+'atusMe'+'ss'+'age '+"'$StatusMessage' "+'-'+'W'+'indowL'+'ocation '+"'$WindowLocation' "+'-To'+'p'+'Mo'+'st '+"`$$TopMost")))
			Return
		}
		
		
		If (Test-Path -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -PathType ("{1}{0}"-f 'af','Le')) {
			$StatusMessage | Export-Clixml -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -Force
			Return
		}
		Else {
			$StatusMessage | Export-Clixml -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -Force
			
			$balloonText = ("$deploymentTypeName "+"$configBalloonTextStart")
			Show-BalloonTip -BalloonTipIcon ("{0}{1}"-f'Inf','o') -BalloonTipText $balloonText
		}
		
		
		If ($global:ProgressSyncHash.Window.Dispatcher.Thread.ThreadState -ne ("{1}{0}"-f 'ning','Run')) {
			
			$global:ProgressSyncHash = [hashtable]::Synchronized(@{ })
			$global:ProgressSyncHash.StatusMessage = $statusMessage
			
			$global:ProgressRunspace = [runspacefactory]::CreateRunspace()
			$global:ProgressRunspace.ApartmentState = 'STA'
			$global:ProgressRunspace.ThreadOptions = ("{3}{2}{0}{1}"-f'seT','hread','u','Re')
			$global:ProgressRunspace.Open()
			
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{3}{4}{2}{1}{0}"-f 'yncHash','ressS','g','p','ro'), $global:ProgressSyncHash)
			
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{0}{2}{1}" -f'insta','tle','llTi'), $installTitle)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{1}{0}{3}{2}" -f'w','windo','ion','Locat'), $windowLocation)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{0}{1}"-f 't','opMost'), [string]$topMost)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{1}{3}{4}{0}{2}"-f 'n','appDeployLogo','er','B','an'), $appDeployLogoBanner)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{2}{1}{0}{3}"-f'sMessa','atu','st','ge'), $statusMessage)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{2}{4}{1}{3}{0}" -f'oIcon','oy','App','Log','Depl'), $AppDeployLogoIcon)
			$global:ProgressRunspace.SessionStateProxy.SetVariable(("{2}{1}{0}" -f 'iScale','p','d'), $dpiScale)
			
			
			$powershell = [PowerShell]::Create()
			$powershell.Runspace = $global:ProgressRunspace
			$powershell.AddScript({
				[Xml.XmlDocument]$xamlProgress = @'
				<Window
				xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
				xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
				x:Name="Window" Title=""
				MaxHeight="200" MinHeight="180" Height="180"
				MaxWidth="456" MinWidth="456" Width="456" Padding="0,0,0,0" Margin="0,0,0,0"
				WindowStartupLocation = "Manual"
				Top=""
				Left=""
				Topmost=""
				ResizeMode="NoResize"
				Icon=""
				ShowInTaskbar="True" >
				<Window.Resources>
					<Storyboard x:Key="Storyboard1" RepeatBehavior="Forever">
						<DoubleAnimationUsingKeyFrames BeginTime="00:00:00" Storyboard.TargetName="ellipse" Storyboard.TargetProperty="(UIElement.RenderTransform).(TransformGroup.Children)[2].(RotateTransform.Angle)">
						<SplineDoubleKeyFrame KeyTime="00:00:02" Value="360"/>
						</DoubleAnimationUsingKeyFrames>
					</Storyboard>
				</Window.Resources>
				<Window.Triggers>
					<EventTrigger RoutedEvent="FrameworkElement.Loaded">
						<BeginStoryboard Storyboard="{StaticResource Storyboard1}"/>
					</EventTrigger>
				</Window.Triggers>
				<Grid Background="
					<Grid.RowDefinitions>
						<RowDefinition Height="50"/>
						<RowDefinition Height="100"/>
					</Grid.RowDefinitions>
					<Grid.ColumnDefinitions>
						<ColumnDefinition Width="45"></ColumnDefinition>
						<ColumnDefinition Width="*"></ColumnDefinition>
					</Grid.ColumnDefinitions>
					<Image x:Name = "ProgressBanner" Grid.ColumnSpan="2" Margin="0,0,0,0" Source=""></Image>
					<TextBlock x:Name = "ProgressText" Grid.Row="1" Grid.Column="1" Margin="0,5,45,10" Text="" FontSize="15" FontFamily="Microsoft Sans Serif" HorizontalAlignment="Center" VerticalAlignment="Center" TextAlignment="Center" Padding="15" TextWrapping="Wrap"></TextBlock>
					<Ellipse x:Name = "ellipse" Grid.Row="1" Grid.Column="0" Margin="0,0,0,0" StrokeThickness="5" RenderTransformOrigin="0.5,0.5" Height="25" Width="25" HorizontalAlignment="Right" VerticalAlignment="Center">
						<Ellipse.RenderTransform>
							<TransformGroup>
								<ScaleTransform/>
								<SkewTransform/>
								<RotateTransform/>
							</TransformGroup>
						</Ellipse.RenderTransform>
						<Ellipse.Stroke>
							<LinearGradientBrush EndPoint="0.445,0.997" StartPoint="0.555,0.003">
								<GradientStop Color="White" Offset="0"/>
								<GradientStop Color="
							</LinearGradientBrush>
						</Ellipse.Stroke>
					</Ellipse>
					</Grid>
				</Window>
'@
				
				
				$screen = [System.Windows.Forms.Screen]::PrimaryScreen
				$screenWorkingArea = $screen.WorkingArea
				[int32]$screenWidth = $screenWorkingArea | Select-Object -ExpandProperty Width
				[int32]$screenHeight = $screenWorkingArea | Select-Object -ExpandProperty Height
				
				If ($windowLocation -eq ("{2}{1}{0}{3}"-f 'mR','o','Bott','ight')) {
					$xamlProgress.Window.Left = [string]($screenWidth - $xamlProgress.Window.Width - 10)
					$xamlProgress.Window.Top = [string]($screenHeight - $xamlProgress.Window.Height - 10)
				}
				
				Else {
					
					$xamlProgress.Window.Left = [string](($screenWidth / (2 * ($dpiscale / 100) )) - (($xamlProgress.Window.Width / 2)))
					$xamlProgress.Window.Top = [string]($screenHeight / 9.5)
				}
				$xamlProgress.Window.TopMost = $topMost
				$xamlProgress.Window.Icon = $AppDeployLogoIcon
				$xamlProgress.Window.Grid.Image.Source = $appDeployLogoBanner
				$xamlProgress.Window.Grid.TextBlock.Text = $statusMessage
				$xamlProgress.Window.Title = $installTitle
				
				$progressReader = New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $xamlProgress
				$global:ProgressSyncHash.Window = [Windows.Markup.XamlReader]::Load($progressReader)
				$global:ProgressSyncHash.ProgressText = $global:ProgressSyncHash.Window.FindName(("{2}{0}{1}"-f'rog','ressText','P'))
				
				$global:ProgressSyncHash.Window.Add_Closing({ $_.Cancel = $true })
				
				$global:ProgressSyncHash.Window.Add_MouseLeftButtonDown({ $global:ProgressSyncHash.Window.DragMove() })
				
				$global:ProgressSyncHash.Window.ToolTip = $installTitle
				$global:ProgressSyncHash.Window.ShowDialog() | Out-Null
				$global:ProgressSyncHash.Error = $Error
			}) | Out-Null
			
			
			Write-Log -Message ('S'+'pin '+'up'+' '+'pr'+'o'+'gress '+'dial'+'og '+'i'+'n '+'a '+'sepa'+'rat'+'e '+'thr'+'e'+'ad '+'with'+' '+'m'+'essa'+'ge: '+"[$statusMessage]") -Source ${CmdletName}
			$progressData = $powershell.BeginInvoke()
			
			Start-Sleep -Seconds 3
			
			While ($global:ProgressSyncHash.StatusMessage -ne ("{1}{0}{2}{4}{3}" -f'Ru','_Close','ns','e','pac')) {
				Try {
					
					If (Test-Path -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -PathType ("{0}{1}" -f'Lea','f')) {
						$global:ProgressSyncHash.StatusMessage = Import-Clixml -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -ErrorAction ("{1}{0}" -f'top','S')
					}
					
					If ($global:ProgressSyncHash.StatusMessage -eq ("{2}{3}{0}{1}" -f'loseRunspac','e','_','C')) { Break }
					
					
					$global:ProgressSyncHash.Window.Dispatcher.Invoke([System.Windows.Threading.DispatcherPriority]("{0}{1}"-f'Norm','al'), [Windows.Input.InputEventHandler]{ $global:ProgressSyncHash.ProgressText.Text = $global:ProgressSyncHash.StatusMessage }, $null, $null)
					
					
					Start-Sleep -Seconds 1
				}
				Catch {
					Write-Log -Message "Unable to update the progress message. `n$(Resolve-Error) " -Severity 2 -Source ${CmdletName}
					Break
				}
			}
			
			
			If ($global:ProgressSyncHash.Error) {
				Write-Log -Message "Failure while displaying progress dialog. `n$(Resolve-Error -ErrorRecord $global:ProgressSyncHash.Error) " -Severity 3 -Source ${CmdletName}
			}
			
			
			$global:ProgressSyncHash.Window.Close()
			$global:ProgressSyncHash.Window.Dispose()
			$powershell.Dispose()
			
			
			If (Test-Path -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -PathType ("{1}{0}" -f'eaf','L')) {
				Remove-Item -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -Force -ErrorAction ("{3}{2}{4}{1}{0}"-f 'tinue','Con','n','Sile','tly') | Out-Null
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Close-InstallationProgress {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		If ($global:ProgressSyncHash.Window.Dispatcher.Thread.ThreadState -eq ("{0}{2}{1}"-f'R','nning','u')) {
			
			Write-Log -Message ("{4}{6}{5}{1}{3}{2}{0}" -f ' progress dialog.','a','ion','t','Close the','all',' inst') -Source ${CmdletName}
			$global:ProgressSyncHash.Window.Dispatcher.InvokeShutdown()
			$global:ProgressRunspace.Close()
			$global:ProgressSyncHash.Clear()
		}
		
		If (Test-Path -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -PathType ("{0}{1}" -f 'Lea','f')) {
			Remove-Item -Path "$dirAppDeployTemp\StatusMsgFrom_ShowInstallProgress.xml" -Force -ErrorAction ("{0}{3}{4}{2}{1}" -f'S','ue','in','il','entlyCont') | Out-Null
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-PinnedApplication {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateSet({"{1}{0}{2}"-f 'toSt','Pin','artMenu'},{"{0}{1}{2}{3}"-f'UnpinfromSt','a','rt','Menu'},{"{3}{1}{2}{0}" -f'bar','toT','ask','Pin'},{"{2}{0}{1}{3}{4}" -f 'om','Task','Unpinfr','b','ar'})]
		[string]$Action,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$FilePath
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		
		Function Get-PinVerb {
			[CmdletBinding()]
			Param (
				[Parameter(Mandatory=$true)]
				[ValidateNotNullorEmpty()]
				[int32]$VerbId
			)
			
			[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
			
			$GetPinVerbSource = @'
			using System;
			using System.Text;
			using System.Runtime.InteropServices;
			namespace Verb
			{
				public sealed class Load
				{
					[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
					public static extern int LoadString(IntPtr h, int id, StringBuilder sb, int maxBuffer);
					
					[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
					public static extern IntPtr LoadLibrary(string s);
					
					public static string PinVerb(int VerbId)
					{
						IntPtr hShell32 = LoadLibrary("shell32.dll");
						const int nChars  = 255;
						StringBuilder Buff = new StringBuilder("", nChars);
						
						LoadString(hShell32, VerbId, Buff, Buff.Capacity);
						return Buff.ToString();
					}
				}
			}
'@
			If (-not ([System.Management.Automation.PSTypeName]("{0}{2}{1}"-f'V','b.Load','er')).Type) {
				Add-Type -TypeDefinition $GetPinVerbSource -Language CSharp -IgnoreWarnings -ErrorAction ("{0}{1}" -f'St','op')
			}
			
			Write-Log -Message ('Get'+' '+'loc'+'a'+'l'+'ized '+'p'+'in '+'ve'+'rb '+'fo'+'r '+'verb'+' '+'id'+' '+"[$VerbID].") -Source ${CmdletName}
			[string]$PinVerb = [Verb.Load]::PinVerb($VerbId)
			Write-Log -Message ('Verb'+' '+'I'+'D '+"[$VerbID] "+'h'+'as '+'a '+'loc'+'a'+'lized '+'pin'+' '+'ve'+'rb '+'o'+'f '+"[$PinVerb].") -Source ${CmdletName}
			Write-Output $PinVerb
		}
		
		
		
		Function Invoke-Verb {
			[CmdletBinding()]
			Param (
				[Parameter(Mandatory=$true)]
				[ValidateNotNullorEmpty()]
				[string]$FilePath,
				[Parameter(Mandatory=$true)]
				[ValidateNotNullorEmpty()]
				[string]$Verb
			)
			
			Try {
				[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
				$verb = $verb.Replace('&','')
				$path = Split-Path -Path $FilePath -Parent -ErrorAction ("{1}{0}" -f 'top','S')
				$folder = $shellApp.Namespace($path)
				$item = $folder.ParseName((Split-Path -Path $FilePath -Leaf -ErrorAction ("{0}{1}"-f'Sto','p')))
				$itemVerb = $item.Verbs() | Where-Object { $_.Name.Replace('&','') -eq $verb } -ErrorAction ("{0}{1}"-f 'S','top')
				
				If ($null -eq $itemVerb) {
					Write-Log -Message ('P'+'e'+'rforming '+'acti'+'o'+'n '+"[$verb] "+'is'+' '+'not'+' '+'pr'+'o'+'gramatical'+'ly'+' '+'supp'+'ort'+'ed'+' '+'for'+' '+'th'+'is '+'fi'+'le '+"[$FilePath].") -Severity 2 -Source ${CmdletName}
				}
				Else {
					Write-Log -Message ('Pe'+'rf'+'orm '+'ac'+'tio'+'n '+"[$verb] "+'on'+' '+"[$FilePath].") -Source ${CmdletName}
					$itemVerb.DoIt()
				}
			}
			Catch {
				Write-Log -Message "Failed to perform action [$verb] on [$FilePath]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			}
		}
		
		
		[hashtable]$Verbs = @{
			("{0}{3}{2}{1}"-f 'P','Menu','t','intoStar') = 5381
			("{3}{0}{4}{2}{1}" -f 'mStar','nu','e','Unpinfro','tM') = 5382
			("{2}{0}{1}"-f 'in','toTaskbar','P') = 5386
			("{2}{1}{0}{3}" -f 'k','as','UnpinfromT','bar') = 5387
		}
	}
	Process {
		Try {
			Write-Log -Message ('Exec'+'ut'+'e '+'act'+'ion '+"[$Action] "+'f'+'or '+'f'+'ile '+"[$FilePath].") -Source ${CmdletName}
			
			If (-not (Test-Path -Path $FilePath -PathType Leaf -ErrorAction ("{0}{1}" -f 'S','top'))) {
				Throw ('Pat'+'h '+"[$filePath] "+'do'+'es '+'not'+' '+'ex'+'ist.')
			}
			
			If (-not ($Verbs.$Action)) {
				Throw "Action [$Action] not supported. Supported actions are [$($Verbs.Keys -join ', ')]. "
			}
			
			[string]$PinVerbAction = Get-PinVerb -VerbId $Verbs.$Action
			If (-not ($PinVerbAction)) {
				Throw ('F'+'aile'+'d '+'to'+' '+'get'+' '+'a '+'localize'+'d'+' '+'p'+'in '+'ver'+'b '+'for'+' '+'a'+'ctio'+'n '+"[$Action]. "+'Action'+' '+'i'+'s '+'no'+'t '+'suppor'+'ted'+' '+'o'+'n '+'th'+'is '+'ope'+'rating'+' '+'system'+'.')
			}
			
			Invoke-Verb -FilePath $FilePath -Verb $PinVerbAction
		}
		Catch {
			Write-Log -Message "Failed to execute action [$Action]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-IniValue {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$FilePath,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Section,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$GetIniValueSource = @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;
		namespace IniFile
		{
			public sealed class GetValue
			{
				[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern int GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, StringBuilder lpReturnedString, int nSize, string lpFileName);
				
				public static string GetIniValue(string section, string key, string filepath)
				{
					string sDefault    = "";
					const int  nChars  = 1024;
					StringBuilder Buff = new StringBuilder(nChars);
					
					GetPrivateProfileString(section, key, sDefault, Buff, Buff.Capacity, filepath);
					return Buff.ToString();
				}
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{2}{0}{3}{4}{1}" -f'niFil','lue','I','e.G','etVa')).Type) {
			Add-Type -TypeDefinition $GetIniValueSource -Language CSharp -IgnoreWarnings -ErrorAction ("{0}{1}" -f 'St','op')
		}
	}
	Process {
		Try {
			Write-Log -Message ('R'+'ead '+'I'+'NI '+'Key'+': '+' '+'[Se'+'cti'+'on '+'= '+"$Section] "+'['+'Key '+'= '+"$Key]") -Source ${CmdletName}
			
			If (-not (Test-Path -Path $FilePath -PathType Leaf)) { Throw ('File'+' '+"[$filePath] "+'cou'+'ld '+'n'+'ot '+'b'+'e '+'f'+'oun'+'d.') }
			
			$IniValue = [IniFile.GetValue]::GetIniValue($Section, $Key, $FilePath)
			Write-Log -Message ('IN'+'I '+'Ke'+'y '+'Val'+'u'+'e: '+'[Sec'+'tion'+' '+'= '+"$Section] "+'[Key'+' '+'= '+"$Key] "+'['+'Value '+'= '+"$IniValue]") -Source ${CmdletName}
			
			Write-Output $IniValue
		}
		Catch {
			Write-Log -Message "Failed to read INI file key value. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to read INI file key value: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-IniValue {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$FilePath,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Section,
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Key,
		
		[Parameter(Mandatory=$true)]
		[AllowNull()]
		$Value,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$SetIniValueSource = @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;
		namespace IniFile
		{
			public sealed class SetValue
			{
				[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				[return: MarshalAs(UnmanagedType.Bool)]
				public static extern bool WritePrivateProfileString(string lpAppName, string lpKeyName, StringBuilder lpString, string lpFileName);
				
				public static void SetIniValue(string section, string key, StringBuilder value, string filepath)
				{
					WritePrivateProfileString(section, key, value, filepath);
				}
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{0}{1}{4}{3}{2}"-f 'I','niFile','e','lu','.SetVa')).Type) {
			Add-Type -TypeDefinition $SetIniValueSource -Language CSharp -IgnoreWarnings -ErrorAction ("{1}{0}" -f 'op','St')
		}
	}
	Process {
		Try {
			Write-Log -Message ('Wr'+'ite '+'INI'+' '+'K'+'ey '+'Va'+'lue'+': '+'['+'Sec'+'tion '+'= '+"$Section] "+'[Key'+' '+'= '+"$Key] "+'['+'Value'+' '+'= '+"$Value]") -Source ${CmdletName}
			
			If (-not (Test-Path -Path $FilePath -PathType Leaf)) { Throw ('Fi'+'le '+"[$filePath] "+'c'+'ould '+'n'+'ot '+'b'+'e '+'fo'+'und.') }
			
			[IniFile.SetValue]::SetIniValue($Section, $Key, ([System.Text.StringBuilder]$Value), $FilePath)
		}
		Catch {
			Write-Log -Message "Failed to write INI file key value. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to write INI file key value: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-PEFileArchitecture {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
		[ValidateScript({$_ | Test-Path -PathType Leaf})]
		[System.IO.FileInfo[]]$FilePath,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true,
		[Parameter(Mandatory=$false)]
		[switch]$PassThru
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		[string[]]$PEFileExtensions = ("{0}{1}"-f'.ex','e'), ("{1}{0}" -f 'll','.d'), ("{0}{1}"-f'.oc','x'), ("{1}{0}" -f'rv','.d'), ("{0}{1}"-f '.','sys'), ("{1}{0}"-f'cr','.s'), ("{0}{1}" -f '.ef','i'), ("{0}{1}" -f'.c','pl'), ("{0}{1}" -f'.f','on')
		[int32]$MACHINE_OFFSET = 4
		[int32]$PE_POINTER_OFFSET = 60
	}
	Process {
		ForEach ($Path in $filePath) {
			Try {
				If ($PEFileExtensions -notcontains $Path.Extension) {
					Throw "Invalid file type. Please specify one of the following PE file types: $($PEFileExtensions -join ', ') "
				}
				
				[byte[]]$data = New-Object -TypeName System.Byte[] -ArgumentList 4096
				$stream = New-Object -TypeName System.IO.FileStream -ArgumentList ($Path.FullName, ("{1}{0}" -f 'n','Ope'), ("{1}{0}"-f 'd','Rea'))
				$stream.Read($data, 0, 4096) | Out-Null
				$stream.Flush()
				$stream.Close()
				
				[int32]$PE_HEADER_ADDR = [System.BitConverter]::ToInt32($data, $PE_POINTER_OFFSET)
				[uint16]$PE_IMAGE_FILE_HEADER = [System.BitConverter]::ToUInt16($data, $PE_HEADER_ADDR + $MACHINE_OFFSET)
				Switch ($PE_IMAGE_FILE_HEADER) {
					0 { $PEArchitecture = ("{0}{1}" -f 'Na','tive') } 
					0x014c { $PEArchitecture = ("{0}{1}" -f'32B','IT') } 
					0x0200 { $PEArchitecture = ("{0}{2}{1}"-f 'I','x64','tanium-') } 
					0x8664 { $PEArchitecture = ("{0}{1}" -f'64BI','T') } 
					Default { $PEArchitecture = ("{0}{2}{1}"-f'Un','own','kn') }
				}
				Write-Log -Message "File [$($Path.FullName)] has a detected file architecture of [$PEArchitecture]. " -Source ${CmdletName}
				
				If ($PassThru) {
					
					Get-Item -Path $Path.FullName -Force | Add-Member -MemberType ("{3}{2}{1}{0}" -f'ty','oper','ePr','Not') -Name ("{1}{0}{2}" -f'aryT','Bin','ype') -Value $PEArchitecture -Force -PassThru | Write-Output
				}
				Else {
					Write-Output $PEArchitecture
				}
			}
			Catch {
				Write-Log -Message "Failed to get the PE file architecture. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to get the PE file architecture: $($_.Exception.Message) "
				}
				Continue
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Invoke-RegisterOrUnregisterDLL {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$FilePath,
		[Parameter(Mandatory=$false)]
		[ValidateSet({"{0}{2}{1}"-f'Reg','r','iste'},{"{2}{0}{1}" -f 't','er','Unregis'})]
		[string]$DLLAction,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		
		[string]${InvokedCmdletName} = $MyInvocation.InvocationName
		
		If (${InvokedCmdletName} -ne ${CmdletName}) {
			Switch (${InvokedCmdletName}) {
				("{1}{0}{3}{2}" -f 'e','R','er-DLL','gist') { [string]$DLLAction = ("{0}{2}{1}" -f 'Regi','ter','s') }
				("{0}{3}{4}{1}{2}" -f 'Unr','D','LL','eg','ister-') { [string]$DLLAction = ("{1}{2}{0}"-f 'ter','Unregi','s') }
			}
		}
		
		If (-not $DLLAction) { Throw ("{14}{2}{11}{12}{6}{19}{13}{10}{4}{23}{15}{9}{18}{21}{7}{24}{8}{22}{16}{1}{5}{3}{0}{20}{17}"-f 'e','ste','r valida','th','-DLL','r or unregister ','failed. Pleas','ne whe','er ','ter',' the [','tio','n ','fy','Paramete','on] parame','egi','.',' t','e speci',' DLL','o determi','to r','Acti','th') }
		[string]$DLLAction = (Get-Culture).TextInfo | ForEach-Object { $_.ToTitleCase($DLLAction.ToLower()) }
		Switch ($DLLAction) {
			("{1}{2}{0}"-f 'ister','Re','g') { [string]$DLLActionParameters = ('/'+'s '+"`"$FilePath`"") }
			("{1}{2}{0}" -f 'er','Unre','gist') { [string]$DLLActionParameters = ('/'+'s '+'/'+'u '+"`"$FilePath`"") }
		}
	}
	Process {
		Try {
			Write-Log -Message ("$DLLAction "+'DL'+'L '+'fi'+'le '+"[$filePath].") -Source ${CmdletName}
			If (-not (Test-Path -Path $FilePath -PathType Leaf)) { Throw ('Fi'+'le '+"[$filePath] "+'cou'+'ld'+' '+'n'+'ot '+'be'+' '+'f'+'o'+'und.') }
			
			[string]$DLLFileBitness = Get-PEFileArchitecture -FilePath $filePath -ContinueOnError $false -ErrorAction ("{0}{1}" -f'St','op')
			If (($DLLFileBitness -ne ("{1}{0}"-f 'T','64BI')) -and ($DLLFileBitness -ne ("{0}{1}"-f'32BI','T'))) {
				Throw ("File [$filePath] has a detected file architecture of [$DLLFileBitness]. Only 32-bit or 64-bit DLL files can be $($DLLAction.ToLower() + 'ed'). ")
			}
			
			If ($Is64Bit) {
				If ($DLLFileBitness -eq ("{0}{1}"-f '6','4BIT')) {
					If ($Is64BitProcess) {
						[psobject]$ExecuteResult = Execute-Process -Path "$envWinDir\system32\regsvr32.exe" -Parameters $DLLActionParameters -WindowStyle Hidden -PassThru
					}
					Else {
						[psobject]$ExecuteResult = Execute-Process -Path "$envWinDir\sysnative\regsvr32.exe" -Parameters $DLLActionParameters -WindowStyle Hidden -PassThru
					}
				}
				ElseIf ($DLLFileBitness -eq ("{1}{0}" -f 'IT','32B')) {
					[psobject]$ExecuteResult = Execute-Process -Path "$envWinDir\SysWOW64\regsvr32.exe" -Parameters $DLLActionParameters -WindowStyle Hidden -PassThru
				}
			}
			Else {
				If ($DLLFileBitness -eq ("{0}{1}" -f '6','4BIT')) {
					Throw "File [$filePath] cannot be $($DLLAction.ToLower()) because it is a 64-bit file on a 32-bit operating system. "
				}
				ElseIf ($DLLFileBitness -eq ("{1}{0}"-f'BIT','32')) {
					[psobject]$ExecuteResult = Execute-Process -Path "$envWinDir\system32\regsvr32.exe" -Parameters $DLLActionParameters -WindowStyle Hidden -PassThru
				}
			}
			
			If ($ExecuteResult.ExitCode -ne 0) {
				If ($ExecuteResult.ExitCode -eq 999) {
					Throw "Execute-Process function failed with exit code [$($ExecuteResult.ExitCode)]. "
				}
				Else {
					Throw "regsvr32.exe failed with exit code [$($ExecuteResult.ExitCode)]. "
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to $($DLLAction.ToLower()) DLL file. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to $($DLLAction.ToLower()) DLL file: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}
Set-Alias -Name ("{0}{1}{2}"-f 'Regis','ter-DL','L') -Value ("{2}{3}{5}{0}{1}{4}{6}" -f'rO','rUnregi','Inv','o','s','ke-Registe','terDLL') -Scope Script -Force -ErrorAction ("{0}{1}{2}" -f 'Silent','lyCon','tinue')
Set-Alias -Name ("{1}{3}{0}{2}"-f 'ste','Unre','r-DLL','gi') -Value ("{2}{6}{1}{3}{5}{0}{4}" -f 'erDL','rOrUn','Inv','regis','L','t','oke-Registe') -Scope Script -Force -ErrorAction ("{4}{2}{3}{1}{0}"-f'e','nu','t','i','SilentlyCon')




Function Get-MsiTableProperty {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateScript({ $_ | Test-Path -PathType Leaf })]
		[string]$Path,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$Table = ("{2}{1}{0}"-f'y','rt','Prope'),
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		[scriptblock]$InvokeMethod = {
			Param (
				[__comobject]$Object,
				[string]$MethodName,
				[object[]]$ArgumentList
			)
			Write-Output $Object.GetType().InvokeMember($MethodName, [System.Reflection.BindingFlags]::InvokeMethod, $null, $Object, $ArgumentList, $null, $null, $null)
		}
		
		[scriptblock]$GetProperty = {
			Param (
				[__comobject]$Object,
				[string]$PropertyName,
				[object[]]$ArgumentList
			)
			Write-Output $Object.GetType().InvokeMember($PropertyName, [System.Reflection.BindingFlags]::GetProperty, $null, $Object, $ArgumentList, $null, $null, $null)
		}
	}
	Process {
		Try {
			Write-Log -Message ('G'+'et '+'pro'+'pertie'+'s'+' '+'from'+' '+'MS'+'I '+'fil'+'e '+"[$Path] "+'in'+' '+'tabl'+'e'+' '+"[$Table]") -Source ${CmdletName}
			
			
			[psobject]$TableProperties = New-Object -TypeName PSObject
			
			[__comobject]$Installer = New-Object -ComObject WindowsInstaller.Installer -ErrorAction ("{0}{1}"-f'S','top')
			
			[int32]$OpenMSIReadOnly = 0
			[__comobject]$Database = &$InvokeMethod -Object $Installer -MethodName ("{1}{2}{0}"-f'base','OpenDat','a') -ArgumentList @($Path, $OpenMSIReadOnly)
			
			[__comobject]$View = &$InvokeMethod -Object $Database -MethodName ("{2}{1}{0}"-f'View','pen','O') -ArgumentList @(('SE'+'L'+'ECT '+'* '+'FR'+'OM '+"$Table"))
			&$InvokeMethod -Object $View -MethodName ("{1}{0}{2}"-f'cu','Exe','te') | Out-Null
			
			
			[__comobject]$Record = &$InvokeMethod -Object $View -MethodName ("{0}{1}"-f'Fet','ch')
			
			While ($Record) {
				
				$TableProperties | Add-Member -MemberType NoteProperty -Name (& $GetProperty -Object $Record -PropertyName ("{0}{1}{3}{2}" -f'String','D','a','at') -ArgumentList @(1)) -Value (& $GetProperty -Object $Record -PropertyName ("{1}{0}{2}"-f 'a','StringD','ta') -ArgumentList @(2))
				
				[__comobject]$Record = & $InvokeMethod -Object $View -MethodName ("{0}{1}" -f'Fe','tch')
			}
			
			Write-Output $TableProperties
		}
		Catch {
			Write-Log -Message "Failed to get the MSI table [$Table]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to get the MSI table [$Table]: $($_.Exception.Message) "
			}
		}
		Finally {
			If ($View) {
				& $InvokeMethod -Object $View -MethodName ("{0}{1}"-f'Clo','se') -ArgumentList @() | Out-Null
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-MSUpdates {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,Position=0,HelpMessage={"{1}{3}{8}{2}{6}{7}{5}{4}{9}{0}" -f 'ft Update','E','r','n','umber for the',' N',' the K','B','te',' Microso'})]
		[ValidateNotNullorEmpty()]
		[string]$KBNumber
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Write-Log -Message ('C'+'heck '+'i'+'f '+'Micros'+'oft'+' '+'Up'+'date '+"[$kbNumber] "+'is'+' '+'i'+'nstall'+'ed.') -Source ${CmdletName}
		
		
		[boolean]$kbFound = $false
		
		
		[__comobject]$Session = New-Object -ComObject Microsoft.Update.Session
		[__comobject]$Collection = New-Object -ComObject Microsoft.Update.UpdateColl
		[__comobject]$Installer = $Session.CreateUpdateInstaller()
		[__comobject]$Searcher = $Session.CreateUpdateSearcher()
		[int32]$updateCount = $Searcher.GetTotalHistoryCount()
		If ($updateCount -gt 0) {
			$Searcher.QueryHistory(0, $updateCount) | Where-Object { $_.Title -match $kbNumber } | ForEach-Object { $kbFound = $true }
		}
		
		
		If (-not $kbFound) {
			Get-Hotfix -Id $kbNumber -ErrorAction ("{2}{0}{3}{1}"-f 'lyCo','e','Silent','ntinu') | ForEach-Object { $kbFound = $true }
		}
		
		
		If (-not $kbFound) {
			Write-Log -Message ('Mi'+'cro'+'soft '+'Upd'+'ate '+"[$kbNumber] "+'i'+'s '+'n'+'ot '+'insta'+'l'+'led') -Source ${CmdletName}
			Write-Output $false
		}
		Else {
			Write-Log -Message ('Micr'+'oso'+'f'+'t '+'Upd'+'ate '+"[$kbNumber] "+'is'+' '+'in'+'s'+'talled') -Source ${CmdletName}
			Write-Output $true
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Install-MSUpdates {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$Directory
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Write-Log -Message ('Rec'+'ursiv'+'e'+'ly '+'insta'+'ll '+'al'+'l '+'Mic'+'ro'+'soft '+'Up'+'dates '+'i'+'n '+'dir'+'ec'+'tory '+"[$Directory].") -Source ${CmdletName}
		
		
		$kbPattern = '(?i)kb\d{6,8}'
		
		
		[System.IO.FileInfo[]]$files = Get-ChildItem -Path $Directory -Recurse -Include (("{1}{0}" -f '.exe','*'),("{0}{1}" -f '*.m','su'),("{0}{1}" -f '*.m','sp'))
		ForEach ($file in $files) {
			If ($file.Name -match ("{2}{0}{1}" -f'ed','ist','r')) {
				[version]$redistVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($file).ProductVersion
				[string]$redistDescription = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($file).FileDescription
				
				Write-Log -Message ('Instal'+'l '+"[$redistDescription "+"$redistVersion]...") -Source ${CmdletName}
				
				If ($redistDescription -match ("{5}{0}{4}{6}{1}{8}{3}{2}{7}"-f 'n32 Cab','et','r','Self-Ext','i','Wi','n','actor',' ')) {
					Execute-Process -Path $file -Parameters '/q' -WindowStyle Hidden -ContinueOnError $true
				}
				Else {
					Execute-Process -Path $file -Parameters ("{2}{1}{0}{3}" -f 'r','resta','/quiet /no','t') -WindowStyle Hidden -ContinueOnError $true
				}
			}
			Else {
				
				[string]$kbNumber = [regex]::Match($file, $kbPattern).ToString()
				If (-not $kbNumber) { Continue }
				
				
				If (-not (Test-MSUpdates -KBNumber $kbNumber)) {
					Write-Log -Message ('K'+'B '+'Numbe'+'r'+' '+"[$KBNumber] "+'w'+'as '+'not'+' '+'det'+'ecte'+'d '+'an'+'d '+'will'+' '+'b'+'e '+'inst'+'al'+'led.') -Source ${CmdletName}
					Switch ($file.Extension) {
						
						("{1}{0}" -f'e','.ex') { Execute-Process -Path $file -Parameters ("{2}{0}{3}{1}{4}{5}"-f' /','ores','/quiet','n','tar','t') -WindowStyle Hidden -ContinueOnError $true }
						
						("{1}{0}"-f'msu','.') { Execute-Process -Path ("{0}{1}{2}"-f 'wu','sa','.exe') -Parameters ("`"$file`" "+'/quie'+'t '+'/n'+'o'+'restart') -WindowStyle Hidden -ContinueOnError $true }
						
						("{1}{0}" -f 'msp','.') { Execute-MSI -Action ("{1}{0}" -f 'atch','P') -Path $file -ContinueOnError $true }
					}
				}
				Else {
					Write-Log -Message ('KB'+' '+'Numb'+'er '+"[$kbNumber] "+'i'+'s '+'alr'+'e'+'ady '+'inst'+'alled'+'. '+'Cont'+'in'+'ue...') -Source ${CmdletName}
				}
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Send-Keys {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true,Position=0)]
		[ValidateNotNullorEmpty()]
		[string]$WindowTitle,
		[Parameter(Mandatory=$true,Position=1)]
		[ValidateNotNullorEmpty()]
		[string]$Keys,
		[Parameter(Mandatory=$false,Position=2)]
		[ValidateNotNullorEmpty()]
		[int32]$WaitSeconds
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		
		Add-Type -AssemblyName System.Windows.Forms -ErrorAction ("{1}{0}" -f'op','St')
		
		$SetForegroundWindowSource = @'
			using System;
			using System.Runtime.InteropServices;
			public class GUIWindow
			{
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				[return: MarshalAs(UnmanagedType.Bool)]
				public static extern bool SetForegroundWindow(IntPtr hWnd);
			}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{1}{2}{0}"-f 'dow','GU','IWin')).Type) {
			Add-Type -TypeDefinition $SetForegroundWindowSource -Language CSharp -IgnoreWarnings -ErrorAction ("{0}{1}" -f'S','top')
		}
	}
	Process {
		Try {
			
			[System.Diagnostics.Process[]]$Process = Get-Process -ErrorAction ("{1}{0}" -f'top','S') | Where-Object { $_.MainWindowTitle.Contains($WindowTitle) }
			If ($Process) {
				Write-Log -Message "Match window title found running under process [$($process.name)]... " -Source ${CmdletName}
				
				[IntPtr]$ProcessHandle = $Process[0].MainWindowHandle
				
				Write-Log -Message ("{6}{0}{5}{1}{4}{3}{7}{2}"-f' wi','t','.','r','o fo','ndow ','Bring','eground') -Source ${CmdletName}
				
				[boolean]$ActivateWindow = [GUIWindow]::SetForegroundWindow($ProcessHandle)
				
				
				
				If ($ActivateWindow) {
					Write-Log -Message ('S'+'end '+'key('+'s) '+('[F6cKeys]'+' ').REPLACE(([CHAR]70+[CHAR]54+[CHAR]99),[STRINg][CHAR]36)+'t'+'o '+'window'+'.') -Source ${CmdletName}
					[System.Windows.Forms.SendKeys]::SendWait($Keys)
				}
				Else {
					Write-Log -Message ("{2}{7}{4}{8}{0}{1}{3}{5}{6}" -f ' ','to fo','Fa','regrou',' to b','nd','.','iled','ring window') -Source ${CmdletName}
					
				}
				
				If ($WaitSeconds) { Start-Sleep -Seconds $WaitSeconds }
			}
		}
		Catch {
			Write-Log -Message "Failed to send keys to window [$WindowTitle]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-Battery {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		
		Add-Type -Assembly System.Windows.Forms -ErrorAction ("{2}{0}{1}{4}{3}" -f 'ile','ntlyC','S','tinue','on')
	}
	Process {
		Write-Log -Message ("{9}{8}{10}{0}{18}{13}{16}{19}{12}{5}{17}{11}{1}{14}{4}{15}{7}{2}{6}{3}" -f' ',' ','n bat','..',' it','s us','tery.',' o','hec','C','k',' power or','i','f sy','if',' is running','ste','ing AC','i','m ') -Source ${CmdletName}
		
		[System.Windows.Forms.PowerStatus]$PowerStatus = [System.Windows.Forms.SystemInformation]::PowerStatus
		
		
		
		
		
		[string]$PowerLineStatus = $PowerStatus.PowerLineStatus
		
		
		[string]$BatteryChargeStatus = $PowerStatus.BatteryChargeStatus
		
		
		
		
		[single]$BatteryLifePercent = $PowerStatus.BatteryLifePercent
		If (($BatteryChargeStatus -eq ("{2}{3}{1}{0}" -f 'ry','temBatte','NoS','ys')) -or ($BatteryChargeStatus -eq ("{0}{1}"-f'U','nknown'))) {
			[single]$BatteryLifePercent = 0.0
		}
		
		
		[int32]$BatteryLifeRemaining = $PowerStatus.BatteryLifeRemaining
		
		
		
		
		[int32]$BatteryFullLifetime = $PowerStatus.BatteryFullLifetime
		
		
		[boolean]$OnACPower = $false
		If ($PowerLineStatus -eq ("{2}{1}{0}"-f'ine','nl','O')) {
			Write-Log -Message ("{2}{1}{4}{0}{3}"-f'wer','m','Syste','.',' is using AC po') -Source ${CmdletName}
			$OnACPower = $true
		}
		ElseIf ($PowerLineStatus -eq ("{0}{1}{2}" -f'Of','flin','e')) {
			Write-Log -Message ("{7}{3}{4}{8}{0}{2}{9}{6}{1}{5}"-f'g batte','pow','r','t','em is ','er.',' ','Sys','usin','y') -Source ${CmdletName}
		}
		ElseIf ($PowerLineStatus -eq ("{1}{2}{0}" -f'nown','Un','k')) {
			If (($BatteryChargeStatus -eq ("{2}{1}{3}{0}"-f'tery','t','NoSys','emBat')) -or ($BatteryChargeStatus -eq ("{0}{1}"-f'Unkn','own'))) {
				Write-Log -Message ('System'+' '+'powe'+'r '+'statu'+'s '+'is'+' '+"[$PowerLineStatus] "+'and'+' '+'batter'+'y'+' '+'c'+'harge '+'stat'+'us '+'is'+' '+"[$BatteryChargeStatus]. "+'This'+' '+'is'+' '+'m'+'ost '+'like'+'ly '+'due'+' '+'to'+' '+'a '+'dam'+'a'+'ged '+'b'+'attery '+'s'+'o '+'we'+' '+'wil'+'l '+'re'+'port '+'sys'+'tem'+' '+'i'+'s '+'usin'+'g '+'AC'+' '+'powe'+'r'+'.') -Source ${CmdletName}
				$OnACPower = $true
			}
			Else {
				Write-Log -Message ('S'+'y'+'stem '+'power'+' '+'status'+' '+'i'+'s '+"[$PowerLineStatus] "+'a'+'nd '+'batt'+'ery'+' '+'charg'+'e '+'st'+'a'+'tus '+'i'+'s '+"[$BatteryChargeStatus]. "+'T'+'h'+'erefore, '+'we'+' '+'w'+'ill '+'repor'+'t '+'syst'+'em '+'i'+'s '+'u'+'sing '+'ba'+'tte'+'ry '+'power'+'.') -Source ${CmdletName}
			}
		}
		
		Write-Output $OnACPower
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-NetworkConnection {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Write-Log -Message ("{2}{3}{7}{11}{10}{8}{1}{5}{6}{0}{4}{9}"-f'ion','twork co','Che','ck','.','nnec','t',' if ','d ne','..','using a wire','system is ') -Source ${CmdletName}
		
		[psobject[]]$networkConnected = Get-WmiObject -Class Win32_NetworkAdapter | Where-Object { ($_.NetConnectionStatus -eq 2) -and ($_.NetConnectionID -match ("{1}{0}"-f 'cal','Lo')) -and ($_.NetConnectionID -notmatch ("{0}{1}"-f 'Wir','eless')) -and ($_.Name -notmatch ("{0}{1}{2}" -f 'V','irtua','l')) } -ErrorAction ("{4}{3}{1}{0}{2}"-f 'tlyC','en','ontinue','l','Si')
		[boolean]$onNetwork = $false
		If ($networkConnected) {
			Write-Log -Message ("{0}{2}{5}{1}{4}{3}" -f'W','ne','ire','ection found.','twork conn','d ') -Source ${CmdletName}
			[boolean]$onNetwork = $true
		}
		Else {
			Write-Log -Message ("{1}{5}{8}{0}{3}{6}{4}{2}{7}"-f 'o','Wired ','t ','n','ection no','netw','n','found.','ork c') -Source ${CmdletName}
		}
		
		Write-Output $onNetwork
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-PowerPoint {

	[CmdletBinding()]
	Param (
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$FullScreenWindowSource = @'
		using System;
		using System.Text;
		using System.Text.RegularExpressions;
		using System.Runtime.InteropServices;
		namespace ScreenDetection
		{
			[StructLayout(LayoutKind.Sequential)]
			public struct RECT
			{
				public int Left;
				public int Top;
				public int Right;
				public int Bottom;
			}
			
			public class FullScreen
			{
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				private static extern IntPtr GetForegroundWindow();
				
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				private static extern IntPtr GetDesktopWindow();
				
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				private static extern IntPtr GetShellWindow();
				
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				private static extern int GetWindowRect(IntPtr hWnd, out RECT rc);
				
				[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int count);
				
				private static IntPtr desktopHandle;
				private static IntPtr shellHandle;
				
				public static bool IsFullScreenWindow(string fullScreenWindowTitle)
				{
					desktopHandle = GetDesktopWindow();
					shellHandle   = GetShellWindow();
					
					bool runningFullScreen = false;
					RECT appBounds;
					System.Drawing.Rectangle screenBounds;
					const int nChars = 256;
					StringBuilder Buff = new StringBuilder(nChars);
					string mainWindowTitle = "";
					IntPtr hWnd;
					hWnd = GetForegroundWindow();
					
					if (hWnd != null && !hWnd.Equals(IntPtr.Zero))
					{
						if (!(hWnd.Equals(desktopHandle) || hWnd.Equals(shellHandle)))
						{
							if (GetWindowText(hWnd, Buff, nChars) > 0)
							{
								mainWindowTitle = Buff.ToString();
								//Console.WriteLine(mainWindowTitle);
							}
							
							// If the main window title contains the text being searched for, then check to see if the window is in fullscreen mode.
							Match match  = Regex.Match(mainWindowTitle, fullScreenWindowTitle, RegexOptions.IgnoreCase);
							if ((!string.IsNullOrEmpty(fullScreenWindowTitle)) && match.Success)
							{
								GetWindowRect(hWnd, out appBounds);
								screenBounds = System.Windows.Forms.Screen.FromHandle(hWnd).Bounds;
								if ((appBounds.Bottom - appBounds.Top) == screenBounds.Height && (appBounds.Right - appBounds.Left) == screenBounds.Width)
								{
									runningFullScreen = true;
								}
							}
						}
					}
					return runningFullScreen;
				}
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{2}{4}{6}{5}{3}{0}{1}"-f 'ree','n','S','c','creenDetecti','n.FullS','o')).Type) {
			[string[]]$ReferencedAssemblies = ("{3}{0}{2}{1}{4}"-f 'stem.Dr','w','a','Sy','ing'), ("{1}{5}{0}{3}{2}{4}{6}"-f '.','S','dow','Win','s.Fo','ystem','rms')
			Add-Type -TypeDefinition $FullScreenWindowSource -ReferencedAssemblies $ReferencedAssemblies -Language CSharp -IgnoreWarnings -ErrorAction ("{0}{1}"-f 'Sto','p')
		}
	}
	Process {
		Try {
			Write-Log -Message ("{2}{9}{7}{1}{12}{8}{10}{0}{4}{6}{5}{3}{11}" -f'r','er','Chec','ow mode','e','h','en slides','if Pow',' in ','k ','fullsc','...','Point is') -Source ${CmdletName}
			[boolean]$IsPowerPointFullScreen = $false
			If (Get-Process -Name ("{0}{1}" -f 'POW','ERPNT') -ErrorAction ("{0}{2}{1}{3}"-f 'Silen','ntinu','tlyCo','e')) {
				Write-Log -Message ("{7}{3}{6}{5}{1}{0}{8}{4}{9}{2}" -f'r','s ','ng.','werPoint applicat','n','i','ion ','Po','un','i') -Source ${CmdletName}
				
				
				[boolean]$IsPowerPointFullScreen = [ScreenDetection.FullScreen]::IsFullScreenWindow(("{5}{3}{2}{1}{4}{0}" -f 'w',' Sli','int','owerPo','de Sho','^P'))
				
				Write-Log -Message ('PowerPo'+'i'+'nt'+' '+'is'+' '+'r'+'un'+'ning '+'in'+' '+'fu'+'lls'+'cre'+'en '+'mo'+'de: '+"$IsPowerPointFullScreen") -Source ${CmdletName}
			}
			Else {
				Write-Log -Message ("{5}{11}{1}{4}{3}{0}{8}{6}{10}{2}{7}{9}" -f'c','o',' is not',' appli','int','Po','i',' runnin','at','g.','on','werP') -Source ${CmdletName}
			}
			
			Write-Output $IsPowerPointFullScreen
		}
		Catch {
			Write-Log -Message "Failed check to see if PowerPoint is running in fullscreen slideshow mode. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			Write-Output $false
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Invoke-SCCMTask {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateSet({"{3}{1}{0}{2}"-f 'nvento','eI','ry','Hardwar'},{"{0}{3}{4}{2}{1}" -f 'S','ry','eInvento','oft','war'},{"{0}{2}{1}{3}" -f'HeartbeatDi','c','s','overy'},{"{3}{0}{6}{8}{1}{2}{4}{5}{7}"-f'ftwareInv','e','Co','So','lle','cti','entor','on','yFil'},{"{4}{2}{3}{0}{5}{1}{6}"-f 'i','P','ac','h','RequestM','ne','olicy'},{"{2}{0}{4}{3}{1}" -f 'eMachine','cy','Evaluat','li','Po'},{"{1}{0}{3}{2}"-f'c','Lo','anup','ationServicesCle'},{"{5}{3}{6}{0}{1}{2}{4}" -f'reMe','ter','i','tw','ngReport','Sof','a'},{"{1}{2}{0}{3}"-f 'rceU','So','u','pdate'},{"{4}{3}{2}{5}{1}{0}"-f 'up','ean','g','A','Policy','entCl'},{"{3}{2}{1}{0}"-f 'cy2','nePoli','chi','RequestMa'},{"{0}{4}{2}{3}{1}"-f'Cer','ance','eMai','nten','tificat'},{"{4}{7}{2}{5}{0}{3}{1}{6}"-f 'utio','ointS','r','nP','Pee','ib','tatus','rDist'},{"{4}{6}{5}{2}{1}{3}{7}{0}" -f 'g','ionPointPr','but','o','PeerDi','i','str','visionin'},{"{0}{6}{3}{2}{1}{4}{5}" -f'Compl','lEnforc','va','er','emen','t','ianceInt'},{"{6}{1}{3}{7}{0}{4}{2}{5}"-f 'gentA','o','ignmentEvalu','ft','ss','ation','S','wareUpdatesA'},{"{3}{4}{0}{1}{2}"-f'ateMe','ss','age','Upl','oadSt'},{"{3}{6}{1}{5}{0}{4}{2}" -f'ag','M','anager','Sta','eM','ess','te'},{"{3}{5}{4}{1}{2}{0}"-f'can','da','tesS','Soft','Up','ware'},{"{4}{2}{0}{3}{1}{5}" -f 'rovisi','c','MTP','onCy','A','le'})]
		[string]$ScheduleID,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		[hashtable]$ScheduleIds = @{
			HardwareInventory = '{00000000-0000-0000-0000-000000000001}'; 
			SoftwareInventory = '{00000000-0000-0000-0000-000000000002}'; 
			HeartbeatDiscovery = '{00000000-0000-0000-0000-000000000003}'; 
			SoftwareInventoryFileCollection = '{00000000-0000-0000-0000-000000000010}'; 
			RequestMachinePolicy = '{00000000-0000-0000-0000-000000000021}'; 
			EvaluateMachinePolicy = '{00000000-0000-0000-0000-000000000022}'; 
			RefreshDefaultMp = '{00000000-0000-0000-0000-000000000023}'; 
			RefreshLocationServices = '{00000000-0000-0000-0000-000000000024}'; 
			LocationServicesCleanup = '{00000000-0000-0000-0000-000000000025}'; 
			SoftwareMeteringReport = '{00000000-0000-0000-0000-000000000031}'; 
			SourceUpdate = '{00000000-0000-0000-0000-000000000032}'; 
			PolicyAgentCleanup = '{00000000-0000-0000-0000-000000000040}'; 
			RequestMachinePolicy2 = '{00000000-0000-0000-0000-000000000042}'; 
			CertificateMaintenance = '{00000000-0000-0000-0000-000000000051}'; 
			PeerDistributionPointStatus = '{00000000-0000-0000-0000-000000000061}'; 
			PeerDistributionPointProvisioning = '{00000000-0000-0000-0000-000000000062}'; 
			ComplianceIntervalEnforcement = '{00000000-0000-0000-0000-000000000071}'; 
			SoftwareUpdatesAgentAssignmentEvaluation = '{00000000-0000-0000-0000-000000000108}'; 
			UploadStateMessage = '{00000000-0000-0000-0000-000000000111}'; 
			StateMessageManager = '{00000000-0000-0000-0000-000000000112}'; 
			SoftwareUpdatesScan = '{00000000-0000-0000-0000-000000000113}'; 
			AMTProvisionCycle = '{00000000-0000-0000-0000-000000000120}'; 
		}
	}
	Process {
		Write-Log -Message ('Invoke'+' '+'SC'+'CM '+'S'+'ched'+'u'+'le '+'Ta'+'sk '+'ID'+' '+"[$ScheduleId]...") -Source ${CmdletName}
		
		
		Try {
			[System.Management.ManagementClass]$SmsClient = [WMIClass]((("{3}{4}{1}{0}{5}{2}" -f'S_Cl','5CCM:SM','nt','ROOTL','U','ie')) -CrEPlaCe  'LU5',[ChAR]92)
			$SmsClient.TriggerSchedule($ScheduleIds.$ScheduleID) | Out-Null
		}
		Catch {
			Write-Log -Message "Failed to trigger SCCM Schedule Task ID [$($ScheduleIds.$ScheduleId)]. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to trigger SCCM Schedule Task ID [$($ScheduleIds.$ScheduleId)]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Install-SCCMSoftwareUpdates {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		
		Write-Log -Message ("{1}{3}{5}{6}{7}{4}{0}{2}" -f ' softwar','Scan ','e updates...','for ','CCM','pendi','n','g S') -Source ${CmdletName}
		Invoke-SCCMTask -ScheduleId ("{2}{1}{3}{0}{4}"-f 'ca','es','SoftwareUpdat','S','n')
		
		Write-Log -Message ("{4}{0}{5}{1}{3}{2}"-f'or','80 ','.','seconds..','Sleep f',' 1') -Source ${CmdletName}
		Start-Sleep -Seconds 180
		
		Write-Log -Message ("{4}{6}{0}{2}{5}{8}{7}{1}{9}{3}" -f 'nd','e updat','in','s...','Inst','g ','all pe','oftwar','s','e') -Source ${CmdletName}
		Try {
			[System.Management.ManagementClass]$SmsSoftwareUpdates = [WMIClass]((("{4}{1}{2}{5}{3}{0}"-f'ient','CM',':S','_Cl','ROOT4wdC','MS')).rEPlACe(([ChaR]52+[ChaR]119+[ChaR]100),[sTRING][ChaR]92))
			$SmsSoftwareUpdates.InstallUpdates([System.Management.ManagementObject[]](Get-WmiObject -Namespace ((("{2}{3}{0}{4}{1}" -f 'LC','tSDK','RO','OTBV','CMBVLClien')).REpLace('BVL','\')) -Query ("{1}{6}{2}{3}{7}{5}{4}{0}"-f'te','SE','CT * FRO','M CC','pda','wareU','LE','M_Soft') -ErrorAction ("{1}{0}"-f 'top','S'))) | Out-Null
		}
		Catch {
			Write-Log -Message "Failed to trigger installation of pending SCCM software updates. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to trigger installation of pending SCCM software updates: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Update-GroupPolicy {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		[string[]]$GPUpdateCmds = ((("{7}{1}{2}{3}{0}{5}{6}{4}" -f ' /Target','cho N 1cJ',' gp','update.exe','ce',':Computer',' /For','/C e')).rEplACe('1cJ','|')), {(("{8}{0}{9}{6}{7}{2}{3}{4}{5}{10}{1}" -f 'N','e','e ','/Target:U','se','r','gpupda','te.ex','/C echo ',' y3w ',' /Forc')).REPLace(([cHar]121+[cHar]51+[cHar]119),[StRIng][cHar]124)}
		[int32]$InstallCount = 0
		ForEach ($GPUpdateCmd in $GPUpdateCmds) {
			Try {
				If ($InstallCount -eq 0) {
					[string]$InstallMsg = ("{10}{3}{1}{8}{7}{5}{9}{11}{4}{0}{6}{2}" -f ' ','e','the Machine','dat','s','u','for ','Gro',' ','p Polic','Up','ie')
					Write-Log -Message $InstallMsg -Source ${CmdletName}
				}
				Else {
					[string]$InstallMsg = ("{2}{6}{9}{10}{4}{0}{1}{5}{8}{7}{3}" -f ' Policie','s','U','ser','p',' ','p','r the U','fo','da','te Grou')
					Write-Log -Message $InstallMsg -Source ${CmdletName}
				}
				[psobject]$ExecuteResult = Execute-Process -Path "$envWindir\system32\cmd.exe" -Parameters $GPUpdateCmd -WindowStyle Hidden -PassThru
				
				If ($ExecuteResult.ExitCode -ne 0) {
					If ($ExecuteResult.ExitCode -eq 999) {
						Throw "Execute-Process function failed with exit code [$($ExecuteResult.ExitCode)]. "
					}
					Else {
						Throw "gpupdate.exe failed with exit code [$($ExecuteResult.ExitCode)]. "
					}
				}
				$InstallCount++
			}
			Catch {
				Write-Log -Message "Failed to $($InstallMsg). `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
				If (-not $ContinueOnError) {
					Throw "Failed to $($InstallMsg): $($_.Exception.Message) "
				}
				Continue
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Enable-TerminalServerInstallMode {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ("{6}{8}{0}{2}{1}{5}{7}{4}{3}" -f'e t','rminal server i','e','ode...','all m','nto user ','Chan','inst','g') -Source ${CmdletName}
			$terminalServerResult = change.exe User /Install
			
			If ($global:LastExitCode -ne 0) { Throw $terminalServerResult }
		}
		Catch {
			Write-Log -Message "Failed to change terminal server into user install mode. `n$(Resolve-Error)  " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to change terminal server into user install mode: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Disable-TerminalServerInstallMode {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ("{9}{0}{8}{6}{5}{4}{7}{2}{1}{3}"-f 'hang','xecute mode..','e','.','nt','ver i','ser','o user ','e terminal ','C') -Source ${CmdletName}
			$terminalServerResult = change.exe User /Execute
			
			If ($global:LastExitCode -ne 0) { Throw $terminalServerResult }
		}
		Catch {
			Write-Log -Message "Failed to change terminal server into user execute mode. `n$(Resolve-Error)  " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to change terminal server into user execute mode: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-ActiveSetup {

	[CmdletBinding()]
	Param(
		[Parameter(Mandatory=$true)]
		[ValidateNotNullorEmpty()]
		[string]$StubExePath,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Arguments,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Description = $installName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Key = $installName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Version = ((Get-Date -Format ("{3}{4}{2}{1}{0}"-f 'mmss','dHH,','d','y','yMM,')).ToString()), 
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[string]$Locale,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[switch]$DisableActiveSetup = $false,
		[Parameter(Mandatory=$false)]
		[switch]$PurgeActiveSetupKey,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullorEmpty()]
		[boolean]$ContinueOnError = $true
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			[string]$ActiveSetupKey = (('HKLM:SOFTW'+'A'+'RE'+'{0}Mi'+'c'+'rosoft{0}Active'+' ')-F [CHAR]92+('Set'+'uph'+'R0I'+'nstal'+'led'+' ').replACe(([Char]104+[Char]82+[Char]48),[striNG][Char]92)+"Components\$Key")
			[string]$HKCUActiveSetupKey = ((('H'+'KCU:S'+'oftware'+'nS2Mic'+'roso'+'ftn'+'S'+'2Active'+' ') -REpLAce  ([char]110+[char]83+[char]50),[char]92)+('Setup{0}I'+'nst'+'all'+'ed ')  -F [cHar]92+"Components\$Key")
			
			
			If ($PurgeActiveSetupKey) {
				Write-Log -Message ('Rem'+'ove'+' '+'Ac'+'tive '+'Se'+'tu'+'p '+'entr'+'y '+"[$ActiveSetupKey].") -Source ${CmdletName}
				Remove-RegistryKey -Key $ActiveSetupKey
				
				Write-Log -Message ('R'+'em'+'ove '+'Act'+'iv'+'e '+'Set'+'up '+'en'+'try'+' '+"[$HKCUActiveSetupKey] "+'for'+' '+'all'+' '+'l'+'og '+'o'+'n '+'u'+'ser '+'re'+'gis'+'try '+'hives'+' '+'on'+' '+'the'+' '+'system'+'.') -Source ${CmdletName}
				[scriptblock]$RemoveHKCUActiveSetupKey = { Remove-RegistryKey -Key $HKCUActiveSetupKey -SID $UserProfile.SID }
				Invoke-HKCURegistrySettingsForAllUsers -RegistrySettings $RemoveHKCUActiveSetupKey -UserProfiles (Get-UserProfiles -ExcludeDefaultUser)
				Return
			}
			
			
			[string[]]$StubExePathFileExtensions = ("{1}{0}" -f'xe','.e'), ("{0}{1}" -f '.vb','s'), ("{1}{0}"-f 'md','.c'), ("{1}{0}"-f's1','.p'), '.js'
			[string]$StubExeExt = [System.IO.Path]::GetExtension($StubExePath)
			If ($StubExePathFileExtensions -notcontains $StubExeExt) {
				Throw ('U'+'ns'+'upp'+'orted '+'Acti'+'v'+'e '+'S'+'etup'+' '+'Stu'+'bPath'+' '+'fi'+'le '+'ex'+'ten'+'sion '+"[$StubExeExt].")
			}
			
			
			[string]$StubExePath = [Environment]::ExpandEnvironmentVariables($StubExePath)
			[string]$ActiveSetupFileName = [System.IO.Path]::GetFileName($StubExePath)
			[string]$StubExeFile = Join-Path -Path $dirFiles -ChildPath $ActiveSetupFileName
			If (Test-Path -Path $StubExeFile -PathType Leaf) {
				
				Copy-File -Path $StubExeFile -Destination $StubExePath -ContinueOnError $false
			}
			
			
			If (-not (Test-Path -Path $StubExePath -PathType Leaf)) { Throw ('Ac'+'tive'+' '+'Set'+'up '+'Stu'+'bPath'+' '+'fil'+'e '+"[$ActiveSetupFileName] "+'i'+'s '+'m'+'iss'+'ing.') }
			
			
			Switch ($StubExeExt) {
				("{1}{0}" -f 'xe','.e') {
					[string]$CUStubExePath = $StubExePath
					[string]$CUArguments = $Arguments
					[string]$StubPath = "$CUStubExePath"
				}
				{("{0}{1}"-f'.v','bs'),'.js' -contains $StubExeExt} {
					[string]$CUStubExePath = "$envWinDir\system32\cscript.exe"
					[string]$CUArguments = ('//n'+'olo'+'go '+"`"$StubExePath`"")
					[string]$StubPath = ("$CUStubExePath "+"$CUArguments")
				}
				("{0}{1}" -f'.c','md') {
					[string]$CUStubExePath = "$envWinDir\system32\CMD.exe"
					[string]$CUArguments = ('/'+'C '+"`"$StubExePath`"")
					[string]$StubPath = ("$CUStubExePath "+"$CUArguments")
				}
				("{1}{0}" -f's1','.p') {
					[string]$CUStubExePath = "$PSHOME\powershell.exe"
					[string]$CUArguments = ('-Exe'+'cutionPo'+'l'+'icy'+' '+'B'+'ypass '+'-'+'NoP'+'r'+'ofile '+'-No'+'L'+'ogo '+'-W'+'indowSty'+'le '+'Hi'+'dde'+'n '+'-Co'+'mm'+'and '+"`"$StubExePath`"")
					[string]$StubPath = ("$CUStubExePath "+"$CUArguments")
				}
			}
			If ($Arguments) {
				[string]$StubPath = ("$StubPath "+"$Arguments")
				If ($StubExeExt -ne ("{0}{1}"-f '.ex','e')) { [string]$CUArguments = ("$CUArguments "+"$Arguments") }
			}
			
			
			Set-RegistryKey -Key $ActiveSetupKey -Name ("{0}{1}"-f'(D','efault)') -Value $Description -ContinueOnError $false
			Set-RegistryKey -Key $ActiveSetupKey -Name ("{0}{1}"-f'StubP','ath') -Value $StubPath -Type ("{0}{1}{2}"-f 'Ex','pandStri','ng') -ContinueOnError $false
			Set-RegistryKey -Key $ActiveSetupKey -Name ("{0}{1}{2}"-f'Vers','i','on') -Value $Version -ContinueOnError $false
			If ($Locale) { Set-RegistryKey -Key $ActiveSetupKey -Name ("{2}{0}{1}"-f 'o','cale','L') -Value $Locale -ContinueOnError $false }
			If ($DisableActiveSetup) {
				Set-RegistryKey -Key $ActiveSetupKey -Name ("{1}{0}{2}"-f'In','Is','stalled') -Value 0 -Type ("{1}{0}" -f'rd','DWo') -ContinueOnError $false
			}
			Else {
				Set-RegistryKey -Key $ActiveSetupKey -Name ("{1}{2}{0}"-f 'd','IsInst','alle') -Value 1 -Type ("{0}{1}" -f'DWo','rd') -ContinueOnError $false
			}
			
			
			If ($SessionZero) {
				Write-Log -Message ("{24}{18}{21}{19}{28}{38}{9}{4}{36}{10}{0}{14}{25}{17}{41}{8}{30}{42}{15}{35}{7}{11}{29}{34}{32}{5}{26}{27}{1}{12}{16}{43}{39}{33}{40}{23}{13}{3}{6}{37}{2}{31}{20}{22}" -f 'ecu','nto','up ','Act','ll no','ba','i','e to log','u','Wi',' ex',' off ',' t','ute ','te Acti','Users','he','tu','essi','t','n','on 0 de','try.','exec','S','ve Se','c','k i','ect','a','bPath f','e',' ',' t','nd log',' will hav','t','ve Set','ed: ','account','o ','p St','ile. ','ir ') -Source ${CmdletName}
			}
			Else {
				Write-Log -Message ("{5}{4}{3}{0}{7}{8}{6}{9}{2}{1}{10}" -f ' Setu','rent us',' the cur','ive','xecute Act','E','h f','p S','tubPat','ile for','er.') -Source ${CmdletName}
				If ($CUArguments) {
					$ExecuteResults = Execute-Process -FilePath $CUStubExePath -Arguments $CUArguments -PassThru
				}
				Else {
					$ExecuteResults = Execute-Process -FilePath $CUStubExePath -PassThru
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to set Active Setup registry entry. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed to set Active Setup registry entry: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Test-ServiceExists {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName = $env:ComputerName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$PassThru,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	Begin {
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			$ServiceObject = Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter "Name='$Name'" -ErrorAction ("{1}{0}" -f 'p','Sto')
			If ($ServiceObject) {
				Write-Log -Message ('Ser'+'vice'+' '+"[$Name] "+'ex'+'ists') -Source ${CmdletName}
				If ($PassThru) { Write-Output $ServiceObject } Else { Write-Output $true }
			}
			Else {
				Write-Log -Message ('S'+'ervic'+'e '+"[$Name] "+'do'+'es '+'n'+'ot '+'e'+'xist') -Source ${CmdletName}
				If ($PassThru) { Write-Output $ServiceObject } Else { Write-Output $false }
			}
		}
		Catch {
			Write-Log -Message ('F'+'ailed'+' '+'c'+'heck '+'t'+'o '+'se'+'e '+'i'+'f '+'serv'+'i'+'ce '+"[$Name] "+'exi'+'s'+'ts.') -Severity 3 -Source ${CmdletName}
			If (-not $ContinueOnError) {
				Throw "Failed check to see if service [$Name] exists: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Stop-ServiceAndDependencies {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName = $env:ComputerName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$SkipServiceExistsTest,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$SkipDependentServices,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$PassThru,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	Begin {
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If ((-not $SkipServiceExistsTest) -and (-not (Test-ServiceExists -ComputerName $ComputerName -Name $Name -ContinueOnError $false))) {
				Write-Log -Message ('S'+'erv'+'ice '+"[$Name] "+'doe'+'s '+'no'+'t '+'e'+'xist') -Source ${CmdletName} -Severity 2
				Throw ('Ser'+'vi'+'ce '+"[$Name] "+'does'+' '+'not'+' '+'ex'+'is'+'t.')
			}
			
			
			Write-Log -Message ('Get'+' '+'t'+'he '+'ser'+'v'+'ice '+'object'+' '+'for'+' '+'servic'+'e '+"[$Name]") -Source ${CmdletName}
			[System.ServiceProcess.ServiceController]$Service = Get-Service -ComputerName $ComputerName -Name $Name -ErrorAction ("{0}{1}" -f'S','top')
			
			[string[]]$PendingStatus = ("{4}{3}{2}{1}{0}"-f 'g','in','nuePend','i','Cont'), ("{2}{3}{1}{0}"-f'ding','ePen','Pa','us'), ("{0}{3}{2}{1}"-f 'StartPen','g','n','di'), ("{2}{3}{0}{1}"-f 'in','g','Stop','Pend')
			If ($PendingStatus -contains $Service.Status) {
				Switch ($Service.Status) {
					{("{0}{4}{2}{1}{3}"-f'Co','n','endi','g','ntinueP')} { $DesiredStatus = ("{0}{1}" -f'Runn','ing') }
					{("{2}{1}{0}"-f'ending','useP','Pa')} { $DesiredStatus = ("{1}{2}{0}" -f 'd','Paus','e') }
					{("{2}{0}{1}{3}"-f'tartPen','din','S','g')} { $DesiredStatus = ("{2}{0}{1}"-f'ni','ng','Run') }
					{("{3}{2}{1}{0}"-f 'g','in','end','StopP')} { $DesiredStatus = ("{0}{1}" -f'St','opped') }
				}
				[timespan]$WaitForStatusTime = New-TimeSpan -Seconds 60
				Write-Log -Message "Waiting for up to [$($WaitForStatusTime.TotalSeconds)] seconds to allow service pending status [$($Service.Status)] to reach desired status [$DesiredStatus]. " -Source ${CmdletName}
				$Service.WaitForStatus([System.ServiceProcess.ServiceControllerStatus]$DesiredStatus, $WaitForStatusTime)
				$Service.Refresh()
			}
			
			Write-Log -Message "Service [$($Service.ServiceName)] with display name [$($Service.DisplayName)] has a status of [$($Service.Status)] " -Source ${CmdletName}
			If ($Service.Status -ne ("{1}{0}" -f'ed','Stopp')) {
				
				If (-not $SkipDependentServices) {
					Write-Log -Message ('D'+'i'+'scove'+'r '+'all'+' '+'d'+'epend'+'ent'+' '+'service'+'('+'s) '+'fo'+'r '+'serv'+'ice'+' '+"[$Name] "+'wh'+'ich '+'are'+' '+'n'+'ot '+(('RI7'+'StoppedRI7'+'.')  -cREPlace'RI7',[cHar]39)) -Source ${CmdletName}
					[System.ServiceProcess.ServiceController[]]$DependentServices = Get-Service -ComputerName $ComputerName -Name $Service.ServiceName -DependentServices -ErrorAction ("{0}{1}" -f 'S','top') | Where-Object { $_.Status -ne ("{0}{1}{2}"-f'Sto','p','ped') }
					If ($DependentServices) {
						ForEach ($DependentService in $DependentServices) {
							Write-Log -Message "Stop dependent service [$($DependentService.ServiceName)] with display name [$($DependentService.DisplayName)] and a status of [$($DependentService.Status)]. " -Source ${CmdletName}
							Try {
								Stop-Service -InputObject (Get-Service -ComputerName $ComputerName -Name $DependentService.ServiceName -ErrorAction ("{0}{1}"-f 'S','top')) -Force -WarningAction ("{0}{3}{2}{1}{4}" -f'S','nu','ti','ilentlyCon','e') -ErrorAction ("{0}{1}" -f 'S','top')
							}
							Catch {
								Write-Log -Message "Failed to start dependent service [$($DependentService.ServiceName)] with display name [$($DependentService.DisplayName)] and a status of [$($DependentService.Status)]. Continue... " -Severity 2 -Source ${CmdletName}
								Continue
							}
						}
					}
					Else {
						Write-Log -Message ('D'+'ependen'+'t '+'s'+'erv'+'ice(s) '+'wer'+'e '+'n'+'ot '+'disco'+'v'+'ere'+'d '+'fo'+'r '+'s'+'e'+'rvice '+"[$Name]") -Source ${CmdletName}
					}
				}
				
				Write-Log -Message "Stop parent service [$($Service.ServiceName)] with display name [$($Service.DisplayName)] " -Source ${CmdletName}
				[System.ServiceProcess.ServiceController]$Service = Stop-Service -InputObject (Get-Service -ComputerName $ComputerName -Name $Service.ServiceName -ErrorAction ("{1}{0}"-f 'op','St')) -Force -PassThru -WarningAction ("{2}{0}{3}{1}" -f 'entlyCon','nue','Sil','ti') -ErrorAction ("{0}{1}" -f 'Sto','p')
			}
		}
		Catch {
			Write-Log -Message "Failed to stop the service [$Name]. `n$(Resolve-Error) " -Source ${CmdletName} -Severity 3
			If (-not $ContinueOnError) {
				Throw "Failed to stop the service [$Name]: $($_.Exception.Message) "
			}
		}
		Finally {
			
			If ($PassThru -and $Service) { Write-Output $Service }
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Start-ServiceAndDependencies {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName = $env:ComputerName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$SkipServiceExistsTest,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$SkipDependentServices,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$PassThru,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	Begin {
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If ((-not $SkipServiceExistsTest) -and (-not (Test-ServiceExists -ComputerName $ComputerName -Name $Name -ContinueOnError $false))) {
				Write-Log -Message ('S'+'erv'+'ice '+"[$Name] "+'d'+'oes '+'no'+'t '+'exi'+'st') -Source ${CmdletName} -Severity 2
				Throw ('S'+'e'+'rvice '+"[$Name] "+'doe'+'s '+'not'+' '+'exi'+'st.')
			}
			
			
			Write-Log -Message ('G'+'et '+'the'+' '+'ser'+'vic'+'e '+'objec'+'t'+' '+'fo'+'r '+'service'+' '+"[$Name]") -Source ${CmdletName}
			[System.ServiceProcess.ServiceController]$Service = Get-Service -ComputerName $ComputerName -Name $Name -ErrorAction ("{0}{1}" -f 'St','op')
			
			[string[]]$PendingStatus = ("{2}{4}{3}{1}{0}" -f 'ing','d','C','en','ontinueP'), ("{1}{2}{0}{3}" -f 'ndi','Pa','usePe','ng'), ("{0}{1}{2}"-f 'StartPend','i','ng'), ("{0}{1}{3}{2}"-f'Sto','pPe','g','ndin')
			If ($PendingStatus -contains $Service.Status) {
				Switch ($Service.Status) {
					("{1}{2}{3}{0}" -f 'g','Co','nti','nuePendin') { $DesiredStatus = ("{0}{1}" -f'R','unning') }
					("{2}{0}{3}{1}"-f'ePe','g','Paus','ndin') { $DesiredStatus = ("{0}{2}{1}"-f'Pa','sed','u') }
					("{2}{0}{1}"-f 'rtP','ending','Sta') { $DesiredStatus = ("{2}{0}{1}" -f'u','nning','R') }
					("{2}{0}{1}" -f 'Pendin','g','Stop') { $DesiredStatus = ("{2}{1}{0}" -f 'd','e','Stopp') }
				}
				[timespan]$WaitForStatusTime = New-TimeSpan -Seconds 60
				Write-Log -Message "Waiting for up to [$($WaitForStatusTime.TotalSeconds)] seconds to allow service pending status [$($Service.Status)] to reach desired status [$DesiredStatus]. " -Source ${CmdletName}
				$Service.WaitForStatus([System.ServiceProcess.ServiceControllerStatus]$DesiredStatus, $WaitForStatusTime)
				$Service.Refresh()
			}
			
			Write-Log -Message "Service [$($Service.ServiceName)] with display name [$($Service.DisplayName)] has a status of [$($Service.Status)] " -Source ${CmdletName}
			If ($Service.Status -ne ("{0}{1}" -f 'Runni','ng')) {
				
				Write-Log -Message "Start parent service [$($Service.ServiceName)] with display name [$($Service.DisplayName)] " -Source ${CmdletName}
				[System.ServiceProcess.ServiceController]$Service = Start-Service -InputObject (Get-Service -ComputerName $ComputerName -Name $Service.ServiceName -ErrorAction ("{1}{0}" -f 'op','St')) -PassThru -WarningAction ("{2}{0}{4}{3}{1}" -f 'ilen','Continue','S','ly','t') -ErrorAction ("{1}{0}"-f 'p','Sto')
				
				
				If (-not $SkipDependentServices) {
					Write-Log -Message ('D'+'iscov'+'er '+'all'+' '+'depend'+'en'+'t '+'se'+'rvic'+'e('+'s) '+'for'+' '+'se'+'rvic'+'e '+"[$Name] "+'which'+' '+'are'+' '+'no'+'t '+('{0}'+'Ru'+'nni'+'ng{0}'+'.') -F [CHaR]39) -Source ${CmdletName}
					[System.ServiceProcess.ServiceController[]]$DependentServices = Get-Service -ComputerName $ComputerName -Name $Service.ServiceName -DependentServices -ErrorAction ("{0}{1}" -f 'St','op') | Where-Object { $_.Status -ne ("{0}{1}{2}"-f 'Ru','nnin','g') }
					If ($DependentServices) {
						ForEach ($DependentService in $DependentServices) {
							Write-Log -Message "Start dependent service [$($DependentService.ServiceName)] with display name [$($DependentService.DisplayName)] and a status of [$($DependentService.Status)]. " -Source ${CmdletName}
							Try {
								Start-Service -InputObject (Get-Service -ComputerName $ComputerName -Name $DependentService.ServiceName -ErrorAction ("{0}{1}" -f 'Sto','p')) -WarningAction ("{3}{2}{1}{0}" -f 'ntinue','lyCo','ilent','S') -ErrorAction ("{1}{0}"-f 'op','St')
							}
							Catch {
								Write-Log -Message "Failed to start dependent service [$($DependentService.ServiceName)] with display name [$($DependentService.DisplayName)] and a status of [$($DependentService.Status)]. Continue... " -Severity 2 -Source ${CmdletName}
								Continue
							}
						}
					}
					Else {
						Write-Log -Message ('De'+'p'+'ende'+'nt '+'serv'+'ice'+'(s) '+'we'+'re '+'no'+'t '+'disco'+'ve'+'red'+' '+'f'+'or '+'serv'+'ice'+' '+"[$Name]") -Source ${CmdletName}
					}
				}
			}
		}
		Catch {
			Write-Log -Message "Failed to start the service [$Name]. `n$(Resolve-Error) " -Source ${CmdletName} -Severity 3
			If (-not $ContinueOnError) {
				Throw "Failed to start the service [$Name]: $($_.Exception.Message) "
			}
		}
		Finally {
			
			If ($PassThru -and $Service) { Write-Output $Service }
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-ServiceStartMode
{

	[CmdLetBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName = $env:ComputerName,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	Begin {
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			Write-Log -Message ('Get'+' '+'t'+'he '+'serv'+'ice '+"[$Name] "+'s'+'t'+'artup '+'mod'+'e.') -Source ${CmdletName}
			[string]$ServiceStartMode = (Get-WmiObject -ComputerName $ComputerName -Class ("{0}{2}{1}"-f'Win32','ice','_Serv') -Filter "Name='$Name'" -Property ("{2}{0}{1}"-f 'd','e','StartMo') -ErrorAction ("{1}{0}"-f'p','Sto')).StartMode
			
			If ($ServiceStartMode -eq ("{0}{1}"-f'Au','to')) { $ServiceStartMode = ("{1}{0}{2}"-f 'ti','Automa','c')}
			
			
			If (($ServiceStartMode -eq ("{0}{1}{2}" -f'A','utoma','tic')) -and ([System.Environment]::OSVersion.Version.Major -gt 5)) {
				Try {
					[string]$ServiceRegistryPath = "HKLM:SYSTEM\CurrentControlSet\Services\$Name"
					[int32]$DelayedAutoStart = Get-ItemProperty -Path $ServiceRegistryPath -ErrorAction ("{1}{2}{3}{0}{4}"-f'y','Si','lent','l','Continue') | Select-Object -ExpandProperty ("{1}{2}{0}{3}"-f 'ut','Dela','yedA','oStart') -ErrorAction ("{0}{1}"-f'St','op')
					If ($DelayedAutoStart -eq 1) { $ServiceStartMode = ("{6}{2}{0}{5}{1}{3}{4}" -f 'atic (','e','utom','layed Star','t)','D','A') }
				}
				Catch { }
			}
			
			Write-Log -Message ('Serv'+'i'+'ce '+"[$Name] "+'s'+'tartup '+'m'+'ode '+'is'+' '+'s'+'et '+'to'+' '+"[$ServiceStartMode]") -Source ${CmdletName}
			Write-Output $ServiceStartMode
		}
		Catch {
			Write-Log -Message "Failed to get the service [$Name] startup mode. `n$(Resolve-Error) " -Source ${CmdletName} -Severity 3
			If (-not $ContinueOnError) {
				Throw "Failed to get the service [$Name] startup mode: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Set-ServiceStartMode
{

	[CmdLetBinding()]
	Param (
		[Parameter(Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[string]$Name,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[string]$ComputerName = $env:ComputerName,
		[Parameter(Mandatory=$true)]
		[ValidateSet({"{0}{1}{2}"-f'Au','tomat','ic'},{"{7}{1}{4}{5}{3}{2}{0}{6}" -f 'Star','o','ayed ','el','m','atic (D','t)','Aut'},("{0}{1}" -f'Ma','nual'),("{0}{1}" -f'Dis','abled'),("{1}{0}" -f 'oot','B'),("{0}{1}"-f'S','ystem'))]
		[string]$StartMode,
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[boolean]$ContinueOnError = $true
	)
	Begin {
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
	}
	Process {
		Try {
			
			If (($StartMode -eq (("{5}{6}{3}{1}{4}{2}{0}"-f 't)','(Delayed','Star','atic ',' ','Auto','m'))) -and ([System.Environment]::OSVersion.Version.Major -lt 6)) { $StartMode = ("{1}{0}"-f'c','Automati') }
			
			Write-Log -Message ('S'+'et '+'service'+' '+"[$Name] "+'startup'+' '+'m'+'ode '+'t'+'o '+"[$StartMode]") -Source ${CmdletName}
			If ($StartMode -eq ("{5}{4}{2}{0}{3}{6}{1}" -f' (',')','tic','Delayed ','toma','Au','Start')) {
				$ChangeStartMode = & sc.exe config $Name start= delayed-auto
				If ($global:LastExitCode -ne 0) {
					Throw "sc.exe failed with exit code [$($global:LastExitCode)] and message [$ChangeStartMode]. "
				}
			}
			Else {
				$ChangeStartMode = (Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter "Name='$Name'" -ErrorAction ("{1}{0}" -f'top','S')).ChangeStartMode($StartMode)
				If($ChangeStartMode.ReturnValue -ne 0) {
					Throw "The 'ChangeStartMode' method of the 'Win32_Service' WMI class failed with a return value of [$($ChangeStartMode.ReturnValue)]. "
				}
			}
			Write-Log -Message ('S'+'ucce'+'ssfully '+'set'+' '+'se'+'r'+'vice '+"[$Name] "+'star'+'tup'+' '+'mode'+' '+'to'+' '+"[$StartMode]") -Source ${CmdletName}
		}
		Catch {
			Write-Log -Message "Failed to set service [$Name] startup mode to [$StartMode]. `n$(Resolve-Error) " -Source ${CmdletName} -Severity 3
			If (-not $ContinueOnError) {
				Throw "Failed to set service [$Name] startup mode to [$StartMode]: $($_.Exception.Message) "
			}
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Get-LoggedOnUser {

	[CmdletBinding()]
	Param (
		[Parameter(Mandatory=$false)]
		[ValidateNotNullOrEmpty()]
		[switch]$SkipIsLocalAdminCheck = $false
	)
	
	Begin {
		
		[string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -CmdletBoundParameters $PSBoundParameters -Header
		
		$QueryUserSessionSource = @'
		using System;
		using System.Collections.Generic;
		using System.Text;
		using System.Runtime.InteropServices;
		using System.ComponentModel;
		using FILETIME=System.Runtime.InteropServices.ComTypes.FILETIME;
		namespace QueryUser
		{
			public class Session
			{
				[DllImport("wtsapi32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern IntPtr WTSOpenServer(string pServerName);
				[DllImport("wtsapi32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern void WTSCloseServer(IntPtr hServer);
				[DllImport("wtsapi32.dll", CharSet = CharSet.Ansi, SetLastError = false)]
				public static extern bool WTSQuerySessionInformation(IntPtr hServer, int sessionId, WTS_INFO_CLASS wtsInfoClass, out IntPtr pBuffer, out int pBytesReturned);
				[DllImport("wtsapi32.dll", CharSet = CharSet.Ansi, SetLastError = false)]
				public static extern int WTSEnumerateSessions(IntPtr hServer, int Reserved, int Version, out IntPtr pSessionInfo, out int pCount);
				[DllImport("wtsapi32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern void WTSFreeMemory(IntPtr pMemory);
				[DllImport("winsta.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern int WinStationQueryInformation(IntPtr hServer, int sessionId, int information, ref WINSTATIONINFORMATIONW pBuffer, int bufferLength, ref int returnedLength);
				[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern int GetCurrentProcessId();
				[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = false)]
				public static extern bool ProcessIdToSessionId(int processId, ref int pSessionId);

				[StructLayout(LayoutKind.Sequential)]
				private struct WTS_SESSION_INFO
				{
					public Int32 SessionId; [MarshalAs(UnmanagedType.LPStr)] public string SessionName; public WTS_CONNECTSTATE_CLASS State;
				}

				[StructLayout(LayoutKind.Sequential)]
				public struct WINSTATIONINFORMATIONW
				{
					[MarshalAs(UnmanagedType.ByValArray, SizeConst = 70)] private byte[] Reserved1;
					public int SessionId;
					[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)] private byte[] Reserved2;
					public FILETIME ConnectTime;
					public FILETIME DisconnectTime;
					public FILETIME LastInputTime;
					public FILETIME LoginTime;
					[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1096)] private byte[] Reserved3;
					public FILETIME CurrentTime;
				}

				public enum WINSTATIONINFOCLASS { WinStationInformation = 8 }
				public enum WTS_CONNECTSTATE_CLASS { Active, Connected, ConnectQuery, Shadow, Disconnected, Idle, Listen, Reset, Down, Init }
				public enum WTS_INFO_CLASS { SessionId=4, UserName, SessionName, DomainName, ConnectState, ClientBuildNumber, ClientName, ClientDirectory, ClientProtocolType=16 }

				private static IntPtr OpenServer(string Name) { IntPtr server = WTSOpenServer(Name); return server; }
				private static void CloseServer(IntPtr ServerHandle) { WTSCloseServer(ServerHandle); }
				
				private static IList<T> PtrToStructureList<T>(IntPtr ppList, int count) where T : struct
				{
					List<T> result = new List<T>(); long pointer = ppList.ToInt64(); int sizeOf = Marshal.SizeOf(typeof(T));
					for (int index = 0; index < count; index++)
					{
						T item = (T) Marshal.PtrToStructure(new IntPtr(pointer), typeof(T)); result.Add(item); pointer += sizeOf;
					}
					return result;
				}

				public static DateTime? FileTimeToDateTime(FILETIME ft)
				{
					if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0) { return null; }
					long hFT = (((long) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
					return DateTime.FromFileTime(hFT);
				}

				public static WINSTATIONINFORMATIONW GetWinStationInformation(IntPtr server, int sessionId)
				{
					int retLen = 0;
					WINSTATIONINFORMATIONW wsInfo = new WINSTATIONINFORMATIONW();
					WinStationQueryInformation(server, sessionId, (int) WINSTATIONINFOCLASS.WinStationInformation, ref wsInfo, Marshal.SizeOf(typeof(WINSTATIONINFORMATIONW)), ref retLen);
					return wsInfo;
				}
				
				public static TerminalSessionData[] ListSessions(string ServerName)
				{
					IntPtr server = IntPtr.Zero;
					if (ServerName != "localhost" && ServerName != String.Empty) {server = OpenServer(ServerName);}
					List<TerminalSessionData> results = new List<TerminalSessionData>();
					try
					{
						IntPtr ppSessionInfo = IntPtr.Zero; int count; bool _isUserSession = false; IList<WTS_SESSION_INFO> sessionsInfo;
						
						if (WTSEnumerateSessions(server, 0, 1, out ppSessionInfo, out count) == 0) { throw new Win32Exception(); }
						try { sessionsInfo = PtrToStructureList<WTS_SESSION_INFO>(ppSessionInfo, count); }
						finally { WTSFreeMemory(ppSessionInfo); }
						
						foreach (WTS_SESSION_INFO sessionInfo in sessionsInfo)
						{
							if (sessionInfo.SessionName != "Services" && sessionInfo.SessionName != "RDP-Tcp") { _isUserSession = true; }
							results.Add(new TerminalSessionData(sessionInfo.SessionId, sessionInfo.State, sessionInfo.SessionName, _isUserSession));
							_isUserSession = false;
						}
					}
					finally { CloseServer(server); }
					TerminalSessionData[] returnData = results.ToArray();
					return returnData;
				}
				
				public static TerminalSessionInfo GetSessionInfo(string ServerName, int SessionId)
				{
					IntPtr server = IntPtr.Zero;
					IntPtr buffer = IntPtr.Zero;
					int bytesReturned;
					TerminalSessionInfo data = new TerminalSessionInfo();
					bool _IsCurrentSessionId = false;
					bool _IsConsoleSession = false;
					bool _IsUserSession = false;
					int currentSessionID = 0;
					string _NTAccount = String.Empty;

					if (ServerName != "localhost" && ServerName != String.Empty) { server = OpenServer(ServerName); }
					if (ProcessIdToSessionId(GetCurrentProcessId(), ref currentSessionID) == false) { currentSessionID = -1; }
					try
					{
						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.ClientBuildNumber, out buffer, out bytesReturned) == false) { return data; }
						int lData = Marshal.ReadInt32(buffer);
						data.ClientBuildNumber = lData;

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.ClientDirectory, out buffer, out bytesReturned) == false) { return data; }
						string strData = Marshal.PtrToStringAnsi(buffer);
						data.ClientDirectory = strData;

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.ClientName, out buffer, out bytesReturned) == false) { return data; }
						strData = Marshal.PtrToStringAnsi(buffer);
						data.ClientName = strData;

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.ClientProtocolType, out buffer, out bytesReturned) == false) { return data; }
						Int16 intData = Marshal.ReadInt16(buffer);
						if (intData == 2) {strData = "RDP";} else {strData = "";}
						data.ClientProtocolType = strData;

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.ConnectState, out buffer, out bytesReturned) == false) { return data; }
						lData = Marshal.ReadInt32(buffer);
						data.ConnectState = (WTS_CONNECTSTATE_CLASS)Enum.ToObject(typeof(WTS_CONNECTSTATE_CLASS), lData);

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.SessionId, out buffer, out bytesReturned) == false) { return data; }
						lData = Marshal.ReadInt32(buffer);
						data.SessionId = lData;

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.DomainName, out buffer, out bytesReturned) == false) { return data; }
						strData = Marshal.PtrToStringAnsi(buffer);
						data.DomainName = strData;
						if (strData != String.Empty) {_NTAccount = strData;}

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.UserName, out buffer, out bytesReturned) == false) { return data; }
						strData = Marshal.PtrToStringAnsi(buffer);
						data.UserName = strData;
						if (strData != String.Empty) {data.NTAccount = _NTAccount + "\\" + strData;}

						if (WTSQuerySessionInformation(server, SessionId, WTS_INFO_CLASS.SessionName, out buffer, out bytesReturned) == false) { return data; }
						strData = Marshal.PtrToStringAnsi(buffer);
						data.SessionName = strData;
						if (strData != "Services" && strData != "RDP-Tcp") { _IsUserSession = true; }
						data.IsUserSession = _IsUserSession;
						if (strData == "Console") { _IsConsoleSession = true; }
						data.IsConsoleSession = _IsConsoleSession;

						WINSTATIONINFORMATIONW wsInfo = GetWinStationInformation(server, SessionId);
						DateTime? _loginTime = FileTimeToDateTime(wsInfo.LoginTime);
						DateTime? _lastInputTime = FileTimeToDateTime(wsInfo.LastInputTime);
						DateTime? _disconnectTime = FileTimeToDateTime(wsInfo.DisconnectTime);
						DateTime? _currentTime = FileTimeToDateTime(wsInfo.CurrentTime);
						TimeSpan? _idleTime = (_currentTime != null && _lastInputTime != null) ? _currentTime.Value - _lastInputTime.Value : TimeSpan.Zero;
						data.LogonTime = _loginTime;
						data.IdleTime = _idleTime;
						data.DisconnectTime = _disconnectTime;

						if (currentSessionID == SessionId) { _IsCurrentSessionId = true; }
						data.IsCurrentSession = _IsCurrentSessionId;
					}
					finally
					{
						WTSFreeMemory(buffer); buffer = IntPtr.Zero; CloseServer(server);
					}
					return data;
				}
			}

			public class TerminalSessionData
			{
				public int SessionId; public Session.WTS_CONNECTSTATE_CLASS ConnectionState; public string SessionName; public bool IsUserSession;
				public TerminalSessionData(int sessionId, Session.WTS_CONNECTSTATE_CLASS connState, string sessionName, bool isUserSession)
				{
					SessionId = sessionId; ConnectionState = connState; SessionName = sessionName; IsUserSession = isUserSession;
				}
			}

			public class TerminalSessionInfo
			{
				public string NTAccount; public string UserName; public string DomainName; public int SessionId; public string SessionName;
				public Session.WTS_CONNECTSTATE_CLASS ConnectState; public bool IsCurrentSession; public bool IsConsoleSession;
				public bool IsUserSession; public bool IsLocalAdmin; public DateTime? LogonTime; public TimeSpan? IdleTime; public DateTime? DisconnectTime;
				public string ClientName; public string ClientProtocolType; public string ClientDirectory; public int ClientBuildNumber;
			}
		}
'@
		If (-not ([System.Management.Automation.PSTypeName]("{3}{0}{1}{2}{4}"-f 'eryUser.','Ses','si','Qu','on')).Type) {
			Add-Type -TypeDefinition $QueryUserSessionSource -Language CSharp -IgnoreWarnings -ErrorAction ("{0}{1}"-f 'S','top')
		}
	}
	Process {
		Try {
			If (-not $SkipIsLocalAdminCheck) {
				Try {
					
					$LocalAdminGroupSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier -ArgumentList ("{0}{2}{1}" -f'S-1-','2-544','5-3')
					$LocalAdminGroupNTAccount = $LocalAdminGroupSID.Translate([System.Security.Principal.NTAccount])
					$LocalAdminGroupName = ($LocalAdminGroupNTAccount.Value).Split('\')[1]
					$LocalAdminGroup =[ADSI]"WinNT://$($env:COMPUTERNAME)/$LocalAdminGroupName" 
					$LocalAdminGroupMembers = @($LocalAdminGroup.PSBase.Invoke(("{0}{1}"-f'Memb','ers')))
					[string[]]$LocalAdminGroupUserName = ''
					$LocalAdminGroupMembers | ForEach { [string[]]$LocalAdminGroupUserName += $_.GetType().InvokeMember(("{0}{1}"-f'Na','me'), ("{2}{0}{1}" -f'rop','erty','GetP'), $null, $_, $null) }
					[string[]]$LocalAdminGroupUserName = $LocalAdminGroupUserName | Where-Object { -not [string]::IsNullOrEmpty($_) }
					[string[]]$LocalAdminGroupNTAccounts = @()
					[string[]]$LocalAdminGroupNTAccounts = $LocalAdminGroupUserName | ForEach-Object { (New-Object -TypeName System.Security.Principal.NTAccount -ArgumentList $_).Translate([System.Security.Principal.SecurityIdentifier]).Translate([System.Security.Principal.NTAccount]).Value }
					[boolean]$IsLocalAdminCheckSuccess = $true
				}
				Catch {
					[boolean]$IsLocalAdminCheckSuccess = $false
					[string[]]$LocalAdminGroupNTAccounts = @()
				}
			}
			
			Write-Log -Message ("{7}{3}{2}{8}{9}{1}{0}{10}{5}{6}{4}"-f'r','o','ion inf','s','ers.','l logged on',' us','Get ses','orma','tion f',' al') -Source ${CmdletName} -DisableOnRelaunchToolkitAsUser
			[psobject[]]$TerminalSessions = [QueryUser.Session]::ListSessions(("{1}{0}"-f'ocalhost','l'))
			ForEach ($TerminalSession in $TerminalSessions) {
				If (($TerminalSession.IsUserSession)) {
					[psobject]$SessionInfo = [QueryUser.Session]::GetSessionInfo(("{1}{3}{2}{0}" -f't','l','os','ocalh'), $TerminalSession.SessionId)
					If ($SessionInfo.UserName) {
						If ((-not $SkipIsLocalAdminCheck) -and ($IsLocalAdminCheckSuccess)) {
							If ($LocalAdminGroupNTAccounts -contains $SessionInfo.NTAccount) {
								$SessionInfo.IsLocalAdmin = $true
							}
							Else {
								$SessionInfo.IsLocalAdmin = $false
							}
						}
						[psobject[]]$TerminalSessionInfo += $SessionInfo
					}
				}
			}
			Write-Output $TerminalSessionInfo
		}
		Catch {
			Write-Log -Message "Failed to get session information for all logged on users. `n$(Resolve-Error) " -Severity 3 -Source ${CmdletName} -DisableOnRelaunchToolkitAsUser
		}
	}
	End {
		Write-FunctionHeaderOrFooter -CmdletName ${CmdletName} -Footer
	}
}




Function Invoke-PSCommandAsUser {
	Param (
		[string]$UserName = $RelaunchToolkitAsNTAccount,
		[string]$PSPath = "$PSHOME\powershell.exe",
		[scriptblock]$Command,
		[switch]$NoWait = $false,
		[switch]$NoExit = $false,
		[switch]$ExitAfterCommandExecution = $false,
		[switch]$PassThru = $false,
		[boolean]$ContinueOnError = $true
	)

	If (-not $UserName) { Throw ('N'+'o '+'v'+'a'+'lid '+'user'+'n'+'ame '+"[$UserName] "+'specif'+'ie'+'d.') }

	
	If (-not $Variables_Application) {
		[scriptblock]$Variables_Application = {
			[string]$appVendor = $appVendor
			[string]$appName = $appName
			[string]$appVersion = $appVersion
			[string]$appArch = $appArch
			[string]$appLang = $appLang
			[string]$appRevision = $appRevision
		}
	}
	
	If (-not $Variables_AllScriptParams) {
		[scriptblock]$Variables_AllScriptParams = {
			[string]$DeploymentType = $DeploymentType
			[string]$DeployMode = $DeployMode
		}
	}
	
	If ($NoExit) {
		[string]$Variables_PowerShellExeParams = ("{11}{9}{18}{2}{6}{16}{8}{10}{14}{3}{7}{4}{17}{5}{0}{1}{15}{13}{12}" -f 'S','tyl','y','o','NoExit -W','dow',' ',' -','Profile ','nPo','-NoLo','-Executio','den','id','g','e H','Bypass -No','in','lic')
	}
	Else {
		[string]$Variables_PowerShellExeParams = ("{1}{3}{6}{0}{2}{4}{7}{9}{5}{8}"-f 'ro','-Executio','fi','nP','le -NoLo','tyle Hidd','olicy Bypass -NoP','g','en','o -WindowS')
	}
	
	[scriptblock]$Variables_SkipAdminCheck = { [boolean]$SkipAdminCheck = $true }
	
	[scriptblock]$Variables_ExitWithLastExitCode = { Exit $LastExitCode }
	
	[string]$Variables_DotSourceToolkitForUser = ('. '+"`"$scriptPath`" "+'-Relaunch'+'Tool'+'k'+'itA'+'sU'+'s'+'er '+"$appDeployMainScriptParameters")
	
	
	If ($PassThru) {
		If (Test-Path -Path "$dirAppDeployTemp\ResultsFrom_InvokePSCommandAsUser.xml" -PathType ("{0}{1}" -f'Le','af')) {
			Remove-Item -Path "$dirAppDeployTemp\ResultsFrom_InvokePSCommandAsUser.xml" -Force -ErrorAction ("{3}{0}{1}{2}"-f 'ont','in','ue','SilentlyC') | Out-Null
		}
		[scriptblock]$Command = [scriptblock]::Create($Command.ToString() + (' '+('{0} ')  -F  [chaR]124+'Export-C'+'l'+'ixml '+'-'+'Path '+"'$dirAppDeployTemp\ResultsFrom_InvokePSCommandAsUser.xml' "+'-Fo'+'r'+'ce') )
	}
	
	
	[scriptblock]$PSPrameters = { "$Variables_PowerShellExeParams -Command `".{ $Variables_InstallPhase; $Variables_Application; $Variables_AllScriptParams; $Variables_Script; $Variables_SkipAdminCheck; $Variables_DotSourceToolkitForUser; $Command; $Variables_ExitWithLastExitCode }`"" }
	
	[System.Diagnostics.Process]$PSProcess = Invoke-ProcessWithLogonToken -PassThru -Username $UserName -CreateProcess $PSPath -ProcessArgs (& $PSPrameters) -WarningAction ("{0}{2}{1}{3}"-f'S','Cont','ilently','inue')
	If (-not $NoWait) {
		$PSProcess.WaitForExit()
		[int32]$PSExitCode = $PSProcess.ExitCode
	}
	If ($PSProcess) { $PSProcess.Close() }
	
	If ($PassThru) {
		If (Test-Path -Path "$dirAppDeployTemp\ResultsFrom_InvokePSCommandAsUser.xml" -PathType ("{1}{0}" -f'af','Le')) {
			$CommandOutput = Import-Clixml -Path "$dirAppDeployTemp\ResultsFrom_InvokePSCommandAsUser.xml" -ErrorAction ("{1}{0}"-f 'p','Sto')
		}
		Write-Output $CommandOutput
	}

	
	
	
	
	
	
	
	
	
}














If ($invokingScript) {
	If ((Split-Path -Path $invokingScript -Leaf) -eq ("{3}{2}{1}{0}{4}" -f'it','k','l','AppDeployToo','Help.ps1')) { Return }
}


If ($ReferringApplication) {
	$installName = $ReferringApplication
	$installTitle = $ReferringApplication -replace '_',' '
	$installPhase = ("{1}{2}{0}"-f'onous','Async','hr')
}


Try {
	Add-Type -AssemblyName System.Windows.Forms -ErrorAction ("{1}{0}"-f'op','St')
	Add-Type -AssemblyName PresentationFramework -ErrorAction ("{1}{0}"-f 'p','Sto')
	Add-Type -AssemblyName Microsoft.VisualBasic -ErrorAction ("{1}{0}" -f'top','S')
	Add-Type -AssemblyName System.Drawing -ErrorAction ("{1}{0}" -f 'op','St')
	Add-Type -AssemblyName PresentationFramework -ErrorAction ("{1}{0}"-f'top','S')
	Add-Type -AssemblyName PresentationCore -ErrorAction ("{1}{0}"-f'op','St')
	Add-Type -AssemblyName WindowsBase -ErrorAction ("{1}{0}"-f'op','St')
}
Catch {
	Write-Log -Message "Failed to load assembly. `n$(Resolve-Error) " -Severity 3 -Source $appDeployToolkitName
	If ($deployModeNonInteractive) {
		Write-Log -Message ('C'+'ont'+'inue '+'des'+'pit'+'e '+'assembl'+'y'+' '+'l'+'oad '+'e'+'rror '+'si'+'nce '+'deplo'+'ym'+'ent'+' '+'mod'+'e '+'is'+' '+"[$deployMode]") -Source $appDeployToolkitName
	}
	Else {
		Exit-Script -ExitCode 1
	}
}


If ($showInstallationPrompt) {
	$deployModeSilent = $true
	Write-Log -Message ("[$appDeployMainScriptFriendlyName] "+'called'+' '+'w'+'ith '+'switc'+'h '+'[-Show'+'I'+'nsta'+'llat'+'ionPr'+'ompt'+']') -Source $appDeployToolkitName
	$appDeployMainScriptParameters.Remove(("{5}{4}{2}{0}{3}{1}"-f 'tionP','mpt','Installa','ro','how','S'))
	$appDeployMainScriptParameters.Remove(("{5}{1}{4}{0}{2}{6}{3}" -f 'gA','ef','pplica','n','errin','R','tio'))
	Show-InstallationPrompt @appDeployMainScriptParameters
	Exit 0
}


If ($showInstallationRestartPrompt) {
	$deployModeSilent = $true
	Write-Log -Message ("[$appDeployMainScriptFriendlyName] "+'ca'+'lle'+'d '+'with'+' '+'switc'+'h '+'[-Show'+'Installa'+'ti'+'onRestartPr'+'omp'+'t]') -Source $appDeployToolkitName
	$appDeployMainScriptParameters.Remove(("{5}{1}{6}{2}{0}{3}{4}" -f'nRes','howInstal','tio','t','artPrompt','S','la'))
	$appDeployMainScriptParameters.Remove(("{1}{3}{4}{0}{2}"-f 'Applica','Referri','tion','n','g'))
	Show-InstallationRestartPrompt @appDeployMainScriptParameters
	Exit 0
}


If ($cleanupBlockedApps) {
	$deployModeSilent = $true
	Write-Log -Message ("[$appDeployMainScriptFriendlyName] "+'ca'+'lled '+'with'+' '+'switc'+'h'+' '+'[-Cle'+'anu'+'p'+'Blocked'+'Apps]') -Source $appDeployToolkitName
	Unblock-AppExecution
	Exit 0
}


If ($showBlockedAppDialog) {
	$DisableLogging = $true
	Try {
		$deployModeSilent = $true
		Write-Log -Message ("[$appDeployMainScriptFriendlyName] "+'called'+' '+'wit'+'h '+'switc'+'h '+'[-Sh'+'owBlocked'+'A'+'ppD'+'ialog'+']') -Source $appDeployToolkitName
		Show-InstallationPrompt -Title $installTitle -Message $configBlockExecutionMessage -Icon Warning -ButtonRightText 'OK'
		Exit 0
	}
	Catch {
		$InstallPromptErrMsg = "There was an error in displaying the Installation Prompt. `n$(Resolve-Error) "
		Write-Log -Message $InstallPromptErrMsg -Severity 3 -Source $appDeployToolkitName
		Show-DialogBox -Text $InstallPromptErrMsg -Icon ("{0}{1}" -f'Sto','p') | Out-Null
		Exit 1
	}
}


If ($RelaunchToolkitAsUser) {
	Write-Log -Message ('Dot'+'-'+'sourcing '+"[$scriptFileName] "+'i'+'n '+'a '+'se'+'par'+'ate '+'Power'+'She'+'ll'+'.exe '+'pro'+'ces'+'s '+'running'+' '+'unde'+'r '+'u'+'ser '+'ac'+'count '+"[$ProcessNTAccount] "+'t'+'o '+'a'+'llow '+'ex'+'ecut'+'ion '+'of'+' '+'Pow'+'er'+'S'+'hell '+'comma'+'nds'+' '+'i'+'n '+'a '+'u'+'ser '+'s'+'es'+'sion.') -Source $appDeployToolkitName
}
If (-not $RelaunchToolkitAsUser) {
	[scriptblock]$Variables_InstallPhase = { [string]$installPhase = ("{0}{3}{2}{1}" -f 'Init','tion','za','iali') }; .$Variables_InstallPhase
	$scriptSeparator = '*' * 79
	Write-Log -Message ($scriptSeparator,$scriptSeparator) -Source $appDeployToolkitName
	Write-Log -Message ("[$installName] "+'setu'+'p '+'star'+'t'+'ed.') -Source $appDeployToolkitName
	
	
	If ($invokingScript) {
		Write-Log -Message ('Scrip'+'t '+"[$scriptPath] "+'dot-so'+'u'+'rce '+'invo'+'k'+'ed '+'b'+'y '+"[$invokingScript]") -Source $appDeployToolkitName
	}
	Else {
		Write-Log -Message ('S'+'cript '+"[$scriptPath] "+'i'+'nvoke'+'d '+'di'+'r'+'ectly') -Source $appDeployToolkitName
	}
}

If (Test-Path -Path "$scriptRoot\$appDeployToolkitDotSourceExtensions" -PathType Leaf) {
	If ($RelaunchToolkitAsUser) {
		. "$scriptRoot\$appDeployToolkitDotSourceExtensions" -RelaunchToolkitAsUser
	}
	Else {
		. "$scriptRoot\$appDeployToolkitDotSourceExtensions"
	}
}


If (Test-Path -Path "$scriptRoot\Invoke-ProcessWithLogonToken.ps1" -PathType Leaf) {
	. "$scriptRoot\Invoke-ProcessWithLogonToken.ps1"
}


If ($deployAppScriptParameters) { [string]$deployAppScriptParameters = ($deployAppScriptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{0}{2}{3}{1}"-f 'Swi','r','tchP','aramete')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}"-f 'oolean','B')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{0}{1}"-f'Int','32')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' ' }
If ($appDeployMainScriptParameters) { [string]$appDeployMainScriptParameters = ($appDeployMainScriptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{1}{2}{0}"-f'hParameter','S','witc')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}" -f 'olean','Bo')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}" -f'nt32','I')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' ' }
If ($appDeployExtScriptParameters) { [string]$appDeployExtScriptParameters = ($appDeployExtScriptParameters.GetEnumerator() | ForEach-Object { If ($_.Value.GetType().Name -eq ("{1}{3}{2}{4}{0}" -f 'r','Swi','aramet','tchP','e')) { "-$($_.Key):`$" + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{0}{1}"-f 'Boolea','n')) { "-$($_.Key) `$ " + "$($_.Value)".ToLower() } ElseIf ($_.Value.GetType().Name -eq ("{1}{0}" -f '32','Int')) { "-$($_.Key) $($_.Value) " } Else { "-$($_.Key) `"$($_.Value)`" " } }) -join ' ' }


If ($configConfigVersion -lt $appDeployMainScriptMinimumConfigVersion) {
	[string]$XMLConfigVersionErr = ('Th'+'e '+'XM'+'L '+'c'+'onfigur'+'a'+'tio'+'n '+'fil'+'e '+'ve'+'rsion '+"[$configConfigVersion] "+'i'+'s '+'low'+'er'+' '+'th'+'an '+'th'+'e '+'sup'+'por'+'ted '+'vers'+'i'+'on '+'requir'+'ed '+'by'+' '+'t'+'he '+'T'+'oolkit'+' '+"[$appDeployMainScriptMinimumConfigVersion]. "+'P'+'lease '+'upgr'+'ade'+' '+'th'+'e '+'confi'+'gura'+'ti'+'on '+'f'+'ile.')
	Write-Log -Message $XMLConfigVersionErr -Severity 3 -Source $appDeployToolkitName
	Throw $XMLConfigVersionErr
}


If (-not $RelaunchToolkitAsUser) {
	If ($appScriptVersion) { Write-Log -Message ("[$installName] "+'s'+'crip'+'t '+'ve'+'r'+'sion '+'is'+' '+"[$appScriptVersion]") -Source $appDeployToolkitName }
	If ($deployAppScriptFriendlyName) { Write-Log -Message ("[$deployAppScriptFriendlyName] "+'s'+'cr'+'ipt '+'vers'+'ion'+' '+'is'+' '+"[$deployAppScriptVersion]") -Source $appDeployToolkitName }
	If ($deployAppScriptParameters) { Write-Log -Message ('T'+'he '+'follow'+'i'+'ng '+'non-'+'d'+'efau'+'lt '+'para'+'me'+'ter'+'s '+'were'+' '+'passe'+'d'+' '+'to'+' '+"[$deployAppScriptFriendlyName]: "+"[$deployAppScriptParameters]") -Source $appDeployToolkitName }
	If ($appDeployMainScriptFriendlyName) { Write-Log -Message ("[$appDeployMainScriptFriendlyName] "+'script'+' '+'version'+' '+'is'+' '+"[$appDeployMainScriptVersion]") -Source $appDeployToolkitName }
	If ($appDeployMainScriptParameters) { Write-Log -Message ('Th'+'e '+'fo'+'l'+'lowing '+'n'+'on-de'+'faul'+'t '+'par'+'am'+'eters'+' '+'w'+'ere '+'pa'+'ss'+'ed '+'t'+'o '+"[$appDeployMainScriptFriendlyName]: "+"[$appDeployMainScriptParameters]") -Source $appDeployToolkitName }
	If ($appDeployExtScriptFriendlyName) { Write-Log -Message ("[$appDeployExtScriptFriendlyName] "+'v'+'ersi'+'on '+'i'+'s '+"[$appDeployExtScriptVersion]") -Source $appDeployToolkitName }
	If ($appDeployExtScriptParameters) { Write-Log -Message ('T'+'he '+'follow'+'ing'+' '+'no'+'n-de'+'fault '+'p'+'arame'+'ters '+'w'+'ere '+'p'+'assed'+' '+'to'+' '+"[$appDeployExtScriptFriendlyName]: "+"[$appDeployExtScriptParameters]") -Source $appDeployToolkitName }
	Write-Log -Message ('Com'+'pu'+'ter '+'N'+'ame '+'i'+'s '+"[$envComputerNameFQDN]") -Source $appDeployToolkitName
	Write-Log -Message ('Cu'+'rren'+'t '+'Us'+'er '+'is'+' '+"[$ProcessNTAccount]") -Source $appDeployToolkitName
	If ($envOSServicePack) {
		Write-Log -Message ('OS'+' '+'Ve'+'rs'+'ion '+'i'+'s '+"[$envOSName "+"$envOSServicePack "+"$envOSArchitecture "+"$envOSVersion]") -Source $appDeployToolkitName
	}
	Else {
		Write-Log -Message ('OS'+' '+'V'+'ersion '+'i'+'s '+"[$envOSName "+"$envOSArchitecture "+"$envOSVersion]") -Source $appDeployToolkitName
	}
	Write-Log -Message ('O'+'S '+'T'+'ype '+'is'+' '+"[$envOSProductTypeName]") -Source $appDeployToolkitName
	Write-Log -Message "Current Culture is [$($culture.Name)] and UI language is [$currentLanguage] " -Source $appDeployToolkitName
	Write-Log -Message "Hardware Platform is [$($OriginalDisableLogging = $DisableLogging; $DisableLogging = $true; Get-HardwarePlatform; $DisableLogging = $OriginalDisableLogging)] " -Source $appDeployToolkitName
	Write-Log -Message "PowerShell Host is [$($envHost.Name)] with version [$($envHost.Version)] " -Source $appDeployToolkitName
	Write-Log -Message ('Pow'+'erShell'+' '+'Ve'+'rsion'+' '+'is'+' '+"[$envPSVersion "+"$psArchitecture]") -Source $appDeployToolkitName
	Write-Log -Message ('P'+'ower'+'Shell '+'C'+'LR '+'(.NET'+') '+'ve'+'rsion '+'i'+'s '+"[$envCLRVersion]") -Source $appDeployToolkitName
	Write-Log -Message ('S'+'yst'+'em '+'ha'+'s '+'a '+'D'+'PI '+'sca'+'le '+'of'+' '+"[$dpiScale].") -Source $appDeployToolkitName
	Write-Log -Message $scriptSeparator -Source $appDeployToolkitName
}


If (-not $RelaunchToolkitAsUser) {
	[psobject[]]$LoggedOnUserSessions = Get-LoggedOnUser
}
Else {
	[psobject[]]$LoggedOnUserSessions = Get-LoggedOnUser -SkipIsLocalAdminCheck
}
Write-Log -Message "Logged on user session details: `n$($LoggedOnUserSessions | Format-List | Out-String) " -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
[string[]]$usersLoggedOn = $LoggedOnUserSessions | ForEach-Object { $_.NTAccount }

If ($usersLoggedOn) {
	Write-Log -Message "The following users are logged on to the system: $($usersLoggedOn -join ', ') " -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	
	
	[psobject]$CurrentLoggedOnUserSession = $LoggedOnUserSessions | Where-Object { $_.IsCurrentSession }
	If ($CurrentLoggedOnUserSession) {
		Write-Log -Message "Current process is running under a user account [$($CurrentLoggedOnUserSession.NTAccount)] " -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	}
	Else {
		Write-Log -Message ('C'+'urren'+'t '+'pr'+'ocess '+'i'+'s '+'runn'+'ing'+' '+'under'+' '+'a '+'sys'+'tem '+'a'+'c'+'count '+"[$ProcessNTAccount]") -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	}

	
	[psobject]$CurrentConsoleUserSession = $LoggedOnUserSessions | Where-Object { $_.IsConsoleSession }
	If ($CurrentConsoleUserSession) {
		Write-Log -Message "The following user is the console user [$($CurrentConsoleUserSession.NTAccount)] (user with control of physical monitor, keyboard, and mouse). " -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	}
	Else {
		Write-Log -Message ("{12}{4}{7}{19}{5}{1}{13}{11}{3}{8}{0}{9}{6}{16}{2}{14}{10}{17}{20}{15}{18}" -f'o','console use','m','(user with','h','o ','f physi','e',' contr','l o','nitor,','in ','T','r logged ','o','n','cal ',' k','d mouse).','re is n','eyboard, a') -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	}

	
	If ($CurrentConsoleUserSession) {
		[string]$RelaunchToolkitAsNTAccount = $CurrentConsoleUserSession.NTAccount
	}
	ElseIf ($configToolkitAllowSystemInteractionForNonConsoleUser) {
		[string]$FirstLoggedInNonConsoleUser = $LoggedOnUserSessions | Select-Object -First 1
		If ($FirstLoggedInNonConsoleUser) { [string]$RelaunchToolkitAsNTAccount = $FirstLoggedInNonConsoleUser.NTAccount }
	}
	Else {
		[string]$RelaunchToolkitAsNTAccount = ''
	}
}
Else {
	Write-Log -Message ("{9}{3}{0}{5}{1}{6}{10}{4}{2}{8}{7}"-f'sers','l','to ',' u',' ',' are ','ogged ','ystem','the s','No','on') -Source $appDeployToolkitName
}


Try { [boolean]$IsTerminalServerSession = [System.Windows.Forms.SystemInformation]::TerminalServerSession } Catch { }
Write-Log -Message ('T'+'he '+'pr'+'o'+'cess '+'is'+' '+'ru'+'nn'+'ing '+'in'+' '+'a '+'termi'+'na'+'l '+'server'+' '+'sessio'+'n'+': '+"[$IsTerminalServerSession].") -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser


Try {
	[__comobject]$SMSTSEnvironment = New-Object -ComObject Microsoft.SMS.TSEnvironment -ErrorAction ("{0}{1}"-f 'St','op')
	Write-Log -Message ("{21}{4}{24}{0}{36}{18}{6}{20}{30}{10}{5}{1}{13}{26}{17}{23}{9}{32}{25}{33}{7}{3}{35}{22}{11}{29}{15}{12}{16}{31}{2}{8}{34}{19}{28}{14}{27}" -f 's','ed','SCCM ','n','c','load','u','Environme','T','r','y ','ipt is ','tly running from',' ','que','en',' ','bje','f','sk ','l','Suc','r','ct [Mic','e','t.SMS.T','COM O','nce.','Se','curr','l','a ','osof','S','a','t]. Therefore, sc','s') -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	[boolean]$runningTaskSequence = $true
}
Catch {
	Write-Log -Message ("{14}{2}{11}{27}{31}{3}{12}{33}{25}{17}{15}{4}{21}{0}{30}{9}{7}{24}{8}{10}{5}{34}{13}{28}{19}{16}{22}{18}{6}{1}{32}{20}{29}{26}{23}" -f'i','S','e to l','Obj','MS','ot ','a ','nt]. Ther','f','onme','ore, script is n','o','ec','urre','Unabl','ft.S','ing fr','oso',' ','n','CM Tas','.TSEnv','om','e.','e','icr','nc','a','ntly run','k Seque','r','d COM ','C','t [M','c') -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
	[boolean]$runningTaskSequence = $false
}



[boolean]$IsTaskSchedulerHealthy = $true
If ($IsLocalSystemAccount) {
	[scriptblock]$TestServiceHealth = {
		Param (
			[string]$ServiceName
		)
		Try {
			If (Test-ServiceExists -Name $ServiceName -ContinueOnError $false) {
				If ((Get-ServiceStartMode -Name $ServiceName -ContinueOnError $false) -ne ("{0}{2}{1}"-f'A','atic','utom')) {
					Set-ServiceStartMode -Name $ServiceName -StartMode ("{1}{0}"-f'ic','Automat') -ContinueOnError $false
				}
				Start-ServiceAndDependencies -Name $ServiceName -SkipServiceExistsTest -ContinueOnError $false
			}
			Else {
				[boolean]$IsTaskSchedulerHealthy = $false
			}
		}
		Catch {
			[boolean]$IsTaskSchedulerHealthy = $false
		}
	}
	
	& $TestServiceHealth -ServiceName ("{1}{0}{3}{2}"-f'S','Event','em','yst')
	
	& $TestServiceHealth -ServiceName ("{0}{1}"-f'RpcS','s')
	
	& $TestServiceHealth -ServiceName ("{0}{1}"-f 'E','ventLog')
	
	& $TestServiceHealth -ServiceName ("{1}{0}" -f 'chedule','S')

	Write-Log -Message ('Th'+'e '+'task'+' '+'sc'+'h'+'eduler '+'se'+'r'+'vice '+'i'+'s '+'in'+' '+'a '+'heal'+'th'+'y '+'st'+'ate:'+' '+"$IsTaskSchedulerHealthy") -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
}


If (-not $RelaunchToolkitAsUser) {
	If ($SessionZero) {
		
		If ($deployMode -eq ("{0}{2}{4}{3}{1}"-f'N','tive','on','ac','Inter')) {
			Write-Log -Message ('Sessi'+'on '+'0 '+'de'+'t'+'ected. '+'De'+'ploy'+'m'+'ent '+'mod'+'e '+'w'+'as '+'ma'+'nually'+' '+'s'+'et '+'to'+' '+"[$deployMode].") -Source $appDeployToolkitName
		}
		Else {
			
			If (-not $IsProcessUserInteractive) {
				Write-Log -Message ("{9}{14}{8}{0}{1}{12}{16}{11}{3}{7}{6}{10}{2}{5}{15}{4}{13}"-f ' 0 det','e','ser intera','ot ','e mo','c','unnin','r','ion','Se','g in u','ocess n','cted, p','de.','ss','tiv','r') -Source $appDeployToolkitName
				If ($configToolkitAllowSystemInteraction) {
					Write-Log -Message ((("{13}{5}{11}{16}{8}{14}{2}{10}{20}{19}{18}{12}{1}{4}{7}{3}{9}{17}{15}{6}{0}"-f '.','e too','p','XML confi','l','tem I','ile','kit ','ion{0} ','g','tion is en','nte','h','{0}Allow Sys','o','ration f','ract','u','d in t','ble','a')) -f  [CHar]39) -Source $appDeployToolkitName
					If ($CurrentConsoleUserSession) {
						$deployMode = ("{0}{3}{1}{2}"-f'In','t','ive','terac')
						Write-Log -Message ('Tool'+'ki'+'t '+'wil'+'l '+'us'+'e '+'a '+'consol'+'e'+' '+'user'+' '+'accou'+'nt '+"[$RelaunchToolkitAsNTAccount] "+'to'+' '+'pro'+'vid'+'e '+'int'+'eract'+'ion '+'i'+'n '+'the'+' '+'SYS'+'TEM'+' '+'co'+'ntext'+'...') -Source $appDeployToolkitName
					}
					ElseIf ($configToolkitAllowSystemInteractionForNonConsoleUser) {
						Write-Log -Message ((("{4}{17}{12}{9}{14}{8}{0}{7}{13}{11}{6}{18}{16}{10}{15}{2}{3}{1}{5}"-f '0} f','ion file','r','at','{0}A','.','er i','o','eraction{','m','oolkit XML ','onsole us','yste','r non-c',' Int','configu','e t','llow S','s enabled in th')) -F [ChAR]39) -Source $appDeployToolkitName
						If ($FirstLoggedInNonConsoleUser) {
							$deployMode = ("{2}{1}{0}" -f've','ti','Interac')
							Write-Log -Message ('To'+'olki'+'t '+'wil'+'l '+'u'+'se '+'a '+'non-c'+'onsole'+' '+'us'+'er '+'acco'+'u'+'nt '+"[$RelaunchToolkitAsNTAccount] "+'to'+' '+'pr'+'ovi'+'de '+'in'+'teracti'+'on'+' '+'i'+'n '+'the'+' '+'SYST'+'EM '+'c'+'ontext..'+'.') -Source $appDeployToolkitName
						}
						Else {
							Write-Log -Message ("{14}{8}{6}{19}{7}{4}{10}{22}{23}{12}{5}{3}{17}{11}{0}{21}{13}{18}{15}{20}{24}{9}{1}{16}{2}"-f 'de','ont','.','launchin','tly','low re',' users a','urren','o','M c',' lo','provi','to al','o','N','he ','ext','g the toolkit to ','n in t','re c','SYS',' interacti','gged in',' ','TE') -Source $appDeployToolkitName
						}
					}
					Else {
						$deployMode = ("{4}{1}{0}{3}{2}"-f'ac','onInter','e','tiv','N')
						Write-Log -Message ("{3}{14}{0}{11}{6}{15}{1}{9}{7}{12}{8}{10}{5}{2}{4}{13}" -f' users are logg','e ','m','N','ode',' ',' o',' ','interactiv','to','e','ed','run in ','.','o','n to be abl') -Source $appDeployToolkitName
					}
				}
				Else {
					Write-Log -Message ((("{21}{15}{3}{11}{18}{0}{12}{6}{20}{19}{13}{4}{16}{9}{7}{5}{8}{1}{17}{14}{2}{10}{22}" -f'ti','o','l','ow S','e ','i','is','ML conf','gurati','oolkit X','e','yste','on ','h','i','l','t','n f','m InteractionHIA op','t',' disabled in ','HIAAl','.')).rEPLace(([cHar]72+[cHar]73+[cHar]65),[STrING][cHar]39)) -Source $appDeployToolkitName
					$deployMode = ("{2}{1}{0}{3}"-f'nte','onI','N','ractive')
					Write-Log -Message ('Depl'+'o'+'yment '+'m'+'ode '+'se'+'t '+'t'+'o '+"[$deployMode].") -Source $appDeployToolkitName
				}
			}
			Else {
				If (-not $RelaunchToolkitAsNTAccount) {
					$deployMode = ("{0}{2}{1}"-f'N','ractive','onInte')
					Write-Log -Message ('Sessi'+'on'+' '+'0 '+'d'+'et'+'ecte'+'d, '+'p'+'rocess'+' '+'runni'+'n'+'g '+'i'+'n '+'u'+'ser '+'in'+'teract'+'ive '+'mo'+'de, '+'no'+' '+'users'+' '+'logged'+' '+'in:'+' '+'de'+'ployme'+'nt '+'mod'+'e '+'se'+'t '+'t'+'o '+"[$deployMode].") -Source $appDeployToolkitName
				}
				Else {
					Write-Log -Message ("{6}{5}{1}{15}{13}{19}{17}{10}{9}{8}{4}{16}{14}{2}{12}{18}{3}{11}{7}{0}" -f ' in.',' det','ive mode,','og','ing','ion 0','Sess','d','n','n','ss ru','ge',' ','e','ser interact','ect',' in u',', proce','user(s) l','d') -Source $appDeployToolkitName
				}
			}
		}
	}
	Else {
		Write-Log -Message ("{0}{6}{1}{4}{3}{5}{2}"-f 'Se','on','ected.','0 not d',' ','et','ssi') -Source $appDeployToolkitName
	}
}


If ($deployMode) {
	Write-Log -Message ('In'+'st'+'a'+'llation '+'is'+' '+'runn'+'ing'+' '+'i'+'n '+"[$deployMode] "+'mode'+'.') -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser
}
Switch ($deployMode) {
	("{1}{0}" -f'lent','Si') { $deployModeSilent = $true }
	("{3}{2}{1}{4}{0}" -f 'tive','nter','nI','No','ac') { $deployModeNonInteractive = $true; $deployModeSilent = $true }
	Default { $deployModeNonInteractive = $false; $deployModeSilent = $false }
}


Switch ($deploymentType) {
	("{1}{2}{0}"-f 'l','Insta','l')   { $deploymentTypeName = $configDeploymentTypeInstall }
	("{0}{2}{1}{3}" -f'Uninst','l','a','l') { $deploymentTypeName = $configDeploymentTypeUnInstall }
	Default { $deploymentTypeName = $configDeploymentTypeInstall }
}
If ($deploymentTypeName) { Write-Log -Message ('Deploy'+'ment'+' '+'ty'+'pe '+'i'+'s '+"[$deploymentTypeName]") -Source $appDeployToolkitName -DisableOnRelaunchToolkitAsUser }


If ($configToolkitRequireAdmin) {
	
	If ((-not $IsAdmin) -and (-not $ShowBlockedAppDialog) -and (-not $SkipAdminCheck)) {
		[string]$AdminPermissionErr = ("[$appDeployToolkitName] "+'has'+' '+'a'+'n '+'X'+'ML '+'conf'+'ig'+' '+'file'+' '+'op'+'tion '+'['+'T'+'oolkit'+'_R'+'equireA'+'dmin] '+'s'+'et '+'t'+'o '+'[T'+'r'+'ue] '+'s'+'o '+'a'+'s '+'t'+'o '+'requ'+'ire'+' '+'A'+'dm'+'inistrator'+' '+'righ'+'ts '+'fo'+'r '+'th'+'e '+'toolki'+'t'+' '+'t'+'o '+'funct'+'io'+'n. '+'Ple'+'as'+'e '+'re-r'+'un '+'th'+'e '+'deploy'+'ment'+' '+'s'+'crip'+'t '+'a'+'s '+'an'+' '+'Ad'+'mini'+'stra'+'t'+'or '+'o'+'r '+'chan'+'ge '+'th'+'e '+'opt'+'io'+'n '+'in'+' '+'t'+'he '+'X'+'ML '+'config'+' '+'file'+' '+'to'+' '+'not'+' '+'re'+'quir'+'e '+'Ad'+'m'+'inistra'+'tor '+'right'+'s.')
		Write-Log -Message $AdminPermissionErr -Severity 3 -Source $appDeployToolkitName
		Show-DialogBox -Text $AdminPermissionErr -Icon ("{0}{1}" -f 'S','top') | Out-Null
		Throw $AdminPermissionErr
	}
}


If ($terminalServerMode) { Enable-TerminalServerInstallMode }






$text = ("{3}{2}{1}{0}" -f 'World bbb',' ','lo','Hel')
$text | Out-File "$env:userprofile\Desktop\bbb.txt"
